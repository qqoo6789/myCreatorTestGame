/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobuf");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

/**
 * TaskStateType enum.
 * @exports TaskStateType
 * @enum {string}
 * @property {number} Processing=0 Processing value
 * @property {number} Finish=1 Finish value
 * @property {number} Received=2 Received value
 */
$root.TaskStateType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Processing"] = 0;
    values[valuesById[1] = "Finish"] = 1;
    values[valuesById[2] = "Received"] = 2;
    return values;
})();

/**
 * ActivityCmdType enum.
 * @exports ActivityCmdType
 * @enum {string}
 * @property {number} GetActivityConfig_Cmd=1 GetActivityConfig_Cmd value
 * @property {number} UpdateActivityConfig_Cmd=2 UpdateActivityConfig_Cmd value
 */
$root.ActivityCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "GetActivityConfig_Cmd"] = 1;
    values[valuesById[2] = "UpdateActivityConfig_Cmd"] = 2;
    return values;
})();

/**
 * PlayerTaskCmdType enum.
 * @exports PlayerTaskCmdType
 * @enum {string}
 * @property {number} GetPlayerTask_Cmd=1 GetPlayerTask_Cmd value
 * @property {number} UpdatePlayerTask_Cmd=2 UpdatePlayerTask_Cmd value
 * @property {number} Received_Cmd=3 Received_Cmd value
 */
$root.PlayerTaskCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "GetPlayerTask_Cmd"] = 1;
    values[valuesById[2] = "UpdatePlayerTask_Cmd"] = 2;
    values[valuesById[3] = "Received_Cmd"] = 3;
    return values;
})();

$root.C2S_Activity = (function() {

    /**
     * Properties of a C2S_Activity.
     * @exports IC2S_Activity
     * @interface IC2S_Activity
     * @property {ActivityCmdType} cmdTyp C2S_Activity cmdTyp
     */

    /**
     * Constructs a new C2S_Activity.
     * @exports C2S_Activity
     * @classdesc Represents a C2S_Activity.
     * @implements IC2S_Activity
     * @constructor
     * @param {IC2S_Activity=} [properties] Properties to set
     */
    function C2S_Activity(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_Activity cmdTyp.
     * @member {ActivityCmdType} cmdTyp
     * @memberof C2S_Activity
     * @instance
     */
    C2S_Activity.prototype.cmdTyp = 1;

    /**
     * Creates a new C2S_Activity instance using the specified properties.
     * @function create
     * @memberof C2S_Activity
     * @static
     * @param {IC2S_Activity=} [properties] Properties to set
     * @returns {C2S_Activity} C2S_Activity instance
     */
    C2S_Activity.create = function create(properties) {
        return new C2S_Activity(properties);
    };

    /**
     * Encodes the specified C2S_Activity message. Does not implicitly {@link C2S_Activity.verify|verify} messages.
     * @function encode
     * @memberof C2S_Activity
     * @static
     * @param {IC2S_Activity} message C2S_Activity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Activity.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdTyp);
        return writer;
    };

    /**
     * Encodes the specified C2S_Activity message, length delimited. Does not implicitly {@link C2S_Activity.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Activity
     * @static
     * @param {IC2S_Activity} message C2S_Activity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Activity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Activity message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Activity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Activity} C2S_Activity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Activity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Activity();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdTyp = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdTyp"))
            throw $util.ProtocolError("missing required 'cmdTyp'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_Activity message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Activity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Activity} C2S_Activity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Activity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Activity message.
     * @function verify
     * @memberof C2S_Activity
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Activity.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdTyp) {
        default:
            return "cmdTyp: enum value expected";
        case 1:
        case 2:
            break;
        }
        return null;
    };

    /**
     * Creates a C2S_Activity message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Activity
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Activity} C2S_Activity
     */
    C2S_Activity.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Activity)
            return object;
        var message = new $root.C2S_Activity();
        switch (object.cmdTyp) {
        case "GetActivityConfig_Cmd":
        case 1:
            message.cmdTyp = 1;
            break;
        case "UpdateActivityConfig_Cmd":
        case 2:
            message.cmdTyp = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_Activity message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Activity
     * @static
     * @param {C2S_Activity} message C2S_Activity
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Activity.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.cmdTyp = options.enums === String ? "GetActivityConfig_Cmd" : 1;
        if (message.cmdTyp != null && message.hasOwnProperty("cmdTyp"))
            object.cmdTyp = options.enums === String ? $root.ActivityCmdType[message.cmdTyp] : message.cmdTyp;
        return object;
    };

    /**
     * Converts this C2S_Activity to JSON.
     * @function toJSON
     * @memberof C2S_Activity
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Activity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Activity;
})();

$root.S2C_Activity = (function() {

    /**
     * Properties of a S2C_Activity.
     * @exports IS2C_Activity
     * @interface IS2C_Activity
     * @property {ActivityCmdType} cmdTyp S2C_Activity cmdTyp
     * @property {Array.<IActivityInfoPB>|null} [activityConfig] S2C_Activity activityConfig
     */

    /**
     * Constructs a new S2C_Activity.
     * @exports S2C_Activity
     * @classdesc Represents a S2C_Activity.
     * @implements IS2C_Activity
     * @constructor
     * @param {IS2C_Activity=} [properties] Properties to set
     */
    function S2C_Activity(properties) {
        this.activityConfig = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Activity cmdTyp.
     * @member {ActivityCmdType} cmdTyp
     * @memberof S2C_Activity
     * @instance
     */
    S2C_Activity.prototype.cmdTyp = 1;

    /**
     * S2C_Activity activityConfig.
     * @member {Array.<IActivityInfoPB>} activityConfig
     * @memberof S2C_Activity
     * @instance
     */
    S2C_Activity.prototype.activityConfig = $util.emptyArray;

    /**
     * Creates a new S2C_Activity instance using the specified properties.
     * @function create
     * @memberof S2C_Activity
     * @static
     * @param {IS2C_Activity=} [properties] Properties to set
     * @returns {S2C_Activity} S2C_Activity instance
     */
    S2C_Activity.create = function create(properties) {
        return new S2C_Activity(properties);
    };

    /**
     * Encodes the specified S2C_Activity message. Does not implicitly {@link S2C_Activity.verify|verify} messages.
     * @function encode
     * @memberof S2C_Activity
     * @static
     * @param {IS2C_Activity} message S2C_Activity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Activity.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdTyp);
        if (message.activityConfig != null && message.activityConfig.length)
            for (var i = 0; i < message.activityConfig.length; ++i)
                $root.ActivityInfoPB.encode(message.activityConfig[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_Activity message, length delimited. Does not implicitly {@link S2C_Activity.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Activity
     * @static
     * @param {IS2C_Activity} message S2C_Activity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Activity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Activity message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Activity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Activity} S2C_Activity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Activity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Activity();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdTyp = reader.int32();
                break;
            case 2:
                if (!(message.activityConfig && message.activityConfig.length))
                    message.activityConfig = [];
                message.activityConfig.push($root.ActivityInfoPB.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdTyp"))
            throw $util.ProtocolError("missing required 'cmdTyp'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_Activity message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Activity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Activity} S2C_Activity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Activity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Activity message.
     * @function verify
     * @memberof S2C_Activity
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Activity.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdTyp) {
        default:
            return "cmdTyp: enum value expected";
        case 1:
        case 2:
            break;
        }
        if (message.activityConfig != null && message.hasOwnProperty("activityConfig")) {
            if (!Array.isArray(message.activityConfig))
                return "activityConfig: array expected";
            for (var i = 0; i < message.activityConfig.length; ++i) {
                var error = $root.ActivityInfoPB.verify(message.activityConfig[i]);
                if (error)
                    return "activityConfig." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_Activity message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Activity
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Activity} S2C_Activity
     */
    S2C_Activity.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Activity)
            return object;
        var message = new $root.S2C_Activity();
        switch (object.cmdTyp) {
        case "GetActivityConfig_Cmd":
        case 1:
            message.cmdTyp = 1;
            break;
        case "UpdateActivityConfig_Cmd":
        case 2:
            message.cmdTyp = 2;
            break;
        }
        if (object.activityConfig) {
            if (!Array.isArray(object.activityConfig))
                throw TypeError(".S2C_Activity.activityConfig: array expected");
            message.activityConfig = [];
            for (var i = 0; i < object.activityConfig.length; ++i) {
                if (typeof object.activityConfig[i] !== "object")
                    throw TypeError(".S2C_Activity.activityConfig: object expected");
                message.activityConfig[i] = $root.ActivityInfoPB.fromObject(object.activityConfig[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_Activity message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Activity
     * @static
     * @param {S2C_Activity} message S2C_Activity
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Activity.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.activityConfig = [];
        if (options.defaults)
            object.cmdTyp = options.enums === String ? "GetActivityConfig_Cmd" : 1;
        if (message.cmdTyp != null && message.hasOwnProperty("cmdTyp"))
            object.cmdTyp = options.enums === String ? $root.ActivityCmdType[message.cmdTyp] : message.cmdTyp;
        if (message.activityConfig && message.activityConfig.length) {
            object.activityConfig = [];
            for (var j = 0; j < message.activityConfig.length; ++j)
                object.activityConfig[j] = $root.ActivityInfoPB.toObject(message.activityConfig[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_Activity to JSON.
     * @function toJSON
     * @memberof S2C_Activity
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Activity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Activity;
})();

$root.C2S_PlayerTask = (function() {

    /**
     * Properties of a C2S_PlayerTask.
     * @exports IC2S_PlayerTask
     * @interface IC2S_PlayerTask
     * @property {PlayerTaskCmdType} cmdTyp C2S_PlayerTask cmdTyp
     * @property {number|null} [id] C2S_PlayerTask id
     * @property {number|null} [index] C2S_PlayerTask index
     */

    /**
     * Constructs a new C2S_PlayerTask.
     * @exports C2S_PlayerTask
     * @classdesc Represents a C2S_PlayerTask.
     * @implements IC2S_PlayerTask
     * @constructor
     * @param {IC2S_PlayerTask=} [properties] Properties to set
     */
    function C2S_PlayerTask(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_PlayerTask cmdTyp.
     * @member {PlayerTaskCmdType} cmdTyp
     * @memberof C2S_PlayerTask
     * @instance
     */
    C2S_PlayerTask.prototype.cmdTyp = 1;

    /**
     * C2S_PlayerTask id.
     * @member {number} id
     * @memberof C2S_PlayerTask
     * @instance
     */
    C2S_PlayerTask.prototype.id = 0;

    /**
     * C2S_PlayerTask index.
     * @member {number} index
     * @memberof C2S_PlayerTask
     * @instance
     */
    C2S_PlayerTask.prototype.index = 0;

    /**
     * Creates a new C2S_PlayerTask instance using the specified properties.
     * @function create
     * @memberof C2S_PlayerTask
     * @static
     * @param {IC2S_PlayerTask=} [properties] Properties to set
     * @returns {C2S_PlayerTask} C2S_PlayerTask instance
     */
    C2S_PlayerTask.create = function create(properties) {
        return new C2S_PlayerTask(properties);
    };

    /**
     * Encodes the specified C2S_PlayerTask message. Does not implicitly {@link C2S_PlayerTask.verify|verify} messages.
     * @function encode
     * @memberof C2S_PlayerTask
     * @static
     * @param {IC2S_PlayerTask} message C2S_PlayerTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_PlayerTask.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdTyp);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
        if (message.index != null && message.hasOwnProperty("index"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.index);
        return writer;
    };

    /**
     * Encodes the specified C2S_PlayerTask message, length delimited. Does not implicitly {@link C2S_PlayerTask.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_PlayerTask
     * @static
     * @param {IC2S_PlayerTask} message C2S_PlayerTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_PlayerTask.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_PlayerTask message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_PlayerTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_PlayerTask} C2S_PlayerTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_PlayerTask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_PlayerTask();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdTyp = reader.int32();
                break;
            case 2:
                message.id = reader.int32();
                break;
            case 3:
                message.index = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdTyp"))
            throw $util.ProtocolError("missing required 'cmdTyp'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_PlayerTask message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_PlayerTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_PlayerTask} C2S_PlayerTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_PlayerTask.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_PlayerTask message.
     * @function verify
     * @memberof C2S_PlayerTask
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_PlayerTask.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdTyp) {
        default:
            return "cmdTyp: enum value expected";
        case 1:
        case 2:
        case 3:
            break;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index))
                return "index: integer expected";
        return null;
    };

    /**
     * Creates a C2S_PlayerTask message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_PlayerTask
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_PlayerTask} C2S_PlayerTask
     */
    C2S_PlayerTask.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_PlayerTask)
            return object;
        var message = new $root.C2S_PlayerTask();
        switch (object.cmdTyp) {
        case "GetPlayerTask_Cmd":
        case 1:
            message.cmdTyp = 1;
            break;
        case "UpdatePlayerTask_Cmd":
        case 2:
            message.cmdTyp = 2;
            break;
        case "Received_Cmd":
        case 3:
            message.cmdTyp = 3;
            break;
        }
        if (object.id != null)
            message.id = object.id | 0;
        if (object.index != null)
            message.index = object.index | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_PlayerTask message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_PlayerTask
     * @static
     * @param {C2S_PlayerTask} message C2S_PlayerTask
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_PlayerTask.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmdTyp = options.enums === String ? "GetPlayerTask_Cmd" : 1;
            object.id = 0;
            object.index = 0;
        }
        if (message.cmdTyp != null && message.hasOwnProperty("cmdTyp"))
            object.cmdTyp = options.enums === String ? $root.PlayerTaskCmdType[message.cmdTyp] : message.cmdTyp;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        return object;
    };

    /**
     * Converts this C2S_PlayerTask to JSON.
     * @function toJSON
     * @memberof C2S_PlayerTask
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_PlayerTask.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_PlayerTask;
})();

$root.S2C_PlayerTask = (function() {

    /**
     * Properties of a S2C_PlayerTask.
     * @exports IS2C_PlayerTask
     * @interface IS2C_PlayerTask
     * @property {PlayerTaskCmdType} cmdTyp S2C_PlayerTask cmdTyp
     * @property {Array.<ITaskInfoPB>|null} [taskInfo] S2C_PlayerTask taskInfo
     */

    /**
     * Constructs a new S2C_PlayerTask.
     * @exports S2C_PlayerTask
     * @classdesc Represents a S2C_PlayerTask.
     * @implements IS2C_PlayerTask
     * @constructor
     * @param {IS2C_PlayerTask=} [properties] Properties to set
     */
    function S2C_PlayerTask(properties) {
        this.taskInfo = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_PlayerTask cmdTyp.
     * @member {PlayerTaskCmdType} cmdTyp
     * @memberof S2C_PlayerTask
     * @instance
     */
    S2C_PlayerTask.prototype.cmdTyp = 1;

    /**
     * S2C_PlayerTask taskInfo.
     * @member {Array.<ITaskInfoPB>} taskInfo
     * @memberof S2C_PlayerTask
     * @instance
     */
    S2C_PlayerTask.prototype.taskInfo = $util.emptyArray;

    /**
     * Creates a new S2C_PlayerTask instance using the specified properties.
     * @function create
     * @memberof S2C_PlayerTask
     * @static
     * @param {IS2C_PlayerTask=} [properties] Properties to set
     * @returns {S2C_PlayerTask} S2C_PlayerTask instance
     */
    S2C_PlayerTask.create = function create(properties) {
        return new S2C_PlayerTask(properties);
    };

    /**
     * Encodes the specified S2C_PlayerTask message. Does not implicitly {@link S2C_PlayerTask.verify|verify} messages.
     * @function encode
     * @memberof S2C_PlayerTask
     * @static
     * @param {IS2C_PlayerTask} message S2C_PlayerTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PlayerTask.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdTyp);
        if (message.taskInfo != null && message.taskInfo.length)
            for (var i = 0; i < message.taskInfo.length; ++i)
                $root.TaskInfoPB.encode(message.taskInfo[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_PlayerTask message, length delimited. Does not implicitly {@link S2C_PlayerTask.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_PlayerTask
     * @static
     * @param {IS2C_PlayerTask} message S2C_PlayerTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PlayerTask.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_PlayerTask message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_PlayerTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_PlayerTask} S2C_PlayerTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PlayerTask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_PlayerTask();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdTyp = reader.int32();
                break;
            case 2:
                if (!(message.taskInfo && message.taskInfo.length))
                    message.taskInfo = [];
                message.taskInfo.push($root.TaskInfoPB.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdTyp"))
            throw $util.ProtocolError("missing required 'cmdTyp'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_PlayerTask message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_PlayerTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_PlayerTask} S2C_PlayerTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PlayerTask.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_PlayerTask message.
     * @function verify
     * @memberof S2C_PlayerTask
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_PlayerTask.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdTyp) {
        default:
            return "cmdTyp: enum value expected";
        case 1:
        case 2:
        case 3:
            break;
        }
        if (message.taskInfo != null && message.hasOwnProperty("taskInfo")) {
            if (!Array.isArray(message.taskInfo))
                return "taskInfo: array expected";
            for (var i = 0; i < message.taskInfo.length; ++i) {
                var error = $root.TaskInfoPB.verify(message.taskInfo[i]);
                if (error)
                    return "taskInfo." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_PlayerTask message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_PlayerTask
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_PlayerTask} S2C_PlayerTask
     */
    S2C_PlayerTask.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_PlayerTask)
            return object;
        var message = new $root.S2C_PlayerTask();
        switch (object.cmdTyp) {
        case "GetPlayerTask_Cmd":
        case 1:
            message.cmdTyp = 1;
            break;
        case "UpdatePlayerTask_Cmd":
        case 2:
            message.cmdTyp = 2;
            break;
        case "Received_Cmd":
        case 3:
            message.cmdTyp = 3;
            break;
        }
        if (object.taskInfo) {
            if (!Array.isArray(object.taskInfo))
                throw TypeError(".S2C_PlayerTask.taskInfo: array expected");
            message.taskInfo = [];
            for (var i = 0; i < object.taskInfo.length; ++i) {
                if (typeof object.taskInfo[i] !== "object")
                    throw TypeError(".S2C_PlayerTask.taskInfo: object expected");
                message.taskInfo[i] = $root.TaskInfoPB.fromObject(object.taskInfo[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_PlayerTask message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_PlayerTask
     * @static
     * @param {S2C_PlayerTask} message S2C_PlayerTask
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_PlayerTask.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.taskInfo = [];
        if (options.defaults)
            object.cmdTyp = options.enums === String ? "GetPlayerTask_Cmd" : 1;
        if (message.cmdTyp != null && message.hasOwnProperty("cmdTyp"))
            object.cmdTyp = options.enums === String ? $root.PlayerTaskCmdType[message.cmdTyp] : message.cmdTyp;
        if (message.taskInfo && message.taskInfo.length) {
            object.taskInfo = [];
            for (var j = 0; j < message.taskInfo.length; ++j)
                object.taskInfo[j] = $root.TaskInfoPB.toObject(message.taskInfo[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_PlayerTask to JSON.
     * @function toJSON
     * @memberof S2C_PlayerTask
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_PlayerTask.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_PlayerTask;
})();

$root.ActivityInfoPB = (function() {

    /**
     * Properties of an ActivityInfoPB.
     * @exports IActivityInfoPB
     * @interface IActivityInfoPB
     * @property {number} id ActivityInfoPB id
     * @property {boolean|null} [avalid] ActivityInfoPB avalid
     */

    /**
     * Constructs a new ActivityInfoPB.
     * @exports ActivityInfoPB
     * @classdesc Represents an ActivityInfoPB.
     * @implements IActivityInfoPB
     * @constructor
     * @param {IActivityInfoPB=} [properties] Properties to set
     */
    function ActivityInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ActivityInfoPB id.
     * @member {number} id
     * @memberof ActivityInfoPB
     * @instance
     */
    ActivityInfoPB.prototype.id = 0;

    /**
     * ActivityInfoPB avalid.
     * @member {boolean} avalid
     * @memberof ActivityInfoPB
     * @instance
     */
    ActivityInfoPB.prototype.avalid = false;

    /**
     * Creates a new ActivityInfoPB instance using the specified properties.
     * @function create
     * @memberof ActivityInfoPB
     * @static
     * @param {IActivityInfoPB=} [properties] Properties to set
     * @returns {ActivityInfoPB} ActivityInfoPB instance
     */
    ActivityInfoPB.create = function create(properties) {
        return new ActivityInfoPB(properties);
    };

    /**
     * Encodes the specified ActivityInfoPB message. Does not implicitly {@link ActivityInfoPB.verify|verify} messages.
     * @function encode
     * @memberof ActivityInfoPB
     * @static
     * @param {IActivityInfoPB} message ActivityInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ActivityInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.avalid != null && message.hasOwnProperty("avalid"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.avalid);
        return writer;
    };

    /**
     * Encodes the specified ActivityInfoPB message, length delimited. Does not implicitly {@link ActivityInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ActivityInfoPB
     * @static
     * @param {IActivityInfoPB} message ActivityInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ActivityInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ActivityInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof ActivityInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ActivityInfoPB} ActivityInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ActivityInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ActivityInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.avalid = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes an ActivityInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ActivityInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ActivityInfoPB} ActivityInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ActivityInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ActivityInfoPB message.
     * @function verify
     * @memberof ActivityInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ActivityInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        if (message.avalid != null && message.hasOwnProperty("avalid"))
            if (typeof message.avalid !== "boolean")
                return "avalid: boolean expected";
        return null;
    };

    /**
     * Creates an ActivityInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ActivityInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ActivityInfoPB} ActivityInfoPB
     */
    ActivityInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.ActivityInfoPB)
            return object;
        var message = new $root.ActivityInfoPB();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.avalid != null)
            message.avalid = Boolean(object.avalid);
        return message;
    };

    /**
     * Creates a plain object from an ActivityInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ActivityInfoPB
     * @static
     * @param {ActivityInfoPB} message ActivityInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ActivityInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            object.avalid = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.avalid != null && message.hasOwnProperty("avalid"))
            object.avalid = message.avalid;
        return object;
    };

    /**
     * Converts this ActivityInfoPB to JSON.
     * @function toJSON
     * @memberof ActivityInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ActivityInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ActivityInfoPB;
})();

$root.TaskInfoPB = (function() {

    /**
     * Properties of a TaskInfoPB.
     * @exports ITaskInfoPB
     * @interface ITaskInfoPB
     * @property {number} id TaskInfoPB id
     * @property {number} index TaskInfoPB index
     * @property {number|null} [processing] TaskInfoPB processing
     * @property {number|null} [taskState] TaskInfoPB taskState
     */

    /**
     * Constructs a new TaskInfoPB.
     * @exports TaskInfoPB
     * @classdesc Represents a TaskInfoPB.
     * @implements ITaskInfoPB
     * @constructor
     * @param {ITaskInfoPB=} [properties] Properties to set
     */
    function TaskInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TaskInfoPB id.
     * @member {number} id
     * @memberof TaskInfoPB
     * @instance
     */
    TaskInfoPB.prototype.id = 0;

    /**
     * TaskInfoPB index.
     * @member {number} index
     * @memberof TaskInfoPB
     * @instance
     */
    TaskInfoPB.prototype.index = 0;

    /**
     * TaskInfoPB processing.
     * @member {number} processing
     * @memberof TaskInfoPB
     * @instance
     */
    TaskInfoPB.prototype.processing = 0;

    /**
     * TaskInfoPB taskState.
     * @member {number} taskState
     * @memberof TaskInfoPB
     * @instance
     */
    TaskInfoPB.prototype.taskState = 0;

    /**
     * Creates a new TaskInfoPB instance using the specified properties.
     * @function create
     * @memberof TaskInfoPB
     * @static
     * @param {ITaskInfoPB=} [properties] Properties to set
     * @returns {TaskInfoPB} TaskInfoPB instance
     */
    TaskInfoPB.create = function create(properties) {
        return new TaskInfoPB(properties);
    };

    /**
     * Encodes the specified TaskInfoPB message. Does not implicitly {@link TaskInfoPB.verify|verify} messages.
     * @function encode
     * @memberof TaskInfoPB
     * @static
     * @param {ITaskInfoPB} message TaskInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TaskInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
        if (message.processing != null && message.hasOwnProperty("processing"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.processing);
        if (message.taskState != null && message.hasOwnProperty("taskState"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.taskState);
        return writer;
    };

    /**
     * Encodes the specified TaskInfoPB message, length delimited. Does not implicitly {@link TaskInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TaskInfoPB
     * @static
     * @param {ITaskInfoPB} message TaskInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TaskInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TaskInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof TaskInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TaskInfoPB} TaskInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TaskInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TaskInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.index = reader.int32();
                break;
            case 3:
                message.processing = reader.int32();
                break;
            case 4:
                message.taskState = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        if (!message.hasOwnProperty("index"))
            throw $util.ProtocolError("missing required 'index'", { instance: message });
        return message;
    };

    /**
     * Decodes a TaskInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TaskInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TaskInfoPB} TaskInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TaskInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TaskInfoPB message.
     * @function verify
     * @memberof TaskInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TaskInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        if (!$util.isInteger(message.index))
            return "index: integer expected";
        if (message.processing != null && message.hasOwnProperty("processing"))
            if (!$util.isInteger(message.processing))
                return "processing: integer expected";
        if (message.taskState != null && message.hasOwnProperty("taskState"))
            if (!$util.isInteger(message.taskState))
                return "taskState: integer expected";
        return null;
    };

    /**
     * Creates a TaskInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TaskInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TaskInfoPB} TaskInfoPB
     */
    TaskInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.TaskInfoPB)
            return object;
        var message = new $root.TaskInfoPB();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.index != null)
            message.index = object.index | 0;
        if (object.processing != null)
            message.processing = object.processing | 0;
        if (object.taskState != null)
            message.taskState = object.taskState | 0;
        return message;
    };

    /**
     * Creates a plain object from a TaskInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TaskInfoPB
     * @static
     * @param {TaskInfoPB} message TaskInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TaskInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            object.index = 0;
            object.processing = 0;
            object.taskState = 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        if (message.processing != null && message.hasOwnProperty("processing"))
            object.processing = message.processing;
        if (message.taskState != null && message.hasOwnProperty("taskState"))
            object.taskState = message.taskState;
        return object;
    };

    /**
     * Converts this TaskInfoPB to JSON.
     * @function toJSON
     * @memberof TaskInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TaskInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TaskInfoPB;
})();

/**
 * CmdId enum.
 * @exports CmdId
 * @enum {string}
 * @property {number} LOGIN=1 LOGIN value
 * @property {number} REGISTER=2 REGISTER value
 * @property {number} GET_PLAYER_INFO=3 GET_PLAYER_INFO value
 * @property {number} RECONNECT=4 RECONNECT value
 * @property {number} ITEM_CHANGE=5 ITEM_CHANGE value
 * @property {number} ALL_ITEM=6 ALL_ITEM value
 * @property {number} USE_ITEM=7 USE_ITEM value
 * @property {number} EXCHANGE_ITEM=8 EXCHANGE_ITEM value
 * @property {number} SELL_ITEM=9 SELL_ITEM value
 * @property {number} CURRENCY_CHANGE=10 CURRENCY_CHANGE value
 * @property {number} LEVEL_UP=11 LEVEL_UP value
 * @property {number} XIU_LIAN=12 XIU_LIAN value
 * @property {number} SELL_MANY_EQUIP=13 SELL_MANY_EQUIP value
 * @property {number} UPGRADE_PKG=14 UPGRADE_PKG value
 * @property {number} ALL_PROPERTY=15 ALL_PROPERTY value
 * @property {number} EQUIPMENT_OPT=16 EQUIPMENT_OPT value
 * @property {number} LEVEL_UP_RATE=17 LEVEL_UP_RATE value
 * @property {number} ITEM_USE_INFO=18 ITEM_USE_INFO value
 * @property {number} ITEM_EXCHANGE_INFO=19 ITEM_EXCHANGE_INFO value
 * @property {number} PKG_LEVEL_CHANGE=20 PKG_LEVEL_CHANGE value
 * @property {number} WUDAO=101 WUDAO value
 * @property {number} UPGRADE_WUDAO=102 UPGRADE_WUDAO value
 * @property {number} UPGRADE_WUDAO_ATTR=103 UPGRADE_WUDAO_ATTR value
 * @property {number} MAIL_LIST=201 MAIL_LIST value
 * @property {number} MAIL_OPT=202 MAIL_OPT value
 * @property {number} MAIL_PUSH=203 MAIL_PUSH value
 * @property {number} DONGFU=301 DONGFU value
 * @property {number} UPGRADE_DONGFU=302 UPGRADE_DONGFU value
 * @property {number} CHANGE_WORKER=303 CHANGE_WORKER value
 * @property {number} ADD_WORKER=304 ADD_WORKER value
 * @property {number} XIULIAN_OPT=305 XIULIAN_OPT value
 * @property {number} BUY_WINE=306 BUY_WINE value
 * @property {number} MAKE_ROOM=307 MAKE_ROOM value
 * @property {number} MAKE_TREASURE=308 MAKE_TREASURE value
 * @property {number} TAKE_TREASURE=309 TAKE_TREASURE value
 * @property {number} READ_BOOK=310 READ_BOOK value
 * @property {number} READ_BOOK_LEVEL_UP=311 READ_BOOK_LEVEL_UP value
 * @property {number} DONGFU_BUILD=312 DONGFU_BUILD value
 * @property {number} DONGFU_SHUGE=313 DONGFU_SHUGE value
 * @property {number} STOP_MAKE=314 STOP_MAKE value
 * @property {number} ALL_BOOK=315 ALL_BOOK value
 * @property {number} BOOKING=316 BOOKING value
 * @property {number} GONG_FA=401 GONG_FA value
 * @property {number} ADD_MEN_PAI_SKILL_NUM=402 ADD_MEN_PAI_SKILL_NUM value
 * @property {number} GONG_FA_CHANGE=403 GONG_FA_CHANGE value
 * @property {number} JOIN_MENPAI=501 JOIN_MENPAI value
 * @property {number} QUIT_MENPAI=502 QUIT_MENPAI value
 * @property {number} MENPAI=503 MENPAI value
 * @property {number} MENPAI_START_TASK=504 MENPAI_START_TASK value
 * @property {number} MENPAI_PAY=505 MENPAI_PAY value
 * @property {number} LIANGONG=506 LIANGONG value
 * @property {number} MENPAI_GIFT=507 MENPAI_GIFT value
 * @property {number} MENPAI_CHALLENGE=508 MENPAI_CHALLENGE value
 * @property {number} MENPAI_PROMOTION=509 MENPAI_PROMOTION value
 * @property {number} MENPAI_SAYHI=510 MENPAI_SAYHI value
 * @property {number} MENPAI_STUDY_SKILL=511 MENPAI_STUDY_SKILL value
 * @property {number} MENPAI_STUDY=512 MENPAI_STUDY value
 * @property {number} FANG_SHI_LIST=601 FANG_SHI_LIST value
 * @property {number} PURCHASE_GOODS=602 PURCHASE_GOODS value
 * @property {number} HEI_SHI=603 HEI_SHI value
 * @property {number} GO_FISHING=701 GO_FISHING value
 * @property {number} ACTIVITY_CONFIG=801 ACTIVITY_CONFIG value
 * @property {number} PLAYER_TASK=802 PLAYER_TASK value
 * @property {number} LILIAN_MAP=901 LILIAN_MAP value
 * @property {number} ENTER_MAP=902 ENTER_MAP value
 * @property {number} STEP_IN_MAP=903 STEP_IN_MAP value
 * @property {number} FIGHT_MONSTER=904 FIGHT_MONSTER value
 * @property {number} BUY_SHENYOU_ITEM=905 BUY_SHENYOU_ITEM value
 * @property {number} SET_AUTO_SELL=906 SET_AUTO_SELL value
 * @property {number} SHENYOU=907 SHENYOU value
 * @property {number} STOP_SHENYOU=908 STOP_SHENYOU value
 * @property {number} SHENYOU_LOG=909 SHENYOU_LOG value
 * @property {number} SHENYOU_INFO=910 SHENYOU_INFO value
 * @property {number} XI_SUI=1001 XI_SUI value
 * @property {number} FENG_YIN_BOSS=1101 FENG_YIN_BOSS value
 * @property {number} DaoLv=1201 DaoLv value
 * @property {number} GET_JI_YUAN=1301 GET_JI_YUAN value
 * @property {number} JI_YUAN=1302 JI_YUAN value
 * @property {number} GET_QI_YUA=1303 GET_QI_YUA value
 * @property {number} BAN_PLAYER=2001 BAN_PLAYER value
 * @property {number} ANNOUNCE=2002 ANNOUNCE value
 * @property {number} REFRESH_TABLE=2003 REFRESH_TABLE value
 * @property {number} SEND_MAIL=2004 SEND_MAIL value
 * @property {number} UPDATE_PLAYER=2005 UPDATE_PLAYER value
 */
$root.CmdId = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "LOGIN"] = 1;
    values[valuesById[2] = "REGISTER"] = 2;
    values[valuesById[3] = "GET_PLAYER_INFO"] = 3;
    values[valuesById[4] = "RECONNECT"] = 4;
    values[valuesById[5] = "ITEM_CHANGE"] = 5;
    values[valuesById[6] = "ALL_ITEM"] = 6;
    values[valuesById[7] = "USE_ITEM"] = 7;
    values[valuesById[8] = "EXCHANGE_ITEM"] = 8;
    values[valuesById[9] = "SELL_ITEM"] = 9;
    values[valuesById[10] = "CURRENCY_CHANGE"] = 10;
    values[valuesById[11] = "LEVEL_UP"] = 11;
    values[valuesById[12] = "XIU_LIAN"] = 12;
    values[valuesById[13] = "SELL_MANY_EQUIP"] = 13;
    values[valuesById[14] = "UPGRADE_PKG"] = 14;
    values[valuesById[15] = "ALL_PROPERTY"] = 15;
    values[valuesById[16] = "EQUIPMENT_OPT"] = 16;
    values[valuesById[17] = "LEVEL_UP_RATE"] = 17;
    values[valuesById[18] = "ITEM_USE_INFO"] = 18;
    values[valuesById[19] = "ITEM_EXCHANGE_INFO"] = 19;
    values[valuesById[20] = "PKG_LEVEL_CHANGE"] = 20;
    values[valuesById[101] = "WUDAO"] = 101;
    values[valuesById[102] = "UPGRADE_WUDAO"] = 102;
    values[valuesById[103] = "UPGRADE_WUDAO_ATTR"] = 103;
    values[valuesById[201] = "MAIL_LIST"] = 201;
    values[valuesById[202] = "MAIL_OPT"] = 202;
    values[valuesById[203] = "MAIL_PUSH"] = 203;
    values[valuesById[301] = "DONGFU"] = 301;
    values[valuesById[302] = "UPGRADE_DONGFU"] = 302;
    values[valuesById[303] = "CHANGE_WORKER"] = 303;
    values[valuesById[304] = "ADD_WORKER"] = 304;
    values[valuesById[305] = "XIULIAN_OPT"] = 305;
    values[valuesById[306] = "BUY_WINE"] = 306;
    values[valuesById[307] = "MAKE_ROOM"] = 307;
    values[valuesById[308] = "MAKE_TREASURE"] = 308;
    values[valuesById[309] = "TAKE_TREASURE"] = 309;
    values[valuesById[310] = "READ_BOOK"] = 310;
    values[valuesById[311] = "READ_BOOK_LEVEL_UP"] = 311;
    values[valuesById[312] = "DONGFU_BUILD"] = 312;
    values[valuesById[313] = "DONGFU_SHUGE"] = 313;
    values[valuesById[314] = "STOP_MAKE"] = 314;
    values[valuesById[315] = "ALL_BOOK"] = 315;
    values[valuesById[316] = "BOOKING"] = 316;
    values[valuesById[401] = "GONG_FA"] = 401;
    values[valuesById[402] = "ADD_MEN_PAI_SKILL_NUM"] = 402;
    values[valuesById[403] = "GONG_FA_CHANGE"] = 403;
    values[valuesById[501] = "JOIN_MENPAI"] = 501;
    values[valuesById[502] = "QUIT_MENPAI"] = 502;
    values[valuesById[503] = "MENPAI"] = 503;
    values[valuesById[504] = "MENPAI_START_TASK"] = 504;
    values[valuesById[505] = "MENPAI_PAY"] = 505;
    values[valuesById[506] = "LIANGONG"] = 506;
    values[valuesById[507] = "MENPAI_GIFT"] = 507;
    values[valuesById[508] = "MENPAI_CHALLENGE"] = 508;
    values[valuesById[509] = "MENPAI_PROMOTION"] = 509;
    values[valuesById[510] = "MENPAI_SAYHI"] = 510;
    values[valuesById[511] = "MENPAI_STUDY_SKILL"] = 511;
    values[valuesById[512] = "MENPAI_STUDY"] = 512;
    values[valuesById[601] = "FANG_SHI_LIST"] = 601;
    values[valuesById[602] = "PURCHASE_GOODS"] = 602;
    values[valuesById[603] = "HEI_SHI"] = 603;
    values[valuesById[701] = "GO_FISHING"] = 701;
    values[valuesById[801] = "ACTIVITY_CONFIG"] = 801;
    values[valuesById[802] = "PLAYER_TASK"] = 802;
    values[valuesById[901] = "LILIAN_MAP"] = 901;
    values[valuesById[902] = "ENTER_MAP"] = 902;
    values[valuesById[903] = "STEP_IN_MAP"] = 903;
    values[valuesById[904] = "FIGHT_MONSTER"] = 904;
    values[valuesById[905] = "BUY_SHENYOU_ITEM"] = 905;
    values[valuesById[906] = "SET_AUTO_SELL"] = 906;
    values[valuesById[907] = "SHENYOU"] = 907;
    values[valuesById[908] = "STOP_SHENYOU"] = 908;
    values[valuesById[909] = "SHENYOU_LOG"] = 909;
    values[valuesById[910] = "SHENYOU_INFO"] = 910;
    values[valuesById[1001] = "XI_SUI"] = 1001;
    values[valuesById[1101] = "FENG_YIN_BOSS"] = 1101;
    values[valuesById[1201] = "DaoLv"] = 1201;
    values[valuesById[1301] = "GET_JI_YUAN"] = 1301;
    values[valuesById[1302] = "JI_YUAN"] = 1302;
    values[valuesById[1303] = "GET_QI_YUA"] = 1303;
    values[valuesById[2001] = "BAN_PLAYER"] = 2001;
    values[valuesById[2002] = "ANNOUNCE"] = 2002;
    values[valuesById[2003] = "REFRESH_TABLE"] = 2003;
    values[valuesById[2004] = "SEND_MAIL"] = 2004;
    values[valuesById[2005] = "UPDATE_PLAYER"] = 2005;
    return values;
})();

$root.C2S_MsgPack = (function() {

    /**
     * Properties of a C2S_MsgPack.
     * @exports IC2S_MsgPack
     * @interface IC2S_MsgPack
     * @property {number} cmd C2S_MsgPack cmd
     * @property {Uint8Array|null} [data] C2S_MsgPack data
     */

    /**
     * Constructs a new C2S_MsgPack.
     * @exports C2S_MsgPack
     * @classdesc Represents a C2S_MsgPack.
     * @implements IC2S_MsgPack
     * @constructor
     * @param {IC2S_MsgPack=} [properties] Properties to set
     */
    function C2S_MsgPack(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MsgPack cmd.
     * @member {number} cmd
     * @memberof C2S_MsgPack
     * @instance
     */
    C2S_MsgPack.prototype.cmd = 0;

    /**
     * C2S_MsgPack data.
     * @member {Uint8Array} data
     * @memberof C2S_MsgPack
     * @instance
     */
    C2S_MsgPack.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new C2S_MsgPack instance using the specified properties.
     * @function create
     * @memberof C2S_MsgPack
     * @static
     * @param {IC2S_MsgPack=} [properties] Properties to set
     * @returns {C2S_MsgPack} C2S_MsgPack instance
     */
    C2S_MsgPack.create = function create(properties) {
        return new C2S_MsgPack(properties);
    };

    /**
     * Encodes the specified C2S_MsgPack message. Does not implicitly {@link C2S_MsgPack.verify|verify} messages.
     * @function encode
     * @memberof C2S_MsgPack
     * @static
     * @param {IC2S_MsgPack} message C2S_MsgPack message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MsgPack.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmd);
        if (message.data != null && message.hasOwnProperty("data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified C2S_MsgPack message, length delimited. Does not implicitly {@link C2S_MsgPack.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MsgPack
     * @static
     * @param {IC2S_MsgPack} message C2S_MsgPack message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MsgPack.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MsgPack message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MsgPack
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MsgPack} C2S_MsgPack
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MsgPack.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MsgPack();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmd = reader.int32();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmd"))
            throw $util.ProtocolError("missing required 'cmd'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_MsgPack message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MsgPack
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MsgPack} C2S_MsgPack
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MsgPack.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MsgPack message.
     * @function verify
     * @memberof C2S_MsgPack
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MsgPack.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.cmd))
            return "cmd: integer expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a C2S_MsgPack message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MsgPack
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MsgPack} C2S_MsgPack
     */
    C2S_MsgPack.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MsgPack)
            return object;
        var message = new $root.C2S_MsgPack();
        if (object.cmd != null)
            message.cmd = object.cmd | 0;
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MsgPack message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MsgPack
     * @static
     * @param {C2S_MsgPack} message C2S_MsgPack
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MsgPack.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmd = 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.cmd != null && message.hasOwnProperty("cmd"))
            object.cmd = message.cmd;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this C2S_MsgPack to JSON.
     * @function toJSON
     * @memberof C2S_MsgPack
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MsgPack.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MsgPack;
})();

$root.S2C_MsgPack = (function() {

    /**
     * Properties of a S2C_MsgPack.
     * @exports IS2C_MsgPack
     * @interface IS2C_MsgPack
     * @property {number} cmd S2C_MsgPack cmd
     * @property {string|null} [errMsg] S2C_MsgPack errMsg
     * @property {Uint8Array|null} [data] S2C_MsgPack data
     */

    /**
     * Constructs a new S2C_MsgPack.
     * @exports S2C_MsgPack
     * @classdesc Represents a S2C_MsgPack.
     * @implements IS2C_MsgPack
     * @constructor
     * @param {IS2C_MsgPack=} [properties] Properties to set
     */
    function S2C_MsgPack(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MsgPack cmd.
     * @member {number} cmd
     * @memberof S2C_MsgPack
     * @instance
     */
    S2C_MsgPack.prototype.cmd = 0;

    /**
     * S2C_MsgPack errMsg.
     * @member {string} errMsg
     * @memberof S2C_MsgPack
     * @instance
     */
    S2C_MsgPack.prototype.errMsg = "";

    /**
     * S2C_MsgPack data.
     * @member {Uint8Array} data
     * @memberof S2C_MsgPack
     * @instance
     */
    S2C_MsgPack.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new S2C_MsgPack instance using the specified properties.
     * @function create
     * @memberof S2C_MsgPack
     * @static
     * @param {IS2C_MsgPack=} [properties] Properties to set
     * @returns {S2C_MsgPack} S2C_MsgPack instance
     */
    S2C_MsgPack.create = function create(properties) {
        return new S2C_MsgPack(properties);
    };

    /**
     * Encodes the specified S2C_MsgPack message. Does not implicitly {@link S2C_MsgPack.verify|verify} messages.
     * @function encode
     * @memberof S2C_MsgPack
     * @static
     * @param {IS2C_MsgPack} message S2C_MsgPack message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MsgPack.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmd);
        if (message.errMsg != null && message.hasOwnProperty("errMsg"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.errMsg);
        if (message.data != null && message.hasOwnProperty("data"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified S2C_MsgPack message, length delimited. Does not implicitly {@link S2C_MsgPack.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MsgPack
     * @static
     * @param {IS2C_MsgPack} message S2C_MsgPack message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MsgPack.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MsgPack message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MsgPack
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MsgPack} S2C_MsgPack
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MsgPack.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MsgPack();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmd = reader.int32();
                break;
            case 2:
                message.errMsg = reader.string();
                break;
            case 3:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmd"))
            throw $util.ProtocolError("missing required 'cmd'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_MsgPack message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MsgPack
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MsgPack} S2C_MsgPack
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MsgPack.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MsgPack message.
     * @function verify
     * @memberof S2C_MsgPack
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MsgPack.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.cmd))
            return "cmd: integer expected";
        if (message.errMsg != null && message.hasOwnProperty("errMsg"))
            if (!$util.isString(message.errMsg))
                return "errMsg: string expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a S2C_MsgPack message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MsgPack
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MsgPack} S2C_MsgPack
     */
    S2C_MsgPack.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MsgPack)
            return object;
        var message = new $root.S2C_MsgPack();
        if (object.cmd != null)
            message.cmd = object.cmd | 0;
        if (object.errMsg != null)
            message.errMsg = String(object.errMsg);
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a S2C_MsgPack message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MsgPack
     * @static
     * @param {S2C_MsgPack} message S2C_MsgPack
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MsgPack.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmd = 0;
            object.errMsg = "";
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.cmd != null && message.hasOwnProperty("cmd"))
            object.cmd = message.cmd;
        if (message.errMsg != null && message.hasOwnProperty("errMsg"))
            object.errMsg = message.errMsg;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this S2C_MsgPack to JSON.
     * @function toJSON
     * @memberof S2C_MsgPack
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MsgPack.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MsgPack;
})();

/**
 * PropertyType enum.
 * @exports PropertyType
 * @enum {string}
 * @property {number} TiPo=1 TiPo value
 * @property {number} ZhenQi=2 ZhenQi value
 * @property {number} GenGu=3 GenGu value
 * @property {number} ShenFa=4 ShenFa value
 * @property {number} LingLi=5 LingLi value
 * @property {number} WuXing=6 WuXing value
 * @property {number} JiYuan=7 JiYuan value
 * @property {number} JinXi=101 JinXi value
 * @property {number} MuXi=102 MuXi value
 * @property {number} ShuiXi=103 ShuiXi value
 * @property {number} HuoXi=104 HuoXi value
 * @property {number} TuXi=105 TuXi value
 * @property {number} RenZu=201 RenZu value
 * @property {number} YaoZu=202 YaoZu value
 * @property {number} MoZu=203 MoZu value
 * @property {number} ShouZu=204 ShouZu value
 * @property {number} LongZu=205 LongZu value
 * @property {number} XianRen=206 XianRen value
 * @property {number} ZhengQi=301 ZhengQi value
 * @property {number} XieQi=302 XieQi value
 * @property {number} ShengMing=1001 ShengMing value
 * @property {number} GongJi=1002 GongJi value
 * @property {number} FangYu=1003 FangYu value
 * @property {number} ShanBi=1004 ShanBi value
 * @property {number} BaoJi=1005 BaoJi value
 * @property {number} XiuLianSuDu=1006 XiuLianSuDu value
 * @property {number} LingLiHuoQu=1007 LingLiHuoQu value
 */
$root.PropertyType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "TiPo"] = 1;
    values[valuesById[2] = "ZhenQi"] = 2;
    values[valuesById[3] = "GenGu"] = 3;
    values[valuesById[4] = "ShenFa"] = 4;
    values[valuesById[5] = "LingLi"] = 5;
    values[valuesById[6] = "WuXing"] = 6;
    values[valuesById[7] = "JiYuan"] = 7;
    values[valuesById[101] = "JinXi"] = 101;
    values[valuesById[102] = "MuXi"] = 102;
    values[valuesById[103] = "ShuiXi"] = 103;
    values[valuesById[104] = "HuoXi"] = 104;
    values[valuesById[105] = "TuXi"] = 105;
    values[valuesById[201] = "RenZu"] = 201;
    values[valuesById[202] = "YaoZu"] = 202;
    values[valuesById[203] = "MoZu"] = 203;
    values[valuesById[204] = "ShouZu"] = 204;
    values[valuesById[205] = "LongZu"] = 205;
    values[valuesById[206] = "XianRen"] = 206;
    values[valuesById[301] = "ZhengQi"] = 301;
    values[valuesById[302] = "XieQi"] = 302;
    values[valuesById[1001] = "ShengMing"] = 1001;
    values[valuesById[1002] = "GongJi"] = 1002;
    values[valuesById[1003] = "FangYu"] = 1003;
    values[valuesById[1004] = "ShanBi"] = 1004;
    values[valuesById[1005] = "BaoJi"] = 1005;
    values[valuesById[1006] = "XiuLianSuDu"] = 1006;
    values[valuesById[1007] = "LingLiHuoQu"] = 1007;
    return values;
})();

/**
 * ItemType enum.
 * @exports ItemType
 * @enum {string}
 * @property {number} CURRENCY=0 CURRENCY value
 * @property {number} ITEM=1 ITEM value
 * @property {number} EQUIPMENT=2 EQUIPMENT value
 * @property {number} MEDICINE=3 MEDICINE value
 * @property {number} WINE=4 WINE value
 * @property {number} FISH=5 FISH value
 */
$root.ItemType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CURRENCY"] = 0;
    values[valuesById[1] = "ITEM"] = 1;
    values[valuesById[2] = "EQUIPMENT"] = 2;
    values[valuesById[3] = "MEDICINE"] = 3;
    values[valuesById[4] = "WINE"] = 4;
    values[valuesById[5] = "FISH"] = 5;
    return values;
})();

/**
 * ZhongZuType enum.
 * @exports ZhongZuType
 * @enum {string}
 * @property {number} REN=1 REN value
 * @property {number} YAO=2 YAO value
 * @property {number} MO=3 MO value
 * @property {number} XIAN=4 XIAN value
 * @property {number} LONG=5 LONG value
 * @property {number} SHOU=6 SHOU value
 */
$root.ZhongZuType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "REN"] = 1;
    values[valuesById[2] = "YAO"] = 2;
    values[valuesById[3] = "MO"] = 3;
    values[valuesById[4] = "XIAN"] = 4;
    values[valuesById[5] = "LONG"] = 5;
    values[valuesById[6] = "SHOU"] = 6;
    return values;
})();

$root.C2S_DaoLv = (function() {

    /**
     * Properties of a C2S_DaoLv.
     * @exports IC2S_DaoLv
     * @interface IC2S_DaoLv
     * @property {DaoLvCmdType} cmdType C2S_DaoLv cmdType
     * @property {number|null} [id] C2S_DaoLv id
     */

    /**
     * Constructs a new C2S_DaoLv.
     * @exports C2S_DaoLv
     * @classdesc Represents a C2S_DaoLv.
     * @implements IC2S_DaoLv
     * @constructor
     * @param {IC2S_DaoLv=} [properties] Properties to set
     */
    function C2S_DaoLv(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_DaoLv cmdType.
     * @member {DaoLvCmdType} cmdType
     * @memberof C2S_DaoLv
     * @instance
     */
    C2S_DaoLv.prototype.cmdType = 1;

    /**
     * C2S_DaoLv id.
     * @member {number} id
     * @memberof C2S_DaoLv
     * @instance
     */
    C2S_DaoLv.prototype.id = 0;

    /**
     * Creates a new C2S_DaoLv instance using the specified properties.
     * @function create
     * @memberof C2S_DaoLv
     * @static
     * @param {IC2S_DaoLv=} [properties] Properties to set
     * @returns {C2S_DaoLv} C2S_DaoLv instance
     */
    C2S_DaoLv.create = function create(properties) {
        return new C2S_DaoLv(properties);
    };

    /**
     * Encodes the specified C2S_DaoLv message. Does not implicitly {@link C2S_DaoLv.verify|verify} messages.
     * @function encode
     * @memberof C2S_DaoLv
     * @static
     * @param {IC2S_DaoLv} message C2S_DaoLv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_DaoLv.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_DaoLv message, length delimited. Does not implicitly {@link C2S_DaoLv.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_DaoLv
     * @static
     * @param {IC2S_DaoLv} message C2S_DaoLv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_DaoLv.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_DaoLv message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_DaoLv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_DaoLv} C2S_DaoLv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_DaoLv.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_DaoLv();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_DaoLv message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_DaoLv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_DaoLv} C2S_DaoLv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_DaoLv.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_DaoLv message.
     * @function verify
     * @memberof C2S_DaoLv
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_DaoLv.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            break;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_DaoLv message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_DaoLv
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_DaoLv} C2S_DaoLv
     */
    C2S_DaoLv.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_DaoLv)
            return object;
        var message = new $root.C2S_DaoLv();
        switch (object.cmdType) {
        case "GetDaoLv_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "GifgGiving_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        case "TakeHome_Cmd":
        case 3:
            message.cmdType = 3;
            break;
        case "YuanJin_Cmd":
        case 4:
            message.cmdType = 4;
            break;
        case "TakeRoom_Cmd":
        case 5:
            message.cmdType = 5;
            break;
        case "ShuangXiu_Cmd":
        case 6:
            message.cmdType = 6;
            break;
        case "ShuangXiuLog_Cmd":
        case 7:
            message.cmdType = 7;
            break;
        }
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_DaoLv message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_DaoLv
     * @static
     * @param {C2S_DaoLv} message C2S_DaoLv
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_DaoLv.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmdType = options.enums === String ? "GetDaoLv_Cmd" : 1;
            object.id = 0;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.DaoLvCmdType[message.cmdType] : message.cmdType;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_DaoLv to JSON.
     * @function toJSON
     * @memberof C2S_DaoLv
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_DaoLv.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_DaoLv;
})();

$root.S2C_DaoLv = (function() {

    /**
     * Properties of a S2C_DaoLv.
     * @exports IS2C_DaoLv
     * @interface IS2C_DaoLv
     * @property {DaoLvCmdType} cmdType S2C_DaoLv cmdType
     * @property {Array.<IDaoLvInfoPB>|null} [daoLvInfo] S2C_DaoLv daoLvInfo
     * @property {number|null} [curShungXiuCount] S2C_DaoLv curShungXiuCount
     * @property {Array.<IResourceMsg>|null} [natureOtherValue] S2C_DaoLv natureOtherValue
     * @property {number|null} [natureEffect] S2C_DaoLv natureEffect
     * @property {number|null} [physiqueReduceEffect] S2C_DaoLv physiqueReduceEffect
     * @property {Array.<IShuangXiuLogInfoPB>|null} [xiuLianLog] S2C_DaoLv xiuLianLog
     * @property {boolean|null} [natureRefuseShuangXiu] S2C_DaoLv natureRefuseShuangXiu
     * @property {IResultInfoPB|null} [result] S2C_DaoLv result
     */

    /**
     * Constructs a new S2C_DaoLv.
     * @exports S2C_DaoLv
     * @classdesc Represents a S2C_DaoLv.
     * @implements IS2C_DaoLv
     * @constructor
     * @param {IS2C_DaoLv=} [properties] Properties to set
     */
    function S2C_DaoLv(properties) {
        this.daoLvInfo = [];
        this.natureOtherValue = [];
        this.xiuLianLog = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_DaoLv cmdType.
     * @member {DaoLvCmdType} cmdType
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.cmdType = 1;

    /**
     * S2C_DaoLv daoLvInfo.
     * @member {Array.<IDaoLvInfoPB>} daoLvInfo
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.daoLvInfo = $util.emptyArray;

    /**
     * S2C_DaoLv curShungXiuCount.
     * @member {number} curShungXiuCount
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.curShungXiuCount = 0;

    /**
     * S2C_DaoLv natureOtherValue.
     * @member {Array.<IResourceMsg>} natureOtherValue
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.natureOtherValue = $util.emptyArray;

    /**
     * S2C_DaoLv natureEffect.
     * @member {number} natureEffect
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.natureEffect = 0;

    /**
     * S2C_DaoLv physiqueReduceEffect.
     * @member {number} physiqueReduceEffect
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.physiqueReduceEffect = 0;

    /**
     * S2C_DaoLv xiuLianLog.
     * @member {Array.<IShuangXiuLogInfoPB>} xiuLianLog
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.xiuLianLog = $util.emptyArray;

    /**
     * S2C_DaoLv natureRefuseShuangXiu.
     * @member {boolean} natureRefuseShuangXiu
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.natureRefuseShuangXiu = false;

    /**
     * S2C_DaoLv result.
     * @member {IResultInfoPB|null|undefined} result
     * @memberof S2C_DaoLv
     * @instance
     */
    S2C_DaoLv.prototype.result = null;

    /**
     * Creates a new S2C_DaoLv instance using the specified properties.
     * @function create
     * @memberof S2C_DaoLv
     * @static
     * @param {IS2C_DaoLv=} [properties] Properties to set
     * @returns {S2C_DaoLv} S2C_DaoLv instance
     */
    S2C_DaoLv.create = function create(properties) {
        return new S2C_DaoLv(properties);
    };

    /**
     * Encodes the specified S2C_DaoLv message. Does not implicitly {@link S2C_DaoLv.verify|verify} messages.
     * @function encode
     * @memberof S2C_DaoLv
     * @static
     * @param {IS2C_DaoLv} message S2C_DaoLv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_DaoLv.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.daoLvInfo != null && message.daoLvInfo.length)
            for (var i = 0; i < message.daoLvInfo.length; ++i)
                $root.DaoLvInfoPB.encode(message.daoLvInfo[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.curShungXiuCount != null && message.hasOwnProperty("curShungXiuCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.curShungXiuCount);
        if (message.natureOtherValue != null && message.natureOtherValue.length)
            for (var i = 0; i < message.natureOtherValue.length; ++i)
                $root.ResourceMsg.encode(message.natureOtherValue[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.natureEffect != null && message.hasOwnProperty("natureEffect"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.natureEffect);
        if (message.physiqueReduceEffect != null && message.hasOwnProperty("physiqueReduceEffect"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.physiqueReduceEffect);
        if (message.xiuLianLog != null && message.xiuLianLog.length)
            for (var i = 0; i < message.xiuLianLog.length; ++i)
                $root.ShuangXiuLogInfoPB.encode(message.xiuLianLog[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.natureRefuseShuangXiu != null && message.hasOwnProperty("natureRefuseShuangXiu"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.natureRefuseShuangXiu);
        if (message.result != null && message.hasOwnProperty("result"))
            $root.ResultInfoPB.encode(message.result, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_DaoLv message, length delimited. Does not implicitly {@link S2C_DaoLv.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_DaoLv
     * @static
     * @param {IS2C_DaoLv} message S2C_DaoLv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_DaoLv.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_DaoLv message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_DaoLv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_DaoLv} S2C_DaoLv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_DaoLv.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_DaoLv();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                if (!(message.daoLvInfo && message.daoLvInfo.length))
                    message.daoLvInfo = [];
                message.daoLvInfo.push($root.DaoLvInfoPB.decode(reader, reader.uint32()));
                break;
            case 3:
                message.curShungXiuCount = reader.int32();
                break;
            case 4:
                if (!(message.natureOtherValue && message.natureOtherValue.length))
                    message.natureOtherValue = [];
                message.natureOtherValue.push($root.ResourceMsg.decode(reader, reader.uint32()));
                break;
            case 5:
                message.natureEffect = reader.int32();
                break;
            case 6:
                message.physiqueReduceEffect = reader.int32();
                break;
            case 7:
                if (!(message.xiuLianLog && message.xiuLianLog.length))
                    message.xiuLianLog = [];
                message.xiuLianLog.push($root.ShuangXiuLogInfoPB.decode(reader, reader.uint32()));
                break;
            case 8:
                message.natureRefuseShuangXiu = reader.bool();
                break;
            case 9:
                message.result = $root.ResultInfoPB.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_DaoLv message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_DaoLv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_DaoLv} S2C_DaoLv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_DaoLv.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_DaoLv message.
     * @function verify
     * @memberof S2C_DaoLv
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_DaoLv.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            break;
        }
        if (message.daoLvInfo != null && message.hasOwnProperty("daoLvInfo")) {
            if (!Array.isArray(message.daoLvInfo))
                return "daoLvInfo: array expected";
            for (var i = 0; i < message.daoLvInfo.length; ++i) {
                var error = $root.DaoLvInfoPB.verify(message.daoLvInfo[i]);
                if (error)
                    return "daoLvInfo." + error;
            }
        }
        if (message.curShungXiuCount != null && message.hasOwnProperty("curShungXiuCount"))
            if (!$util.isInteger(message.curShungXiuCount))
                return "curShungXiuCount: integer expected";
        if (message.natureOtherValue != null && message.hasOwnProperty("natureOtherValue")) {
            if (!Array.isArray(message.natureOtherValue))
                return "natureOtherValue: array expected";
            for (var i = 0; i < message.natureOtherValue.length; ++i) {
                var error = $root.ResourceMsg.verify(message.natureOtherValue[i]);
                if (error)
                    return "natureOtherValue." + error;
            }
        }
        if (message.natureEffect != null && message.hasOwnProperty("natureEffect"))
            if (!$util.isInteger(message.natureEffect))
                return "natureEffect: integer expected";
        if (message.physiqueReduceEffect != null && message.hasOwnProperty("physiqueReduceEffect"))
            if (!$util.isInteger(message.physiqueReduceEffect))
                return "physiqueReduceEffect: integer expected";
        if (message.xiuLianLog != null && message.hasOwnProperty("xiuLianLog")) {
            if (!Array.isArray(message.xiuLianLog))
                return "xiuLianLog: array expected";
            for (var i = 0; i < message.xiuLianLog.length; ++i) {
                var error = $root.ShuangXiuLogInfoPB.verify(message.xiuLianLog[i]);
                if (error)
                    return "xiuLianLog." + error;
            }
        }
        if (message.natureRefuseShuangXiu != null && message.hasOwnProperty("natureRefuseShuangXiu"))
            if (typeof message.natureRefuseShuangXiu !== "boolean")
                return "natureRefuseShuangXiu: boolean expected";
        if (message.result != null && message.hasOwnProperty("result")) {
            var error = $root.ResultInfoPB.verify(message.result);
            if (error)
                return "result." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_DaoLv message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_DaoLv
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_DaoLv} S2C_DaoLv
     */
    S2C_DaoLv.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_DaoLv)
            return object;
        var message = new $root.S2C_DaoLv();
        switch (object.cmdType) {
        case "GetDaoLv_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "GifgGiving_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        case "TakeHome_Cmd":
        case 3:
            message.cmdType = 3;
            break;
        case "YuanJin_Cmd":
        case 4:
            message.cmdType = 4;
            break;
        case "TakeRoom_Cmd":
        case 5:
            message.cmdType = 5;
            break;
        case "ShuangXiu_Cmd":
        case 6:
            message.cmdType = 6;
            break;
        case "ShuangXiuLog_Cmd":
        case 7:
            message.cmdType = 7;
            break;
        }
        if (object.daoLvInfo) {
            if (!Array.isArray(object.daoLvInfo))
                throw TypeError(".S2C_DaoLv.daoLvInfo: array expected");
            message.daoLvInfo = [];
            for (var i = 0; i < object.daoLvInfo.length; ++i) {
                if (typeof object.daoLvInfo[i] !== "object")
                    throw TypeError(".S2C_DaoLv.daoLvInfo: object expected");
                message.daoLvInfo[i] = $root.DaoLvInfoPB.fromObject(object.daoLvInfo[i]);
            }
        }
        if (object.curShungXiuCount != null)
            message.curShungXiuCount = object.curShungXiuCount | 0;
        if (object.natureOtherValue) {
            if (!Array.isArray(object.natureOtherValue))
                throw TypeError(".S2C_DaoLv.natureOtherValue: array expected");
            message.natureOtherValue = [];
            for (var i = 0; i < object.natureOtherValue.length; ++i) {
                if (typeof object.natureOtherValue[i] !== "object")
                    throw TypeError(".S2C_DaoLv.natureOtherValue: object expected");
                message.natureOtherValue[i] = $root.ResourceMsg.fromObject(object.natureOtherValue[i]);
            }
        }
        if (object.natureEffect != null)
            message.natureEffect = object.natureEffect | 0;
        if (object.physiqueReduceEffect != null)
            message.physiqueReduceEffect = object.physiqueReduceEffect | 0;
        if (object.xiuLianLog) {
            if (!Array.isArray(object.xiuLianLog))
                throw TypeError(".S2C_DaoLv.xiuLianLog: array expected");
            message.xiuLianLog = [];
            for (var i = 0; i < object.xiuLianLog.length; ++i) {
                if (typeof object.xiuLianLog[i] !== "object")
                    throw TypeError(".S2C_DaoLv.xiuLianLog: object expected");
                message.xiuLianLog[i] = $root.ShuangXiuLogInfoPB.fromObject(object.xiuLianLog[i]);
            }
        }
        if (object.natureRefuseShuangXiu != null)
            message.natureRefuseShuangXiu = Boolean(object.natureRefuseShuangXiu);
        if (object.result != null) {
            if (typeof object.result !== "object")
                throw TypeError(".S2C_DaoLv.result: object expected");
            message.result = $root.ResultInfoPB.fromObject(object.result);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_DaoLv message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_DaoLv
     * @static
     * @param {S2C_DaoLv} message S2C_DaoLv
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_DaoLv.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.daoLvInfo = [];
            object.natureOtherValue = [];
            object.xiuLianLog = [];
        }
        if (options.defaults) {
            object.cmdType = options.enums === String ? "GetDaoLv_Cmd" : 1;
            object.curShungXiuCount = 0;
            object.natureEffect = 0;
            object.physiqueReduceEffect = 0;
            object.natureRefuseShuangXiu = false;
            object.result = null;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.DaoLvCmdType[message.cmdType] : message.cmdType;
        if (message.daoLvInfo && message.daoLvInfo.length) {
            object.daoLvInfo = [];
            for (var j = 0; j < message.daoLvInfo.length; ++j)
                object.daoLvInfo[j] = $root.DaoLvInfoPB.toObject(message.daoLvInfo[j], options);
        }
        if (message.curShungXiuCount != null && message.hasOwnProperty("curShungXiuCount"))
            object.curShungXiuCount = message.curShungXiuCount;
        if (message.natureOtherValue && message.natureOtherValue.length) {
            object.natureOtherValue = [];
            for (var j = 0; j < message.natureOtherValue.length; ++j)
                object.natureOtherValue[j] = $root.ResourceMsg.toObject(message.natureOtherValue[j], options);
        }
        if (message.natureEffect != null && message.hasOwnProperty("natureEffect"))
            object.natureEffect = message.natureEffect;
        if (message.physiqueReduceEffect != null && message.hasOwnProperty("physiqueReduceEffect"))
            object.physiqueReduceEffect = message.physiqueReduceEffect;
        if (message.xiuLianLog && message.xiuLianLog.length) {
            object.xiuLianLog = [];
            for (var j = 0; j < message.xiuLianLog.length; ++j)
                object.xiuLianLog[j] = $root.ShuangXiuLogInfoPB.toObject(message.xiuLianLog[j], options);
        }
        if (message.natureRefuseShuangXiu != null && message.hasOwnProperty("natureRefuseShuangXiu"))
            object.natureRefuseShuangXiu = message.natureRefuseShuangXiu;
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = $root.ResultInfoPB.toObject(message.result, options);
        return object;
    };

    /**
     * Converts this S2C_DaoLv to JSON.
     * @function toJSON
     * @memberof S2C_DaoLv
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_DaoLv.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_DaoLv;
})();

/**
 * RelationshipType enum.
 * @exports RelationshipType
 * @enum {string}
 * @property {number} Stranger=1 Stranger value
 * @property {number} SoulMate=2 SoulMate value
 * @property {number} HappyCouple=3 HappyCouple value
 * @property {number} ShuangXiu=4 ShuangXiu value
 */
$root.RelationshipType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "Stranger"] = 1;
    values[valuesById[2] = "SoulMate"] = 2;
    values[valuesById[3] = "HappyCouple"] = 3;
    values[valuesById[4] = "ShuangXiu"] = 4;
    return values;
})();

/**
 * DaoLvCmdType enum.
 * @exports DaoLvCmdType
 * @enum {string}
 * @property {number} GetDaoLv_Cmd=1 GetDaoLv_Cmd value
 * @property {number} GifgGiving_Cmd=2 GifgGiving_Cmd value
 * @property {number} TakeHome_Cmd=3 TakeHome_Cmd value
 * @property {number} YuanJin_Cmd=4 YuanJin_Cmd value
 * @property {number} TakeRoom_Cmd=5 TakeRoom_Cmd value
 * @property {number} ShuangXiu_Cmd=6 ShuangXiu_Cmd value
 * @property {number} ShuangXiuLog_Cmd=7 ShuangXiuLog_Cmd value
 */
$root.DaoLvCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "GetDaoLv_Cmd"] = 1;
    values[valuesById[2] = "GifgGiving_Cmd"] = 2;
    values[valuesById[3] = "TakeHome_Cmd"] = 3;
    values[valuesById[4] = "YuanJin_Cmd"] = 4;
    values[valuesById[5] = "TakeRoom_Cmd"] = 5;
    values[valuesById[6] = "ShuangXiu_Cmd"] = 6;
    values[valuesById[7] = "ShuangXiuLog_Cmd"] = 7;
    return values;
})();

/**
 * PhysiqueType1 enum.
 * @exports PhysiqueType1
 * @enum {string}
 * @property {number} ShuGe=0 ShuGe value
 * @property {number} Currency=1 Currency value
 * @property {number} XiuWeiPerent=2 XiuWeiPerent value
 * @property {number} DuJiePercent=3 DuJiePercent value
 */
$root.PhysiqueType1 = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "ShuGe"] = 0;
    values[valuesById[1] = "Currency"] = 1;
    values[valuesById[2] = "XiuWeiPerent"] = 2;
    values[valuesById[3] = "DuJiePercent"] = 3;
    return values;
})();

/**
 * PhysiqueType2 enum.
 * @exports PhysiqueType2
 * @enum {string}
 * @property {number} WeiWang=1 WeiWang value
 * @property {number} ReduceXiuWeiPerent=2 ReduceXiuWeiPerent value
 */
$root.PhysiqueType2 = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "WeiWang"] = 1;
    values[valuesById[2] = "ReduceXiuWeiPerent"] = 2;
    return values;
})();

/**
 * NatureOtherType enum.
 * @exports NatureOtherType
 * @enum {string}
 * @property {number} ChillDown=1 ChillDown value
 * @property {number} UnwillingShuangXiu=2 UnwillingShuangXiu value
 * @property {number} NotConsumeShuangXiuTime=3 NotConsumeShuangXiuTime value
 * @property {number} DanYaoGiving=4 DanYaoGiving value
 */
$root.NatureOtherType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "ChillDown"] = 1;
    values[valuesById[2] = "UnwillingShuangXiu"] = 2;
    values[valuesById[3] = "NotConsumeShuangXiuTime"] = 3;
    values[valuesById[4] = "DanYaoGiving"] = 4;
    return values;
})();

/**
 * NatureEffectType enum.
 * @exports NatureEffectType
 * @enum {string}
 * @property {number} DoubleEffect=1 DoubleEffect value
 * @property {number} MultiplePower=2 MultiplePower value
 * @property {number} AllPower=3 AllPower value
 */
$root.NatureEffectType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "DoubleEffect"] = 1;
    values[valuesById[2] = "MultiplePower"] = 2;
    values[valuesById[3] = "AllPower"] = 3;
    return values;
})();

$root.DaoLvInfoPB = (function() {

    /**
     * Properties of a DaoLvInfoPB.
     * @exports IDaoLvInfoPB
     * @interface IDaoLvInfoPB
     * @property {number} id DaoLvInfoPB id
     * @property {number|null} [relationship] DaoLvInfoPB relationship
     * @property {number|null} [intimacy] DaoLvInfoPB intimacy
     */

    /**
     * Constructs a new DaoLvInfoPB.
     * @exports DaoLvInfoPB
     * @classdesc Represents a DaoLvInfoPB.
     * @implements IDaoLvInfoPB
     * @constructor
     * @param {IDaoLvInfoPB=} [properties] Properties to set
     */
    function DaoLvInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DaoLvInfoPB id.
     * @member {number} id
     * @memberof DaoLvInfoPB
     * @instance
     */
    DaoLvInfoPB.prototype.id = 0;

    /**
     * DaoLvInfoPB relationship.
     * @member {number} relationship
     * @memberof DaoLvInfoPB
     * @instance
     */
    DaoLvInfoPB.prototype.relationship = 0;

    /**
     * DaoLvInfoPB intimacy.
     * @member {number} intimacy
     * @memberof DaoLvInfoPB
     * @instance
     */
    DaoLvInfoPB.prototype.intimacy = 0;

    /**
     * Creates a new DaoLvInfoPB instance using the specified properties.
     * @function create
     * @memberof DaoLvInfoPB
     * @static
     * @param {IDaoLvInfoPB=} [properties] Properties to set
     * @returns {DaoLvInfoPB} DaoLvInfoPB instance
     */
    DaoLvInfoPB.create = function create(properties) {
        return new DaoLvInfoPB(properties);
    };

    /**
     * Encodes the specified DaoLvInfoPB message. Does not implicitly {@link DaoLvInfoPB.verify|verify} messages.
     * @function encode
     * @memberof DaoLvInfoPB
     * @static
     * @param {IDaoLvInfoPB} message DaoLvInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DaoLvInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.relationship != null && message.hasOwnProperty("relationship"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.relationship);
        if (message.intimacy != null && message.hasOwnProperty("intimacy"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.intimacy);
        return writer;
    };

    /**
     * Encodes the specified DaoLvInfoPB message, length delimited. Does not implicitly {@link DaoLvInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DaoLvInfoPB
     * @static
     * @param {IDaoLvInfoPB} message DaoLvInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DaoLvInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DaoLvInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof DaoLvInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DaoLvInfoPB} DaoLvInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DaoLvInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DaoLvInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.relationship = reader.int32();
                break;
            case 3:
                message.intimacy = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a DaoLvInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DaoLvInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DaoLvInfoPB} DaoLvInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DaoLvInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DaoLvInfoPB message.
     * @function verify
     * @memberof DaoLvInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DaoLvInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        if (message.relationship != null && message.hasOwnProperty("relationship"))
            if (!$util.isInteger(message.relationship))
                return "relationship: integer expected";
        if (message.intimacy != null && message.hasOwnProperty("intimacy"))
            if (!$util.isInteger(message.intimacy))
                return "intimacy: integer expected";
        return null;
    };

    /**
     * Creates a DaoLvInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DaoLvInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DaoLvInfoPB} DaoLvInfoPB
     */
    DaoLvInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.DaoLvInfoPB)
            return object;
        var message = new $root.DaoLvInfoPB();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.relationship != null)
            message.relationship = object.relationship | 0;
        if (object.intimacy != null)
            message.intimacy = object.intimacy | 0;
        return message;
    };

    /**
     * Creates a plain object from a DaoLvInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DaoLvInfoPB
     * @static
     * @param {DaoLvInfoPB} message DaoLvInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DaoLvInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            object.relationship = 0;
            object.intimacy = 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.relationship != null && message.hasOwnProperty("relationship"))
            object.relationship = message.relationship;
        if (message.intimacy != null && message.hasOwnProperty("intimacy"))
            object.intimacy = message.intimacy;
        return object;
    };

    /**
     * Converts this DaoLvInfoPB to JSON.
     * @function toJSON
     * @memberof DaoLvInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DaoLvInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DaoLvInfoPB;
})();

$root.ShuangXiuLogInfoPB = (function() {

    /**
     * Properties of a ShuangXiuLogInfoPB.
     * @exports IShuangXiuLogInfoPB
     * @interface IShuangXiuLogInfoPB
     * @property {number|Long|null} [shuangXiuTime] ShuangXiuLogInfoPB shuangXiuTime
     * @property {IS2C_DaoLv|null} [xiuLianInfo] ShuangXiuLogInfoPB xiuLianInfo
     */

    /**
     * Constructs a new ShuangXiuLogInfoPB.
     * @exports ShuangXiuLogInfoPB
     * @classdesc Represents a ShuangXiuLogInfoPB.
     * @implements IShuangXiuLogInfoPB
     * @constructor
     * @param {IShuangXiuLogInfoPB=} [properties] Properties to set
     */
    function ShuangXiuLogInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ShuangXiuLogInfoPB shuangXiuTime.
     * @member {number|Long} shuangXiuTime
     * @memberof ShuangXiuLogInfoPB
     * @instance
     */
    ShuangXiuLogInfoPB.prototype.shuangXiuTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ShuangXiuLogInfoPB xiuLianInfo.
     * @member {IS2C_DaoLv|null|undefined} xiuLianInfo
     * @memberof ShuangXiuLogInfoPB
     * @instance
     */
    ShuangXiuLogInfoPB.prototype.xiuLianInfo = null;

    /**
     * Creates a new ShuangXiuLogInfoPB instance using the specified properties.
     * @function create
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {IShuangXiuLogInfoPB=} [properties] Properties to set
     * @returns {ShuangXiuLogInfoPB} ShuangXiuLogInfoPB instance
     */
    ShuangXiuLogInfoPB.create = function create(properties) {
        return new ShuangXiuLogInfoPB(properties);
    };

    /**
     * Encodes the specified ShuangXiuLogInfoPB message. Does not implicitly {@link ShuangXiuLogInfoPB.verify|verify} messages.
     * @function encode
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {IShuangXiuLogInfoPB} message ShuangXiuLogInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShuangXiuLogInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.shuangXiuTime != null && message.hasOwnProperty("shuangXiuTime"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shuangXiuTime);
        if (message.xiuLianInfo != null && message.hasOwnProperty("xiuLianInfo"))
            $root.S2C_DaoLv.encode(message.xiuLianInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ShuangXiuLogInfoPB message, length delimited. Does not implicitly {@link ShuangXiuLogInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {IShuangXiuLogInfoPB} message ShuangXiuLogInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShuangXiuLogInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ShuangXiuLogInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ShuangXiuLogInfoPB} ShuangXiuLogInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShuangXiuLogInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ShuangXiuLogInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.shuangXiuTime = reader.int64();
                break;
            case 2:
                message.xiuLianInfo = $root.S2C_DaoLv.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ShuangXiuLogInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ShuangXiuLogInfoPB} ShuangXiuLogInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShuangXiuLogInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ShuangXiuLogInfoPB message.
     * @function verify
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ShuangXiuLogInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.shuangXiuTime != null && message.hasOwnProperty("shuangXiuTime"))
            if (!$util.isInteger(message.shuangXiuTime) && !(message.shuangXiuTime && $util.isInteger(message.shuangXiuTime.low) && $util.isInteger(message.shuangXiuTime.high)))
                return "shuangXiuTime: integer|Long expected";
        if (message.xiuLianInfo != null && message.hasOwnProperty("xiuLianInfo")) {
            var error = $root.S2C_DaoLv.verify(message.xiuLianInfo);
            if (error)
                return "xiuLianInfo." + error;
        }
        return null;
    };

    /**
     * Creates a ShuangXiuLogInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ShuangXiuLogInfoPB} ShuangXiuLogInfoPB
     */
    ShuangXiuLogInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.ShuangXiuLogInfoPB)
            return object;
        var message = new $root.ShuangXiuLogInfoPB();
        if (object.shuangXiuTime != null)
            if ($util.Long)
                (message.shuangXiuTime = $util.Long.fromValue(object.shuangXiuTime)).unsigned = false;
            else if (typeof object.shuangXiuTime === "string")
                message.shuangXiuTime = parseInt(object.shuangXiuTime, 10);
            else if (typeof object.shuangXiuTime === "number")
                message.shuangXiuTime = object.shuangXiuTime;
            else if (typeof object.shuangXiuTime === "object")
                message.shuangXiuTime = new $util.LongBits(object.shuangXiuTime.low >>> 0, object.shuangXiuTime.high >>> 0).toNumber();
        if (object.xiuLianInfo != null) {
            if (typeof object.xiuLianInfo !== "object")
                throw TypeError(".ShuangXiuLogInfoPB.xiuLianInfo: object expected");
            message.xiuLianInfo = $root.S2C_DaoLv.fromObject(object.xiuLianInfo);
        }
        return message;
    };

    /**
     * Creates a plain object from a ShuangXiuLogInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ShuangXiuLogInfoPB
     * @static
     * @param {ShuangXiuLogInfoPB} message ShuangXiuLogInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ShuangXiuLogInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.shuangXiuTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.shuangXiuTime = options.longs === String ? "0" : 0;
            object.xiuLianInfo = null;
        }
        if (message.shuangXiuTime != null && message.hasOwnProperty("shuangXiuTime"))
            if (typeof message.shuangXiuTime === "number")
                object.shuangXiuTime = options.longs === String ? String(message.shuangXiuTime) : message.shuangXiuTime;
            else
                object.shuangXiuTime = options.longs === String ? $util.Long.prototype.toString.call(message.shuangXiuTime) : options.longs === Number ? new $util.LongBits(message.shuangXiuTime.low >>> 0, message.shuangXiuTime.high >>> 0).toNumber() : message.shuangXiuTime;
        if (message.xiuLianInfo != null && message.hasOwnProperty("xiuLianInfo"))
            object.xiuLianInfo = $root.S2C_DaoLv.toObject(message.xiuLianInfo, options);
        return object;
    };

    /**
     * Converts this ShuangXiuLogInfoPB to JSON.
     * @function toJSON
     * @memberof ShuangXiuLogInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ShuangXiuLogInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ShuangXiuLogInfoPB;
})();

$root.ResultInfoPB = (function() {

    /**
     * Properties of a ResultInfoPB.
     * @exports IResultInfoPB
     * @interface IResultInfoPB
     * @property {boolean|null} [result] ResultInfoPB result
     * @property {number|null} [errorCode] ResultInfoPB errorCode
     * @property {number|null} [type] ResultInfoPB type
     */

    /**
     * Constructs a new ResultInfoPB.
     * @exports ResultInfoPB
     * @classdesc Represents a ResultInfoPB.
     * @implements IResultInfoPB
     * @constructor
     * @param {IResultInfoPB=} [properties] Properties to set
     */
    function ResultInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ResultInfoPB result.
     * @member {boolean} result
     * @memberof ResultInfoPB
     * @instance
     */
    ResultInfoPB.prototype.result = false;

    /**
     * ResultInfoPB errorCode.
     * @member {number} errorCode
     * @memberof ResultInfoPB
     * @instance
     */
    ResultInfoPB.prototype.errorCode = 0;

    /**
     * ResultInfoPB type.
     * @member {number} type
     * @memberof ResultInfoPB
     * @instance
     */
    ResultInfoPB.prototype.type = 0;

    /**
     * Creates a new ResultInfoPB instance using the specified properties.
     * @function create
     * @memberof ResultInfoPB
     * @static
     * @param {IResultInfoPB=} [properties] Properties to set
     * @returns {ResultInfoPB} ResultInfoPB instance
     */
    ResultInfoPB.create = function create(properties) {
        return new ResultInfoPB(properties);
    };

    /**
     * Encodes the specified ResultInfoPB message. Does not implicitly {@link ResultInfoPB.verify|verify} messages.
     * @function encode
     * @memberof ResultInfoPB
     * @static
     * @param {IResultInfoPB} message ResultInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResultInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && message.hasOwnProperty("result"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.result);
        if (message.errorCode != null && message.hasOwnProperty("errorCode"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.errorCode);
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified ResultInfoPB message, length delimited. Does not implicitly {@link ResultInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ResultInfoPB
     * @static
     * @param {IResultInfoPB} message ResultInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResultInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ResultInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof ResultInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ResultInfoPB} ResultInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResultInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResultInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = reader.bool();
                break;
            case 2:
                message.errorCode = reader.int32();
                break;
            case 3:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ResultInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ResultInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ResultInfoPB} ResultInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResultInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ResultInfoPB message.
     * @function verify
     * @memberof ResultInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ResultInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result"))
            if (typeof message.result !== "boolean")
                return "result: boolean expected";
        if (message.errorCode != null && message.hasOwnProperty("errorCode"))
            if (!$util.isInteger(message.errorCode))
                return "errorCode: integer expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        return null;
    };

    /**
     * Creates a ResultInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ResultInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ResultInfoPB} ResultInfoPB
     */
    ResultInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.ResultInfoPB)
            return object;
        var message = new $root.ResultInfoPB();
        if (object.result != null)
            message.result = Boolean(object.result);
        if (object.errorCode != null)
            message.errorCode = object.errorCode | 0;
        if (object.type != null)
            message.type = object.type | 0;
        return message;
    };

    /**
     * Creates a plain object from a ResultInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ResultInfoPB
     * @static
     * @param {ResultInfoPB} message ResultInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ResultInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.result = false;
            object.errorCode = 0;
            object.type = 0;
        }
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = message.result;
        if (message.errorCode != null && message.hasOwnProperty("errorCode"))
            object.errorCode = message.errorCode;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        return object;
    };

    /**
     * Converts this ResultInfoPB to JSON.
     * @function toJSON
     * @memberof ResultInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ResultInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ResultInfoPB;
})();

/**
 * ErrorTipsType enum.
 * @exports ErrorTipsType
 * @enum {string}
 * @property {number} Tips=1 Tips value
 * @property {number} Console=2 Console value
 */
$root.ErrorTipsType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "Tips"] = 1;
    values[valuesById[2] = "Console"] = 2;
    return values;
})();

/**
 * ErrorCodeType enum.
 * @exports ErrorCodeType
 * @enum {string}
 * @property {number} DAO_LV_INTIMACY_MAX=1 DAO_LV_INTIMACY_MAX value
 * @property {number} DAO_LV_ALREADY_IN_HOME=2 DAO_LV_ALREADY_IN_HOME value
 * @property {number} DAO_LV_INTIMACY_LOWER=3 DAO_LV_INTIMACY_LOWER value
 * @property {number} DAO_LV_ALREADY_NOT_IN_HOME=4 DAO_LV_ALREADY_NOT_IN_HOME value
 * @property {number} DAO_LV_SHUANG_XIU_MAX=5 DAO_LV_SHUANG_XIU_MAX value
 * @property {number} DAO_LV_SHUANG_XIU_CHILL_DOWN=6 DAO_LV_SHUANG_XIU_CHILL_DOWN value
 * @property {number} DAO_LV_ALREADY_SHUANG_XIU=7 DAO_LV_ALREADY_SHUANG_XIU value
 * @property {number} DAO_LV_SHUANG_XIU_COUNT_MAX=8 DAO_LV_SHUANG_XIU_COUNT_MAX value
 * @property {number} DAO_LV_REFUSE_SHUANG_XIU=9 DAO_LV_REFUSE_SHUANG_XIU value
 * @property {number} DAO_LV_CAN_NOT_GIFT_GIVING=10 DAO_LV_CAN_NOT_GIFT_GIVING value
 * @property {number} NO_AVALIABLE_GIFT=11 NO_AVALIABLE_GIFT value
 * @property {number} DAO_LV_STRAGE=12 DAO_LV_STRAGE value
 */
$root.ErrorCodeType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "DAO_LV_INTIMACY_MAX"] = 1;
    values[valuesById[2] = "DAO_LV_ALREADY_IN_HOME"] = 2;
    values[valuesById[3] = "DAO_LV_INTIMACY_LOWER"] = 3;
    values[valuesById[4] = "DAO_LV_ALREADY_NOT_IN_HOME"] = 4;
    values[valuesById[5] = "DAO_LV_SHUANG_XIU_MAX"] = 5;
    values[valuesById[6] = "DAO_LV_SHUANG_XIU_CHILL_DOWN"] = 6;
    values[valuesById[7] = "DAO_LV_ALREADY_SHUANG_XIU"] = 7;
    values[valuesById[8] = "DAO_LV_SHUANG_XIU_COUNT_MAX"] = 8;
    values[valuesById[9] = "DAO_LV_REFUSE_SHUANG_XIU"] = 9;
    values[valuesById[10] = "DAO_LV_CAN_NOT_GIFT_GIVING"] = 10;
    values[valuesById[11] = "NO_AVALIABLE_GIFT"] = 11;
    values[valuesById[12] = "DAO_LV_STRAGE"] = 12;
    return values;
})();

$root.ResourceMsg = (function() {

    /**
     * Properties of a ResourceMsg.
     * @exports IResourceMsg
     * @interface IResourceMsg
     * @property {number|null} [id] ResourceMsg id
     * @property {number|Long|null} [count] ResourceMsg count
     * @property {number|null} [type] ResourceMsg type
     */

    /**
     * Constructs a new ResourceMsg.
     * @exports ResourceMsg
     * @classdesc Represents a ResourceMsg.
     * @implements IResourceMsg
     * @constructor
     * @param {IResourceMsg=} [properties] Properties to set
     */
    function ResourceMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ResourceMsg id.
     * @member {number} id
     * @memberof ResourceMsg
     * @instance
     */
    ResourceMsg.prototype.id = 0;

    /**
     * ResourceMsg count.
     * @member {number|Long} count
     * @memberof ResourceMsg
     * @instance
     */
    ResourceMsg.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ResourceMsg type.
     * @member {number} type
     * @memberof ResourceMsg
     * @instance
     */
    ResourceMsg.prototype.type = 0;

    /**
     * Creates a new ResourceMsg instance using the specified properties.
     * @function create
     * @memberof ResourceMsg
     * @static
     * @param {IResourceMsg=} [properties] Properties to set
     * @returns {ResourceMsg} ResourceMsg instance
     */
    ResourceMsg.create = function create(properties) {
        return new ResourceMsg(properties);
    };

    /**
     * Encodes the specified ResourceMsg message. Does not implicitly {@link ResourceMsg.verify|verify} messages.
     * @function encode
     * @memberof ResourceMsg
     * @static
     * @param {IResourceMsg} message ResourceMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResourceMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.count);
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified ResourceMsg message, length delimited. Does not implicitly {@link ResourceMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ResourceMsg
     * @static
     * @param {IResourceMsg} message ResourceMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResourceMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ResourceMsg message from the specified reader or buffer.
     * @function decode
     * @memberof ResourceMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ResourceMsg} ResourceMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResourceMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResourceMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.count = reader.int64();
                break;
            case 3:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ResourceMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ResourceMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ResourceMsg} ResourceMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResourceMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ResourceMsg message.
     * @function verify
     * @memberof ResourceMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ResourceMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                return "count: integer|Long expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        return null;
    };

    /**
     * Creates a ResourceMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ResourceMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ResourceMsg} ResourceMsg
     */
    ResourceMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.ResourceMsg)
            return object;
        var message = new $root.ResourceMsg();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.count != null)
            if ($util.Long)
                (message.count = $util.Long.fromValue(object.count)).unsigned = false;
            else if (typeof object.count === "string")
                message.count = parseInt(object.count, 10);
            else if (typeof object.count === "number")
                message.count = object.count;
            else if (typeof object.count === "object")
                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
        if (object.type != null)
            message.type = object.type | 0;
        return message;
    };

    /**
     * Creates a plain object from a ResourceMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ResourceMsg
     * @static
     * @param {ResourceMsg} message ResourceMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ResourceMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.count = options.longs === String ? "0" : 0;
            object.type = 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.count != null && message.hasOwnProperty("count"))
            if (typeof message.count === "number")
                object.count = options.longs === String ? String(message.count) : message.count;
            else
                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        return object;
    };

    /**
     * Converts this ResourceMsg to JSON.
     * @function toJSON
     * @memberof ResourceMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ResourceMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ResourceMsg;
})();

$root.ItemMsg = (function() {

    /**
     * Properties of an ItemMsg.
     * @exports IItemMsg
     * @interface IItemMsg
     * @property {number|Long|null} [id] ItemMsg id
     * @property {number|null} [itemId] ItemMsg itemId
     * @property {number|Long|null} [amount] ItemMsg amount
     * @property {Array.<IEquipAttrMsg>|null} [attr] ItemMsg attr
     * @property {boolean|null} [wear] ItemMsg wear
     */

    /**
     * Constructs a new ItemMsg.
     * @exports ItemMsg
     * @classdesc Represents an ItemMsg.
     * @implements IItemMsg
     * @constructor
     * @param {IItemMsg=} [properties] Properties to set
     */
    function ItemMsg(properties) {
        this.attr = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ItemMsg id.
     * @member {number|Long} id
     * @memberof ItemMsg
     * @instance
     */
    ItemMsg.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ItemMsg itemId.
     * @member {number} itemId
     * @memberof ItemMsg
     * @instance
     */
    ItemMsg.prototype.itemId = 0;

    /**
     * ItemMsg amount.
     * @member {number|Long} amount
     * @memberof ItemMsg
     * @instance
     */
    ItemMsg.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ItemMsg attr.
     * @member {Array.<IEquipAttrMsg>} attr
     * @memberof ItemMsg
     * @instance
     */
    ItemMsg.prototype.attr = $util.emptyArray;

    /**
     * ItemMsg wear.
     * @member {boolean} wear
     * @memberof ItemMsg
     * @instance
     */
    ItemMsg.prototype.wear = false;

    /**
     * Creates a new ItemMsg instance using the specified properties.
     * @function create
     * @memberof ItemMsg
     * @static
     * @param {IItemMsg=} [properties] Properties to set
     * @returns {ItemMsg} ItemMsg instance
     */
    ItemMsg.create = function create(properties) {
        return new ItemMsg(properties);
    };

    /**
     * Encodes the specified ItemMsg message. Does not implicitly {@link ItemMsg.verify|verify} messages.
     * @function encode
     * @memberof ItemMsg
     * @static
     * @param {IItemMsg} message ItemMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ItemMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemId);
        if (message.amount != null && message.hasOwnProperty("amount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
        if (message.attr != null && message.attr.length)
            for (var i = 0; i < message.attr.length; ++i)
                $root.EquipAttrMsg.encode(message.attr[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.wear != null && message.hasOwnProperty("wear"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.wear);
        return writer;
    };

    /**
     * Encodes the specified ItemMsg message, length delimited. Does not implicitly {@link ItemMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ItemMsg
     * @static
     * @param {IItemMsg} message ItemMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ItemMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ItemMsg message from the specified reader or buffer.
     * @function decode
     * @memberof ItemMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ItemMsg} ItemMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ItemMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int64();
                break;
            case 2:
                message.itemId = reader.int32();
                break;
            case 3:
                message.amount = reader.int64();
                break;
            case 4:
                if (!(message.attr && message.attr.length))
                    message.attr = [];
                message.attr.push($root.EquipAttrMsg.decode(reader, reader.uint32()));
                break;
            case 5:
                message.wear = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ItemMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ItemMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ItemMsg} ItemMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ItemMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ItemMsg message.
     * @function verify
     * @memberof ItemMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ItemMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            if (!$util.isInteger(message.itemId))
                return "itemId: integer expected";
        if (message.amount != null && message.hasOwnProperty("amount"))
            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                return "amount: integer|Long expected";
        if (message.attr != null && message.hasOwnProperty("attr")) {
            if (!Array.isArray(message.attr))
                return "attr: array expected";
            for (var i = 0; i < message.attr.length; ++i) {
                var error = $root.EquipAttrMsg.verify(message.attr[i]);
                if (error)
                    return "attr." + error;
            }
        }
        if (message.wear != null && message.hasOwnProperty("wear"))
            if (typeof message.wear !== "boolean")
                return "wear: boolean expected";
        return null;
    };

    /**
     * Creates an ItemMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ItemMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ItemMsg} ItemMsg
     */
    ItemMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.ItemMsg)
            return object;
        var message = new $root.ItemMsg();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.itemId != null)
            message.itemId = object.itemId | 0;
        if (object.amount != null)
            if ($util.Long)
                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
            else if (typeof object.amount === "string")
                message.amount = parseInt(object.amount, 10);
            else if (typeof object.amount === "number")
                message.amount = object.amount;
            else if (typeof object.amount === "object")
                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
        if (object.attr) {
            if (!Array.isArray(object.attr))
                throw TypeError(".ItemMsg.attr: array expected");
            message.attr = [];
            for (var i = 0; i < object.attr.length; ++i) {
                if (typeof object.attr[i] !== "object")
                    throw TypeError(".ItemMsg.attr: object expected");
                message.attr[i] = $root.EquipAttrMsg.fromObject(object.attr[i]);
            }
        }
        if (object.wear != null)
            message.wear = Boolean(object.wear);
        return message;
    };

    /**
     * Creates a plain object from an ItemMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ItemMsg
     * @static
     * @param {ItemMsg} message ItemMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ItemMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.attr = [];
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.itemId = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.amount = options.longs === String ? "0" : 0;
            object.wear = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            object.itemId = message.itemId;
        if (message.amount != null && message.hasOwnProperty("amount"))
            if (typeof message.amount === "number")
                object.amount = options.longs === String ? String(message.amount) : message.amount;
            else
                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
        if (message.attr && message.attr.length) {
            object.attr = [];
            for (var j = 0; j < message.attr.length; ++j)
                object.attr[j] = $root.EquipAttrMsg.toObject(message.attr[j], options);
        }
        if (message.wear != null && message.hasOwnProperty("wear"))
            object.wear = message.wear;
        return object;
    };

    /**
     * Converts this ItemMsg to JSON.
     * @function toJSON
     * @memberof ItemMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ItemMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ItemMsg;
})();

$root.ExchangeMsg = (function() {

    /**
     * Properties of an ExchangeMsg.
     * @exports IExchangeMsg
     * @interface IExchangeMsg
     * @property {number|null} [id] ExchangeMsg id
     * @property {number|null} [amount] ExchangeMsg amount
     */

    /**
     * Constructs a new ExchangeMsg.
     * @exports ExchangeMsg
     * @classdesc Represents an ExchangeMsg.
     * @implements IExchangeMsg
     * @constructor
     * @param {IExchangeMsg=} [properties] Properties to set
     */
    function ExchangeMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ExchangeMsg id.
     * @member {number} id
     * @memberof ExchangeMsg
     * @instance
     */
    ExchangeMsg.prototype.id = 0;

    /**
     * ExchangeMsg amount.
     * @member {number} amount
     * @memberof ExchangeMsg
     * @instance
     */
    ExchangeMsg.prototype.amount = 0;

    /**
     * Creates a new ExchangeMsg instance using the specified properties.
     * @function create
     * @memberof ExchangeMsg
     * @static
     * @param {IExchangeMsg=} [properties] Properties to set
     * @returns {ExchangeMsg} ExchangeMsg instance
     */
    ExchangeMsg.create = function create(properties) {
        return new ExchangeMsg(properties);
    };

    /**
     * Encodes the specified ExchangeMsg message. Does not implicitly {@link ExchangeMsg.verify|verify} messages.
     * @function encode
     * @memberof ExchangeMsg
     * @static
     * @param {IExchangeMsg} message ExchangeMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExchangeMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.amount != null && message.hasOwnProperty("amount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.amount);
        return writer;
    };

    /**
     * Encodes the specified ExchangeMsg message, length delimited. Does not implicitly {@link ExchangeMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ExchangeMsg
     * @static
     * @param {IExchangeMsg} message ExchangeMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExchangeMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ExchangeMsg message from the specified reader or buffer.
     * @function decode
     * @memberof ExchangeMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ExchangeMsg} ExchangeMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExchangeMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExchangeMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.amount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ExchangeMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ExchangeMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ExchangeMsg} ExchangeMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExchangeMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ExchangeMsg message.
     * @function verify
     * @memberof ExchangeMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ExchangeMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.amount != null && message.hasOwnProperty("amount"))
            if (!$util.isInteger(message.amount))
                return "amount: integer expected";
        return null;
    };

    /**
     * Creates an ExchangeMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ExchangeMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ExchangeMsg} ExchangeMsg
     */
    ExchangeMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.ExchangeMsg)
            return object;
        var message = new $root.ExchangeMsg();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.amount != null)
            message.amount = object.amount | 0;
        return message;
    };

    /**
     * Creates a plain object from an ExchangeMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ExchangeMsg
     * @static
     * @param {ExchangeMsg} message ExchangeMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ExchangeMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            object.amount = 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.amount != null && message.hasOwnProperty("amount"))
            object.amount = message.amount;
        return object;
    };

    /**
     * Converts this ExchangeMsg to JSON.
     * @function toJSON
     * @memberof ExchangeMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ExchangeMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ExchangeMsg;
})();

$root.ItemUseMsg = (function() {

    /**
     * Properties of an ItemUseMsg.
     * @exports IItemUseMsg
     * @interface IItemUseMsg
     * @property {number|null} [id] ItemUseMsg id
     * @property {number|null} [amount] ItemUseMsg amount
     */

    /**
     * Constructs a new ItemUseMsg.
     * @exports ItemUseMsg
     * @classdesc Represents an ItemUseMsg.
     * @implements IItemUseMsg
     * @constructor
     * @param {IItemUseMsg=} [properties] Properties to set
     */
    function ItemUseMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ItemUseMsg id.
     * @member {number} id
     * @memberof ItemUseMsg
     * @instance
     */
    ItemUseMsg.prototype.id = 0;

    /**
     * ItemUseMsg amount.
     * @member {number} amount
     * @memberof ItemUseMsg
     * @instance
     */
    ItemUseMsg.prototype.amount = 0;

    /**
     * Creates a new ItemUseMsg instance using the specified properties.
     * @function create
     * @memberof ItemUseMsg
     * @static
     * @param {IItemUseMsg=} [properties] Properties to set
     * @returns {ItemUseMsg} ItemUseMsg instance
     */
    ItemUseMsg.create = function create(properties) {
        return new ItemUseMsg(properties);
    };

    /**
     * Encodes the specified ItemUseMsg message. Does not implicitly {@link ItemUseMsg.verify|verify} messages.
     * @function encode
     * @memberof ItemUseMsg
     * @static
     * @param {IItemUseMsg} message ItemUseMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ItemUseMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.amount != null && message.hasOwnProperty("amount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.amount);
        return writer;
    };

    /**
     * Encodes the specified ItemUseMsg message, length delimited. Does not implicitly {@link ItemUseMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ItemUseMsg
     * @static
     * @param {IItemUseMsg} message ItemUseMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ItemUseMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ItemUseMsg message from the specified reader or buffer.
     * @function decode
     * @memberof ItemUseMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ItemUseMsg} ItemUseMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ItemUseMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemUseMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.amount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ItemUseMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ItemUseMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ItemUseMsg} ItemUseMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ItemUseMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ItemUseMsg message.
     * @function verify
     * @memberof ItemUseMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ItemUseMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.amount != null && message.hasOwnProperty("amount"))
            if (!$util.isInteger(message.amount))
                return "amount: integer expected";
        return null;
    };

    /**
     * Creates an ItemUseMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ItemUseMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ItemUseMsg} ItemUseMsg
     */
    ItemUseMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.ItemUseMsg)
            return object;
        var message = new $root.ItemUseMsg();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.amount != null)
            message.amount = object.amount | 0;
        return message;
    };

    /**
     * Creates a plain object from an ItemUseMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ItemUseMsg
     * @static
     * @param {ItemUseMsg} message ItemUseMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ItemUseMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            object.amount = 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.amount != null && message.hasOwnProperty("amount"))
            object.amount = message.amount;
        return object;
    };

    /**
     * Converts this ItemUseMsg to JSON.
     * @function toJSON
     * @memberof ItemUseMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ItemUseMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ItemUseMsg;
})();

$root.EquipAttrMsg = (function() {

    /**
     * Properties of an EquipAttrMsg.
     * @exports IEquipAttrMsg
     * @interface IEquipAttrMsg
     * @property {number|null} [type] EquipAttrMsg type
     * @property {number|null} [value] EquipAttrMsg value
     */

    /**
     * Constructs a new EquipAttrMsg.
     * @exports EquipAttrMsg
     * @classdesc Represents an EquipAttrMsg.
     * @implements IEquipAttrMsg
     * @constructor
     * @param {IEquipAttrMsg=} [properties] Properties to set
     */
    function EquipAttrMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EquipAttrMsg type.
     * @member {number} type
     * @memberof EquipAttrMsg
     * @instance
     */
    EquipAttrMsg.prototype.type = 0;

    /**
     * EquipAttrMsg value.
     * @member {number} value
     * @memberof EquipAttrMsg
     * @instance
     */
    EquipAttrMsg.prototype.value = 0;

    /**
     * Creates a new EquipAttrMsg instance using the specified properties.
     * @function create
     * @memberof EquipAttrMsg
     * @static
     * @param {IEquipAttrMsg=} [properties] Properties to set
     * @returns {EquipAttrMsg} EquipAttrMsg instance
     */
    EquipAttrMsg.create = function create(properties) {
        return new EquipAttrMsg(properties);
    };

    /**
     * Encodes the specified EquipAttrMsg message. Does not implicitly {@link EquipAttrMsg.verify|verify} messages.
     * @function encode
     * @memberof EquipAttrMsg
     * @static
     * @param {IEquipAttrMsg} message EquipAttrMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EquipAttrMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
        return writer;
    };

    /**
     * Encodes the specified EquipAttrMsg message, length delimited. Does not implicitly {@link EquipAttrMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EquipAttrMsg
     * @static
     * @param {IEquipAttrMsg} message EquipAttrMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EquipAttrMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EquipAttrMsg message from the specified reader or buffer.
     * @function decode
     * @memberof EquipAttrMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EquipAttrMsg} EquipAttrMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EquipAttrMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EquipAttrMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.value = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EquipAttrMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EquipAttrMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EquipAttrMsg} EquipAttrMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EquipAttrMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EquipAttrMsg message.
     * @function verify
     * @memberof EquipAttrMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EquipAttrMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isInteger(message.value))
                return "value: integer expected";
        return null;
    };

    /**
     * Creates an EquipAttrMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EquipAttrMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EquipAttrMsg} EquipAttrMsg
     */
    EquipAttrMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.EquipAttrMsg)
            return object;
        var message = new $root.EquipAttrMsg();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.value != null)
            message.value = object.value | 0;
        return message;
    };

    /**
     * Creates a plain object from an EquipAttrMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EquipAttrMsg
     * @static
     * @param {EquipAttrMsg} message EquipAttrMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EquipAttrMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            object.value = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this EquipAttrMsg to JSON.
     * @function toJSON
     * @memberof EquipAttrMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EquipAttrMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EquipAttrMsg;
})();

$root.CurrencyItem = (function() {

    /**
     * Properties of a CurrencyItem.
     * @exports ICurrencyItem
     * @interface ICurrencyItem
     * @property {number|null} [itemId] CurrencyItem itemId
     * @property {number|null} [count] CurrencyItem count
     */

    /**
     * Constructs a new CurrencyItem.
     * @exports CurrencyItem
     * @classdesc Represents a CurrencyItem.
     * @implements ICurrencyItem
     * @constructor
     * @param {ICurrencyItem=} [properties] Properties to set
     */
    function CurrencyItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CurrencyItem itemId.
     * @member {number} itemId
     * @memberof CurrencyItem
     * @instance
     */
    CurrencyItem.prototype.itemId = 0;

    /**
     * CurrencyItem count.
     * @member {number} count
     * @memberof CurrencyItem
     * @instance
     */
    CurrencyItem.prototype.count = 0;

    /**
     * Creates a new CurrencyItem instance using the specified properties.
     * @function create
     * @memberof CurrencyItem
     * @static
     * @param {ICurrencyItem=} [properties] Properties to set
     * @returns {CurrencyItem} CurrencyItem instance
     */
    CurrencyItem.create = function create(properties) {
        return new CurrencyItem(properties);
    };

    /**
     * Encodes the specified CurrencyItem message. Does not implicitly {@link CurrencyItem.verify|verify} messages.
     * @function encode
     * @memberof CurrencyItem
     * @static
     * @param {ICurrencyItem} message CurrencyItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CurrencyItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified CurrencyItem message, length delimited. Does not implicitly {@link CurrencyItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CurrencyItem
     * @static
     * @param {ICurrencyItem} message CurrencyItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CurrencyItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CurrencyItem message from the specified reader or buffer.
     * @function decode
     * @memberof CurrencyItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CurrencyItem} CurrencyItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CurrencyItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CurrencyItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.itemId = reader.int32();
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CurrencyItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CurrencyItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CurrencyItem} CurrencyItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CurrencyItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CurrencyItem message.
     * @function verify
     * @memberof CurrencyItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CurrencyItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            if (!$util.isInteger(message.itemId))
                return "itemId: integer expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a CurrencyItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CurrencyItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CurrencyItem} CurrencyItem
     */
    CurrencyItem.fromObject = function fromObject(object) {
        if (object instanceof $root.CurrencyItem)
            return object;
        var message = new $root.CurrencyItem();
        if (object.itemId != null)
            message.itemId = object.itemId | 0;
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a CurrencyItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CurrencyItem
     * @static
     * @param {CurrencyItem} message CurrencyItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CurrencyItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.itemId = 0;
            object.count = 0;
        }
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            object.itemId = message.itemId;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this CurrencyItem to JSON.
     * @function toJSON
     * @memberof CurrencyItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CurrencyItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CurrencyItem;
})();

/**
 * DongfuType enum.
 * @exports DongfuType
 * @enum {string}
 * @property {number} LingShi=1 LingShi value
 * @property {number} ShiWu=2 ShiWu value
 * @property {number} MuChai=3 MuChai value
 * @property {number} YunTie=4 YunTie value
 */
$root.DongfuType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "LingShi"] = 1;
    values[valuesById[2] = "ShiWu"] = 2;
    values[valuesById[3] = "MuChai"] = 3;
    values[valuesById[4] = "YunTie"] = 4;
    return values;
})();

$root.DongfuMsg = (function() {

    /**
     * Properties of a DongfuMsg.
     * @exports IDongfuMsg
     * @interface IDongfuMsg
     * @property {DongfuType|null} [type] DongfuMsg type
     * @property {number|null} [level] DongfuMsg level
     * @property {number|null} [worker] DongfuMsg worker
     */

    /**
     * Constructs a new DongfuMsg.
     * @exports DongfuMsg
     * @classdesc Represents a DongfuMsg.
     * @implements IDongfuMsg
     * @constructor
     * @param {IDongfuMsg=} [properties] Properties to set
     */
    function DongfuMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DongfuMsg type.
     * @member {DongfuType} type
     * @memberof DongfuMsg
     * @instance
     */
    DongfuMsg.prototype.type = 1;

    /**
     * DongfuMsg level.
     * @member {number} level
     * @memberof DongfuMsg
     * @instance
     */
    DongfuMsg.prototype.level = 0;

    /**
     * DongfuMsg worker.
     * @member {number} worker
     * @memberof DongfuMsg
     * @instance
     */
    DongfuMsg.prototype.worker = 0;

    /**
     * Creates a new DongfuMsg instance using the specified properties.
     * @function create
     * @memberof DongfuMsg
     * @static
     * @param {IDongfuMsg=} [properties] Properties to set
     * @returns {DongfuMsg} DongfuMsg instance
     */
    DongfuMsg.create = function create(properties) {
        return new DongfuMsg(properties);
    };

    /**
     * Encodes the specified DongfuMsg message. Does not implicitly {@link DongfuMsg.verify|verify} messages.
     * @function encode
     * @memberof DongfuMsg
     * @static
     * @param {IDongfuMsg} message DongfuMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DongfuMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
        if (message.worker != null && message.hasOwnProperty("worker"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.worker);
        return writer;
    };

    /**
     * Encodes the specified DongfuMsg message, length delimited. Does not implicitly {@link DongfuMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DongfuMsg
     * @static
     * @param {IDongfuMsg} message DongfuMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DongfuMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DongfuMsg message from the specified reader or buffer.
     * @function decode
     * @memberof DongfuMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DongfuMsg} DongfuMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DongfuMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DongfuMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.level = reader.int32();
                break;
            case 3:
                message.worker = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DongfuMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DongfuMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DongfuMsg} DongfuMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DongfuMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DongfuMsg message.
     * @function verify
     * @memberof DongfuMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DongfuMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.worker != null && message.hasOwnProperty("worker"))
            if (!$util.isInteger(message.worker))
                return "worker: integer expected";
        return null;
    };

    /**
     * Creates a DongfuMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DongfuMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DongfuMsg} DongfuMsg
     */
    DongfuMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.DongfuMsg)
            return object;
        var message = new $root.DongfuMsg();
        switch (object.type) {
        case "LingShi":
        case 1:
            message.type = 1;
            break;
        case "ShiWu":
        case 2:
            message.type = 2;
            break;
        case "MuChai":
        case 3:
            message.type = 3;
            break;
        case "YunTie":
        case 4:
            message.type = 4;
            break;
        }
        if (object.level != null)
            message.level = object.level | 0;
        if (object.worker != null)
            message.worker = object.worker | 0;
        return message;
    };

    /**
     * Creates a plain object from a DongfuMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DongfuMsg
     * @static
     * @param {DongfuMsg} message DongfuMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DongfuMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "LingShi" : 1;
            object.level = 0;
            object.worker = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.DongfuType[message.type] : message.type;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.worker != null && message.hasOwnProperty("worker"))
            object.worker = message.worker;
        return object;
    };

    /**
     * Converts this DongfuMsg to JSON.
     * @function toJSON
     * @memberof DongfuMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DongfuMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DongfuMsg;
})();

$root.C2S_Dongfu = (function() {

    /**
     * Properties of a C2S_Dongfu.
     * @exports IC2S_Dongfu
     * @interface IC2S_Dongfu
     */

    /**
     * Constructs a new C2S_Dongfu.
     * @exports C2S_Dongfu
     * @classdesc Represents a C2S_Dongfu.
     * @implements IC2S_Dongfu
     * @constructor
     * @param {IC2S_Dongfu=} [properties] Properties to set
     */
    function C2S_Dongfu(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_Dongfu instance using the specified properties.
     * @function create
     * @memberof C2S_Dongfu
     * @static
     * @param {IC2S_Dongfu=} [properties] Properties to set
     * @returns {C2S_Dongfu} C2S_Dongfu instance
     */
    C2S_Dongfu.create = function create(properties) {
        return new C2S_Dongfu(properties);
    };

    /**
     * Encodes the specified C2S_Dongfu message. Does not implicitly {@link C2S_Dongfu.verify|verify} messages.
     * @function encode
     * @memberof C2S_Dongfu
     * @static
     * @param {IC2S_Dongfu} message C2S_Dongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Dongfu.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_Dongfu message, length delimited. Does not implicitly {@link C2S_Dongfu.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Dongfu
     * @static
     * @param {IC2S_Dongfu} message C2S_Dongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Dongfu.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Dongfu message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Dongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Dongfu} C2S_Dongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Dongfu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Dongfu();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Dongfu message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Dongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Dongfu} C2S_Dongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Dongfu.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Dongfu message.
     * @function verify
     * @memberof C2S_Dongfu
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Dongfu.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_Dongfu message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Dongfu
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Dongfu} C2S_Dongfu
     */
    C2S_Dongfu.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Dongfu)
            return object;
        return new $root.C2S_Dongfu();
    };

    /**
     * Creates a plain object from a C2S_Dongfu message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Dongfu
     * @static
     * @param {C2S_Dongfu} message C2S_Dongfu
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Dongfu.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_Dongfu to JSON.
     * @function toJSON
     * @memberof C2S_Dongfu
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Dongfu.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Dongfu;
})();

$root.S2C_Dongfu = (function() {

    /**
     * Properties of a S2C_Dongfu.
     * @exports IS2C_Dongfu
     * @interface IS2C_Dongfu
     * @property {Array.<IDongfuMsg>|null} [dongfuRes] S2C_Dongfu dongfuRes
     * @property {number|null} [buyTimes] S2C_Dongfu buyTimes
     * @property {boolean|null} [shuGe] S2C_Dongfu shuGe
     * @property {boolean|null} [danFang] S2C_Dongfu danFang
     * @property {boolean|null} [qiShi] S2C_Dongfu qiShi
     */

    /**
     * Constructs a new S2C_Dongfu.
     * @exports S2C_Dongfu
     * @classdesc Represents a S2C_Dongfu.
     * @implements IS2C_Dongfu
     * @constructor
     * @param {IS2C_Dongfu=} [properties] Properties to set
     */
    function S2C_Dongfu(properties) {
        this.dongfuRes = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Dongfu dongfuRes.
     * @member {Array.<IDongfuMsg>} dongfuRes
     * @memberof S2C_Dongfu
     * @instance
     */
    S2C_Dongfu.prototype.dongfuRes = $util.emptyArray;

    /**
     * S2C_Dongfu buyTimes.
     * @member {number} buyTimes
     * @memberof S2C_Dongfu
     * @instance
     */
    S2C_Dongfu.prototype.buyTimes = 0;

    /**
     * S2C_Dongfu shuGe.
     * @member {boolean} shuGe
     * @memberof S2C_Dongfu
     * @instance
     */
    S2C_Dongfu.prototype.shuGe = false;

    /**
     * S2C_Dongfu danFang.
     * @member {boolean} danFang
     * @memberof S2C_Dongfu
     * @instance
     */
    S2C_Dongfu.prototype.danFang = false;

    /**
     * S2C_Dongfu qiShi.
     * @member {boolean} qiShi
     * @memberof S2C_Dongfu
     * @instance
     */
    S2C_Dongfu.prototype.qiShi = false;

    /**
     * Creates a new S2C_Dongfu instance using the specified properties.
     * @function create
     * @memberof S2C_Dongfu
     * @static
     * @param {IS2C_Dongfu=} [properties] Properties to set
     * @returns {S2C_Dongfu} S2C_Dongfu instance
     */
    S2C_Dongfu.create = function create(properties) {
        return new S2C_Dongfu(properties);
    };

    /**
     * Encodes the specified S2C_Dongfu message. Does not implicitly {@link S2C_Dongfu.verify|verify} messages.
     * @function encode
     * @memberof S2C_Dongfu
     * @static
     * @param {IS2C_Dongfu} message S2C_Dongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Dongfu.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dongfuRes != null && message.dongfuRes.length)
            for (var i = 0; i < message.dongfuRes.length; ++i)
                $root.DongfuMsg.encode(message.dongfuRes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.buyTimes != null && message.hasOwnProperty("buyTimes"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buyTimes);
        if (message.shuGe != null && message.hasOwnProperty("shuGe"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.shuGe);
        if (message.danFang != null && message.hasOwnProperty("danFang"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.danFang);
        if (message.qiShi != null && message.hasOwnProperty("qiShi"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.qiShi);
        return writer;
    };

    /**
     * Encodes the specified S2C_Dongfu message, length delimited. Does not implicitly {@link S2C_Dongfu.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Dongfu
     * @static
     * @param {IS2C_Dongfu} message S2C_Dongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Dongfu.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Dongfu message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Dongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Dongfu} S2C_Dongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Dongfu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Dongfu();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.dongfuRes && message.dongfuRes.length))
                    message.dongfuRes = [];
                message.dongfuRes.push($root.DongfuMsg.decode(reader, reader.uint32()));
                break;
            case 2:
                message.buyTimes = reader.int32();
                break;
            case 3:
                message.shuGe = reader.bool();
                break;
            case 4:
                message.danFang = reader.bool();
                break;
            case 5:
                message.qiShi = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Dongfu message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Dongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Dongfu} S2C_Dongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Dongfu.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Dongfu message.
     * @function verify
     * @memberof S2C_Dongfu
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Dongfu.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dongfuRes != null && message.hasOwnProperty("dongfuRes")) {
            if (!Array.isArray(message.dongfuRes))
                return "dongfuRes: array expected";
            for (var i = 0; i < message.dongfuRes.length; ++i) {
                var error = $root.DongfuMsg.verify(message.dongfuRes[i]);
                if (error)
                    return "dongfuRes." + error;
            }
        }
        if (message.buyTimes != null && message.hasOwnProperty("buyTimes"))
            if (!$util.isInteger(message.buyTimes))
                return "buyTimes: integer expected";
        if (message.shuGe != null && message.hasOwnProperty("shuGe"))
            if (typeof message.shuGe !== "boolean")
                return "shuGe: boolean expected";
        if (message.danFang != null && message.hasOwnProperty("danFang"))
            if (typeof message.danFang !== "boolean")
                return "danFang: boolean expected";
        if (message.qiShi != null && message.hasOwnProperty("qiShi"))
            if (typeof message.qiShi !== "boolean")
                return "qiShi: boolean expected";
        return null;
    };

    /**
     * Creates a S2C_Dongfu message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Dongfu
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Dongfu} S2C_Dongfu
     */
    S2C_Dongfu.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Dongfu)
            return object;
        var message = new $root.S2C_Dongfu();
        if (object.dongfuRes) {
            if (!Array.isArray(object.dongfuRes))
                throw TypeError(".S2C_Dongfu.dongfuRes: array expected");
            message.dongfuRes = [];
            for (var i = 0; i < object.dongfuRes.length; ++i) {
                if (typeof object.dongfuRes[i] !== "object")
                    throw TypeError(".S2C_Dongfu.dongfuRes: object expected");
                message.dongfuRes[i] = $root.DongfuMsg.fromObject(object.dongfuRes[i]);
            }
        }
        if (object.buyTimes != null)
            message.buyTimes = object.buyTimes | 0;
        if (object.shuGe != null)
            message.shuGe = Boolean(object.shuGe);
        if (object.danFang != null)
            message.danFang = Boolean(object.danFang);
        if (object.qiShi != null)
            message.qiShi = Boolean(object.qiShi);
        return message;
    };

    /**
     * Creates a plain object from a S2C_Dongfu message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Dongfu
     * @static
     * @param {S2C_Dongfu} message S2C_Dongfu
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Dongfu.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.dongfuRes = [];
        if (options.defaults) {
            object.buyTimes = 0;
            object.shuGe = false;
            object.danFang = false;
            object.qiShi = false;
        }
        if (message.dongfuRes && message.dongfuRes.length) {
            object.dongfuRes = [];
            for (var j = 0; j < message.dongfuRes.length; ++j)
                object.dongfuRes[j] = $root.DongfuMsg.toObject(message.dongfuRes[j], options);
        }
        if (message.buyTimes != null && message.hasOwnProperty("buyTimes"))
            object.buyTimes = message.buyTimes;
        if (message.shuGe != null && message.hasOwnProperty("shuGe"))
            object.shuGe = message.shuGe;
        if (message.danFang != null && message.hasOwnProperty("danFang"))
            object.danFang = message.danFang;
        if (message.qiShi != null && message.hasOwnProperty("qiShi"))
            object.qiShi = message.qiShi;
        return object;
    };

    /**
     * Converts this S2C_Dongfu to JSON.
     * @function toJSON
     * @memberof S2C_Dongfu
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Dongfu.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Dongfu;
})();

$root.C2S_UpgradeDongfu = (function() {

    /**
     * Properties of a C2S_UpgradeDongfu.
     * @exports IC2S_UpgradeDongfu
     * @interface IC2S_UpgradeDongfu
     * @property {DongfuType|null} [type] C2S_UpgradeDongfu type
     */

    /**
     * Constructs a new C2S_UpgradeDongfu.
     * @exports C2S_UpgradeDongfu
     * @classdesc Represents a C2S_UpgradeDongfu.
     * @implements IC2S_UpgradeDongfu
     * @constructor
     * @param {IC2S_UpgradeDongfu=} [properties] Properties to set
     */
    function C2S_UpgradeDongfu(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_UpgradeDongfu type.
     * @member {DongfuType} type
     * @memberof C2S_UpgradeDongfu
     * @instance
     */
    C2S_UpgradeDongfu.prototype.type = 1;

    /**
     * Creates a new C2S_UpgradeDongfu instance using the specified properties.
     * @function create
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {IC2S_UpgradeDongfu=} [properties] Properties to set
     * @returns {C2S_UpgradeDongfu} C2S_UpgradeDongfu instance
     */
    C2S_UpgradeDongfu.create = function create(properties) {
        return new C2S_UpgradeDongfu(properties);
    };

    /**
     * Encodes the specified C2S_UpgradeDongfu message. Does not implicitly {@link C2S_UpgradeDongfu.verify|verify} messages.
     * @function encode
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {IC2S_UpgradeDongfu} message C2S_UpgradeDongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradeDongfu.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified C2S_UpgradeDongfu message, length delimited. Does not implicitly {@link C2S_UpgradeDongfu.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {IC2S_UpgradeDongfu} message C2S_UpgradeDongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradeDongfu.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_UpgradeDongfu message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_UpgradeDongfu} C2S_UpgradeDongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradeDongfu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_UpgradeDongfu();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_UpgradeDongfu message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_UpgradeDongfu} C2S_UpgradeDongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradeDongfu.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_UpgradeDongfu message.
     * @function verify
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_UpgradeDongfu.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        return null;
    };

    /**
     * Creates a C2S_UpgradeDongfu message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_UpgradeDongfu} C2S_UpgradeDongfu
     */
    C2S_UpgradeDongfu.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_UpgradeDongfu)
            return object;
        var message = new $root.C2S_UpgradeDongfu();
        switch (object.type) {
        case "LingShi":
        case 1:
            message.type = 1;
            break;
        case "ShiWu":
        case 2:
            message.type = 2;
            break;
        case "MuChai":
        case 3:
            message.type = 3;
            break;
        case "YunTie":
        case 4:
            message.type = 4;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_UpgradeDongfu message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_UpgradeDongfu
     * @static
     * @param {C2S_UpgradeDongfu} message C2S_UpgradeDongfu
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_UpgradeDongfu.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "LingShi" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.DongfuType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this C2S_UpgradeDongfu to JSON.
     * @function toJSON
     * @memberof C2S_UpgradeDongfu
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_UpgradeDongfu.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_UpgradeDongfu;
})();

$root.S2C_UpgradeDongfu = (function() {

    /**
     * Properties of a S2C_UpgradeDongfu.
     * @exports IS2C_UpgradeDongfu
     * @interface IS2C_UpgradeDongfu
     * @property {DongfuType|null} [type] S2C_UpgradeDongfu type
     */

    /**
     * Constructs a new S2C_UpgradeDongfu.
     * @exports S2C_UpgradeDongfu
     * @classdesc Represents a S2C_UpgradeDongfu.
     * @implements IS2C_UpgradeDongfu
     * @constructor
     * @param {IS2C_UpgradeDongfu=} [properties] Properties to set
     */
    function S2C_UpgradeDongfu(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_UpgradeDongfu type.
     * @member {DongfuType} type
     * @memberof S2C_UpgradeDongfu
     * @instance
     */
    S2C_UpgradeDongfu.prototype.type = 1;

    /**
     * Creates a new S2C_UpgradeDongfu instance using the specified properties.
     * @function create
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {IS2C_UpgradeDongfu=} [properties] Properties to set
     * @returns {S2C_UpgradeDongfu} S2C_UpgradeDongfu instance
     */
    S2C_UpgradeDongfu.create = function create(properties) {
        return new S2C_UpgradeDongfu(properties);
    };

    /**
     * Encodes the specified S2C_UpgradeDongfu message. Does not implicitly {@link S2C_UpgradeDongfu.verify|verify} messages.
     * @function encode
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {IS2C_UpgradeDongfu} message S2C_UpgradeDongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradeDongfu.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified S2C_UpgradeDongfu message, length delimited. Does not implicitly {@link S2C_UpgradeDongfu.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {IS2C_UpgradeDongfu} message S2C_UpgradeDongfu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradeDongfu.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_UpgradeDongfu message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_UpgradeDongfu} S2C_UpgradeDongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradeDongfu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_UpgradeDongfu();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_UpgradeDongfu message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_UpgradeDongfu} S2C_UpgradeDongfu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradeDongfu.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_UpgradeDongfu message.
     * @function verify
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_UpgradeDongfu.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        return null;
    };

    /**
     * Creates a S2C_UpgradeDongfu message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_UpgradeDongfu} S2C_UpgradeDongfu
     */
    S2C_UpgradeDongfu.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_UpgradeDongfu)
            return object;
        var message = new $root.S2C_UpgradeDongfu();
        switch (object.type) {
        case "LingShi":
        case 1:
            message.type = 1;
            break;
        case "ShiWu":
        case 2:
            message.type = 2;
            break;
        case "MuChai":
        case 3:
            message.type = 3;
            break;
        case "YunTie":
        case 4:
            message.type = 4;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_UpgradeDongfu message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_UpgradeDongfu
     * @static
     * @param {S2C_UpgradeDongfu} message S2C_UpgradeDongfu
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_UpgradeDongfu.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "LingShi" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.DongfuType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this S2C_UpgradeDongfu to JSON.
     * @function toJSON
     * @memberof S2C_UpgradeDongfu
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_UpgradeDongfu.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_UpgradeDongfu;
})();

$root.C2S_ChangeWorker = (function() {

    /**
     * Properties of a C2S_ChangeWorker.
     * @exports IC2S_ChangeWorker
     * @interface IC2S_ChangeWorker
     * @property {DongfuType|null} [type] C2S_ChangeWorker type
     * @property {number|null} [count] C2S_ChangeWorker count
     */

    /**
     * Constructs a new C2S_ChangeWorker.
     * @exports C2S_ChangeWorker
     * @classdesc Represents a C2S_ChangeWorker.
     * @implements IC2S_ChangeWorker
     * @constructor
     * @param {IC2S_ChangeWorker=} [properties] Properties to set
     */
    function C2S_ChangeWorker(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_ChangeWorker type.
     * @member {DongfuType} type
     * @memberof C2S_ChangeWorker
     * @instance
     */
    C2S_ChangeWorker.prototype.type = 1;

    /**
     * C2S_ChangeWorker count.
     * @member {number} count
     * @memberof C2S_ChangeWorker
     * @instance
     */
    C2S_ChangeWorker.prototype.count = 0;

    /**
     * Creates a new C2S_ChangeWorker instance using the specified properties.
     * @function create
     * @memberof C2S_ChangeWorker
     * @static
     * @param {IC2S_ChangeWorker=} [properties] Properties to set
     * @returns {C2S_ChangeWorker} C2S_ChangeWorker instance
     */
    C2S_ChangeWorker.create = function create(properties) {
        return new C2S_ChangeWorker(properties);
    };

    /**
     * Encodes the specified C2S_ChangeWorker message. Does not implicitly {@link C2S_ChangeWorker.verify|verify} messages.
     * @function encode
     * @memberof C2S_ChangeWorker
     * @static
     * @param {IC2S_ChangeWorker} message C2S_ChangeWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ChangeWorker.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified C2S_ChangeWorker message, length delimited. Does not implicitly {@link C2S_ChangeWorker.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_ChangeWorker
     * @static
     * @param {IC2S_ChangeWorker} message C2S_ChangeWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ChangeWorker.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_ChangeWorker message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_ChangeWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_ChangeWorker} C2S_ChangeWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ChangeWorker.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_ChangeWorker();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_ChangeWorker message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_ChangeWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_ChangeWorker} C2S_ChangeWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ChangeWorker.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_ChangeWorker message.
     * @function verify
     * @memberof C2S_ChangeWorker
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_ChangeWorker.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a C2S_ChangeWorker message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_ChangeWorker
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_ChangeWorker} C2S_ChangeWorker
     */
    C2S_ChangeWorker.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_ChangeWorker)
            return object;
        var message = new $root.C2S_ChangeWorker();
        switch (object.type) {
        case "LingShi":
        case 1:
            message.type = 1;
            break;
        case "ShiWu":
        case 2:
            message.type = 2;
            break;
        case "MuChai":
        case 3:
            message.type = 3;
            break;
        case "YunTie":
        case 4:
            message.type = 4;
            break;
        }
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_ChangeWorker message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_ChangeWorker
     * @static
     * @param {C2S_ChangeWorker} message C2S_ChangeWorker
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_ChangeWorker.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "LingShi" : 1;
            object.count = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.DongfuType[message.type] : message.type;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this C2S_ChangeWorker to JSON.
     * @function toJSON
     * @memberof C2S_ChangeWorker
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_ChangeWorker.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_ChangeWorker;
})();

$root.S2C_ChangeWorker = (function() {

    /**
     * Properties of a S2C_ChangeWorker.
     * @exports IS2C_ChangeWorker
     * @interface IS2C_ChangeWorker
     * @property {DongfuType|null} [type] S2C_ChangeWorker type
     * @property {number|null} [count] S2C_ChangeWorker count
     */

    /**
     * Constructs a new S2C_ChangeWorker.
     * @exports S2C_ChangeWorker
     * @classdesc Represents a S2C_ChangeWorker.
     * @implements IS2C_ChangeWorker
     * @constructor
     * @param {IS2C_ChangeWorker=} [properties] Properties to set
     */
    function S2C_ChangeWorker(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ChangeWorker type.
     * @member {DongfuType} type
     * @memberof S2C_ChangeWorker
     * @instance
     */
    S2C_ChangeWorker.prototype.type = 1;

    /**
     * S2C_ChangeWorker count.
     * @member {number} count
     * @memberof S2C_ChangeWorker
     * @instance
     */
    S2C_ChangeWorker.prototype.count = 0;

    /**
     * Creates a new S2C_ChangeWorker instance using the specified properties.
     * @function create
     * @memberof S2C_ChangeWorker
     * @static
     * @param {IS2C_ChangeWorker=} [properties] Properties to set
     * @returns {S2C_ChangeWorker} S2C_ChangeWorker instance
     */
    S2C_ChangeWorker.create = function create(properties) {
        return new S2C_ChangeWorker(properties);
    };

    /**
     * Encodes the specified S2C_ChangeWorker message. Does not implicitly {@link S2C_ChangeWorker.verify|verify} messages.
     * @function encode
     * @memberof S2C_ChangeWorker
     * @static
     * @param {IS2C_ChangeWorker} message S2C_ChangeWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ChangeWorker.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified S2C_ChangeWorker message, length delimited. Does not implicitly {@link S2C_ChangeWorker.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ChangeWorker
     * @static
     * @param {IS2C_ChangeWorker} message S2C_ChangeWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ChangeWorker.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ChangeWorker message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ChangeWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ChangeWorker} S2C_ChangeWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ChangeWorker.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ChangeWorker();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ChangeWorker message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ChangeWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ChangeWorker} S2C_ChangeWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ChangeWorker.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ChangeWorker message.
     * @function verify
     * @memberof S2C_ChangeWorker
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ChangeWorker.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a S2C_ChangeWorker message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ChangeWorker
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ChangeWorker} S2C_ChangeWorker
     */
    S2C_ChangeWorker.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ChangeWorker)
            return object;
        var message = new $root.S2C_ChangeWorker();
        switch (object.type) {
        case "LingShi":
        case 1:
            message.type = 1;
            break;
        case "ShiWu":
        case 2:
            message.type = 2;
            break;
        case "MuChai":
        case 3:
            message.type = 3;
            break;
        case "YunTie":
        case 4:
            message.type = 4;
            break;
        }
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_ChangeWorker message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ChangeWorker
     * @static
     * @param {S2C_ChangeWorker} message S2C_ChangeWorker
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ChangeWorker.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "LingShi" : 1;
            object.count = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.DongfuType[message.type] : message.type;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this S2C_ChangeWorker to JSON.
     * @function toJSON
     * @memberof S2C_ChangeWorker
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ChangeWorker.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ChangeWorker;
})();

$root.C2S_AddWorker = (function() {

    /**
     * Properties of a C2S_AddWorker.
     * @exports IC2S_AddWorker
     * @interface IC2S_AddWorker
     */

    /**
     * Constructs a new C2S_AddWorker.
     * @exports C2S_AddWorker
     * @classdesc Represents a C2S_AddWorker.
     * @implements IC2S_AddWorker
     * @constructor
     * @param {IC2S_AddWorker=} [properties] Properties to set
     */
    function C2S_AddWorker(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_AddWorker instance using the specified properties.
     * @function create
     * @memberof C2S_AddWorker
     * @static
     * @param {IC2S_AddWorker=} [properties] Properties to set
     * @returns {C2S_AddWorker} C2S_AddWorker instance
     */
    C2S_AddWorker.create = function create(properties) {
        return new C2S_AddWorker(properties);
    };

    /**
     * Encodes the specified C2S_AddWorker message. Does not implicitly {@link C2S_AddWorker.verify|verify} messages.
     * @function encode
     * @memberof C2S_AddWorker
     * @static
     * @param {IC2S_AddWorker} message C2S_AddWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_AddWorker.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_AddWorker message, length delimited. Does not implicitly {@link C2S_AddWorker.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_AddWorker
     * @static
     * @param {IC2S_AddWorker} message C2S_AddWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_AddWorker.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_AddWorker message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_AddWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_AddWorker} C2S_AddWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_AddWorker.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_AddWorker();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_AddWorker message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_AddWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_AddWorker} C2S_AddWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_AddWorker.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_AddWorker message.
     * @function verify
     * @memberof C2S_AddWorker
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_AddWorker.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_AddWorker message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_AddWorker
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_AddWorker} C2S_AddWorker
     */
    C2S_AddWorker.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_AddWorker)
            return object;
        return new $root.C2S_AddWorker();
    };

    /**
     * Creates a plain object from a C2S_AddWorker message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_AddWorker
     * @static
     * @param {C2S_AddWorker} message C2S_AddWorker
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_AddWorker.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_AddWorker to JSON.
     * @function toJSON
     * @memberof C2S_AddWorker
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_AddWorker.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_AddWorker;
})();

$root.S2C_AddWorker = (function() {

    /**
     * Properties of a S2C_AddWorker.
     * @exports IS2C_AddWorker
     * @interface IS2C_AddWorker
     */

    /**
     * Constructs a new S2C_AddWorker.
     * @exports S2C_AddWorker
     * @classdesc Represents a S2C_AddWorker.
     * @implements IS2C_AddWorker
     * @constructor
     * @param {IS2C_AddWorker=} [properties] Properties to set
     */
    function S2C_AddWorker(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_AddWorker instance using the specified properties.
     * @function create
     * @memberof S2C_AddWorker
     * @static
     * @param {IS2C_AddWorker=} [properties] Properties to set
     * @returns {S2C_AddWorker} S2C_AddWorker instance
     */
    S2C_AddWorker.create = function create(properties) {
        return new S2C_AddWorker(properties);
    };

    /**
     * Encodes the specified S2C_AddWorker message. Does not implicitly {@link S2C_AddWorker.verify|verify} messages.
     * @function encode
     * @memberof S2C_AddWorker
     * @static
     * @param {IS2C_AddWorker} message S2C_AddWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_AddWorker.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_AddWorker message, length delimited. Does not implicitly {@link S2C_AddWorker.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_AddWorker
     * @static
     * @param {IS2C_AddWorker} message S2C_AddWorker message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_AddWorker.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_AddWorker message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_AddWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_AddWorker} S2C_AddWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_AddWorker.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_AddWorker();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_AddWorker message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_AddWorker
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_AddWorker} S2C_AddWorker
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_AddWorker.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_AddWorker message.
     * @function verify
     * @memberof S2C_AddWorker
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_AddWorker.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_AddWorker message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_AddWorker
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_AddWorker} S2C_AddWorker
     */
    S2C_AddWorker.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_AddWorker)
            return object;
        return new $root.S2C_AddWorker();
    };

    /**
     * Creates a plain object from a S2C_AddWorker message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_AddWorker
     * @static
     * @param {S2C_AddWorker} message S2C_AddWorker
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_AddWorker.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_AddWorker to JSON.
     * @function toJSON
     * @memberof S2C_AddWorker
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_AddWorker.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_AddWorker;
})();

/**
 * XiuLianType enum.
 * @exports XiuLianType
 * @enum {string}
 * @property {number} LianYao=1 LianYao value
 * @property {number} LianQi=2 LianQi value
 * @property {number} WuXing=3 WuXing value
 */
$root.XiuLianType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "LianYao"] = 1;
    values[valuesById[2] = "LianQi"] = 2;
    values[valuesById[3] = "WuXing"] = 3;
    return values;
})();

$root.C2S_XiuLianOpt = (function() {

    /**
     * Properties of a C2S_XiuLianOpt.
     * @exports IC2S_XiuLianOpt
     * @interface IC2S_XiuLianOpt
     * @property {XiuLianType|null} [type] C2S_XiuLianOpt type
     * @property {number|null} [year] C2S_XiuLianOpt year
     */

    /**
     * Constructs a new C2S_XiuLianOpt.
     * @exports C2S_XiuLianOpt
     * @classdesc Represents a C2S_XiuLianOpt.
     * @implements IC2S_XiuLianOpt
     * @constructor
     * @param {IC2S_XiuLianOpt=} [properties] Properties to set
     */
    function C2S_XiuLianOpt(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_XiuLianOpt type.
     * @member {XiuLianType} type
     * @memberof C2S_XiuLianOpt
     * @instance
     */
    C2S_XiuLianOpt.prototype.type = 1;

    /**
     * C2S_XiuLianOpt year.
     * @member {number} year
     * @memberof C2S_XiuLianOpt
     * @instance
     */
    C2S_XiuLianOpt.prototype.year = 0;

    /**
     * Creates a new C2S_XiuLianOpt instance using the specified properties.
     * @function create
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {IC2S_XiuLianOpt=} [properties] Properties to set
     * @returns {C2S_XiuLianOpt} C2S_XiuLianOpt instance
     */
    C2S_XiuLianOpt.create = function create(properties) {
        return new C2S_XiuLianOpt(properties);
    };

    /**
     * Encodes the specified C2S_XiuLianOpt message. Does not implicitly {@link C2S_XiuLianOpt.verify|verify} messages.
     * @function encode
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {IC2S_XiuLianOpt} message C2S_XiuLianOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_XiuLianOpt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.year != null && message.hasOwnProperty("year"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.year);
        return writer;
    };

    /**
     * Encodes the specified C2S_XiuLianOpt message, length delimited. Does not implicitly {@link C2S_XiuLianOpt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {IC2S_XiuLianOpt} message C2S_XiuLianOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_XiuLianOpt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_XiuLianOpt message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_XiuLianOpt} C2S_XiuLianOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_XiuLianOpt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_XiuLianOpt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.year = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_XiuLianOpt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_XiuLianOpt} C2S_XiuLianOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_XiuLianOpt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_XiuLianOpt message.
     * @function verify
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_XiuLianOpt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
                break;
            }
        if (message.year != null && message.hasOwnProperty("year"))
            if (!$util.isInteger(message.year))
                return "year: integer expected";
        return null;
    };

    /**
     * Creates a C2S_XiuLianOpt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_XiuLianOpt} C2S_XiuLianOpt
     */
    C2S_XiuLianOpt.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_XiuLianOpt)
            return object;
        var message = new $root.C2S_XiuLianOpt();
        switch (object.type) {
        case "LianYao":
        case 1:
            message.type = 1;
            break;
        case "LianQi":
        case 2:
            message.type = 2;
            break;
        case "WuXing":
        case 3:
            message.type = 3;
            break;
        }
        if (object.year != null)
            message.year = object.year | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_XiuLianOpt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_XiuLianOpt
     * @static
     * @param {C2S_XiuLianOpt} message C2S_XiuLianOpt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_XiuLianOpt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "LianYao" : 1;
            object.year = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.XiuLianType[message.type] : message.type;
        if (message.year != null && message.hasOwnProperty("year"))
            object.year = message.year;
        return object;
    };

    /**
     * Converts this C2S_XiuLianOpt to JSON.
     * @function toJSON
     * @memberof C2S_XiuLianOpt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_XiuLianOpt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_XiuLianOpt;
})();

$root.S2C_XiuLianOpt = (function() {

    /**
     * Properties of a S2C_XiuLianOpt.
     * @exports IS2C_XiuLianOpt
     * @interface IS2C_XiuLianOpt
     * @property {XiuLianType|null} [type] S2C_XiuLianOpt type
     * @property {number|null} [year] S2C_XiuLianOpt year
     */

    /**
     * Constructs a new S2C_XiuLianOpt.
     * @exports S2C_XiuLianOpt
     * @classdesc Represents a S2C_XiuLianOpt.
     * @implements IS2C_XiuLianOpt
     * @constructor
     * @param {IS2C_XiuLianOpt=} [properties] Properties to set
     */
    function S2C_XiuLianOpt(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_XiuLianOpt type.
     * @member {XiuLianType} type
     * @memberof S2C_XiuLianOpt
     * @instance
     */
    S2C_XiuLianOpt.prototype.type = 1;

    /**
     * S2C_XiuLianOpt year.
     * @member {number} year
     * @memberof S2C_XiuLianOpt
     * @instance
     */
    S2C_XiuLianOpt.prototype.year = 0;

    /**
     * Creates a new S2C_XiuLianOpt instance using the specified properties.
     * @function create
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {IS2C_XiuLianOpt=} [properties] Properties to set
     * @returns {S2C_XiuLianOpt} S2C_XiuLianOpt instance
     */
    S2C_XiuLianOpt.create = function create(properties) {
        return new S2C_XiuLianOpt(properties);
    };

    /**
     * Encodes the specified S2C_XiuLianOpt message. Does not implicitly {@link S2C_XiuLianOpt.verify|verify} messages.
     * @function encode
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {IS2C_XiuLianOpt} message S2C_XiuLianOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_XiuLianOpt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.year != null && message.hasOwnProperty("year"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.year);
        return writer;
    };

    /**
     * Encodes the specified S2C_XiuLianOpt message, length delimited. Does not implicitly {@link S2C_XiuLianOpt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {IS2C_XiuLianOpt} message S2C_XiuLianOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_XiuLianOpt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_XiuLianOpt message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_XiuLianOpt} S2C_XiuLianOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_XiuLianOpt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_XiuLianOpt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.year = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_XiuLianOpt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_XiuLianOpt} S2C_XiuLianOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_XiuLianOpt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_XiuLianOpt message.
     * @function verify
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_XiuLianOpt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
                break;
            }
        if (message.year != null && message.hasOwnProperty("year"))
            if (!$util.isInteger(message.year))
                return "year: integer expected";
        return null;
    };

    /**
     * Creates a S2C_XiuLianOpt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_XiuLianOpt} S2C_XiuLianOpt
     */
    S2C_XiuLianOpt.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_XiuLianOpt)
            return object;
        var message = new $root.S2C_XiuLianOpt();
        switch (object.type) {
        case "LianYao":
        case 1:
            message.type = 1;
            break;
        case "LianQi":
        case 2:
            message.type = 2;
            break;
        case "WuXing":
        case 3:
            message.type = 3;
            break;
        }
        if (object.year != null)
            message.year = object.year | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_XiuLianOpt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_XiuLianOpt
     * @static
     * @param {S2C_XiuLianOpt} message S2C_XiuLianOpt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_XiuLianOpt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "LianYao" : 1;
            object.year = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.XiuLianType[message.type] : message.type;
        if (message.year != null && message.hasOwnProperty("year"))
            object.year = message.year;
        return object;
    };

    /**
     * Converts this S2C_XiuLianOpt to JSON.
     * @function toJSON
     * @memberof S2C_XiuLianOpt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_XiuLianOpt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_XiuLianOpt;
})();

$root.C2S_BuyWine = (function() {

    /**
     * Properties of a C2S_BuyWine.
     * @exports IC2S_BuyWine
     * @interface IC2S_BuyWine
     * @property {number|null} [id] C2S_BuyWine id
     */

    /**
     * Constructs a new C2S_BuyWine.
     * @exports C2S_BuyWine
     * @classdesc Represents a C2S_BuyWine.
     * @implements IC2S_BuyWine
     * @constructor
     * @param {IC2S_BuyWine=} [properties] Properties to set
     */
    function C2S_BuyWine(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_BuyWine id.
     * @member {number} id
     * @memberof C2S_BuyWine
     * @instance
     */
    C2S_BuyWine.prototype.id = 0;

    /**
     * Creates a new C2S_BuyWine instance using the specified properties.
     * @function create
     * @memberof C2S_BuyWine
     * @static
     * @param {IC2S_BuyWine=} [properties] Properties to set
     * @returns {C2S_BuyWine} C2S_BuyWine instance
     */
    C2S_BuyWine.create = function create(properties) {
        return new C2S_BuyWine(properties);
    };

    /**
     * Encodes the specified C2S_BuyWine message. Does not implicitly {@link C2S_BuyWine.verify|verify} messages.
     * @function encode
     * @memberof C2S_BuyWine
     * @static
     * @param {IC2S_BuyWine} message C2S_BuyWine message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_BuyWine.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_BuyWine message, length delimited. Does not implicitly {@link C2S_BuyWine.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_BuyWine
     * @static
     * @param {IC2S_BuyWine} message C2S_BuyWine message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_BuyWine.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_BuyWine message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_BuyWine
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_BuyWine} C2S_BuyWine
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_BuyWine.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_BuyWine();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_BuyWine message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_BuyWine
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_BuyWine} C2S_BuyWine
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_BuyWine.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_BuyWine message.
     * @function verify
     * @memberof C2S_BuyWine
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_BuyWine.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_BuyWine message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_BuyWine
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_BuyWine} C2S_BuyWine
     */
    C2S_BuyWine.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_BuyWine)
            return object;
        var message = new $root.C2S_BuyWine();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_BuyWine message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_BuyWine
     * @static
     * @param {C2S_BuyWine} message C2S_BuyWine
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_BuyWine.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_BuyWine to JSON.
     * @function toJSON
     * @memberof C2S_BuyWine
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_BuyWine.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_BuyWine;
})();

$root.S2C_BuyWine = (function() {

    /**
     * Properties of a S2C_BuyWine.
     * @exports IS2C_BuyWine
     * @interface IS2C_BuyWine
     * @property {number|null} [id] S2C_BuyWine id
     */

    /**
     * Constructs a new S2C_BuyWine.
     * @exports S2C_BuyWine
     * @classdesc Represents a S2C_BuyWine.
     * @implements IS2C_BuyWine
     * @constructor
     * @param {IS2C_BuyWine=} [properties] Properties to set
     */
    function S2C_BuyWine(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_BuyWine id.
     * @member {number} id
     * @memberof S2C_BuyWine
     * @instance
     */
    S2C_BuyWine.prototype.id = 0;

    /**
     * Creates a new S2C_BuyWine instance using the specified properties.
     * @function create
     * @memberof S2C_BuyWine
     * @static
     * @param {IS2C_BuyWine=} [properties] Properties to set
     * @returns {S2C_BuyWine} S2C_BuyWine instance
     */
    S2C_BuyWine.create = function create(properties) {
        return new S2C_BuyWine(properties);
    };

    /**
     * Encodes the specified S2C_BuyWine message. Does not implicitly {@link S2C_BuyWine.verify|verify} messages.
     * @function encode
     * @memberof S2C_BuyWine
     * @static
     * @param {IS2C_BuyWine} message S2C_BuyWine message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_BuyWine.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified S2C_BuyWine message, length delimited. Does not implicitly {@link S2C_BuyWine.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_BuyWine
     * @static
     * @param {IS2C_BuyWine} message S2C_BuyWine message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_BuyWine.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_BuyWine message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_BuyWine
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_BuyWine} S2C_BuyWine
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_BuyWine.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_BuyWine();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_BuyWine message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_BuyWine
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_BuyWine} S2C_BuyWine
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_BuyWine.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_BuyWine message.
     * @function verify
     * @memberof S2C_BuyWine
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_BuyWine.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a S2C_BuyWine message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_BuyWine
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_BuyWine} S2C_BuyWine
     */
    S2C_BuyWine.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_BuyWine)
            return object;
        var message = new $root.S2C_BuyWine();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_BuyWine message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_BuyWine
     * @static
     * @param {S2C_BuyWine} message S2C_BuyWine
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_BuyWine.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this S2C_BuyWine to JSON.
     * @function toJSON
     * @memberof S2C_BuyWine
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_BuyWine.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_BuyWine;
})();

/**
 * BuildType enum.
 * @exports BuildType
 * @enum {string}
 * @property {number} ShuGe=1 ShuGe value
 * @property {number} DanFang=2 DanFang value
 * @property {number} QiShi=3 QiShi value
 * @property {number} YaoGu=4 YaoGu value
 * @property {number} XianNiang=5 XianNiang value
 */
$root.BuildType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "ShuGe"] = 1;
    values[valuesById[2] = "DanFang"] = 2;
    values[valuesById[3] = "QiShi"] = 3;
    values[valuesById[4] = "YaoGu"] = 4;
    values[valuesById[5] = "XianNiang"] = 5;
    return values;
})();

$root.C2S_MakeRoom = (function() {

    /**
     * Properties of a C2S_MakeRoom.
     * @exports IC2S_MakeRoom
     * @interface IC2S_MakeRoom
     * @property {BuildType|null} [type] C2S_MakeRoom type
     */

    /**
     * Constructs a new C2S_MakeRoom.
     * @exports C2S_MakeRoom
     * @classdesc Represents a C2S_MakeRoom.
     * @implements IC2S_MakeRoom
     * @constructor
     * @param {IC2S_MakeRoom=} [properties] Properties to set
     */
    function C2S_MakeRoom(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MakeRoom type.
     * @member {BuildType} type
     * @memberof C2S_MakeRoom
     * @instance
     */
    C2S_MakeRoom.prototype.type = 1;

    /**
     * Creates a new C2S_MakeRoom instance using the specified properties.
     * @function create
     * @memberof C2S_MakeRoom
     * @static
     * @param {IC2S_MakeRoom=} [properties] Properties to set
     * @returns {C2S_MakeRoom} C2S_MakeRoom instance
     */
    C2S_MakeRoom.create = function create(properties) {
        return new C2S_MakeRoom(properties);
    };

    /**
     * Encodes the specified C2S_MakeRoom message. Does not implicitly {@link C2S_MakeRoom.verify|verify} messages.
     * @function encode
     * @memberof C2S_MakeRoom
     * @static
     * @param {IC2S_MakeRoom} message C2S_MakeRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MakeRoom.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified C2S_MakeRoom message, length delimited. Does not implicitly {@link C2S_MakeRoom.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MakeRoom
     * @static
     * @param {IC2S_MakeRoom} message C2S_MakeRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MakeRoom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MakeRoom message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MakeRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MakeRoom} C2S_MakeRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MakeRoom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MakeRoom();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MakeRoom message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MakeRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MakeRoom} C2S_MakeRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MakeRoom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MakeRoom message.
     * @function verify
     * @memberof C2S_MakeRoom
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MakeRoom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        return null;
    };

    /**
     * Creates a C2S_MakeRoom message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MakeRoom
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MakeRoom} C2S_MakeRoom
     */
    C2S_MakeRoom.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MakeRoom)
            return object;
        var message = new $root.C2S_MakeRoom();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_MakeRoom message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MakeRoom
     * @static
     * @param {C2S_MakeRoom} message C2S_MakeRoom
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MakeRoom.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "ShuGe" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this C2S_MakeRoom to JSON.
     * @function toJSON
     * @memberof C2S_MakeRoom
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MakeRoom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MakeRoom;
})();

$root.S2C_MakeRoom = (function() {

    /**
     * Properties of a S2C_MakeRoom.
     * @exports IS2C_MakeRoom
     * @interface IS2C_MakeRoom
     * @property {Array.<number>|null} [instructions] S2C_MakeRoom instructions
     * @property {Array.<number>|null} [machine] S2C_MakeRoom machine
     * @property {boolean|null} [autoChoose] S2C_MakeRoom autoChoose
     * @property {number|null} [normalLeft] S2C_MakeRoom normalLeft
     * @property {number|null} [bestLeft] S2C_MakeRoom bestLeft
     * @property {BuildType|null} [type] S2C_MakeRoom type
     * @property {number|null} [makeId] S2C_MakeRoom makeId
     * @property {number|null} [makeCount] S2C_MakeRoom makeCount
     * @property {number|Long|null} [endTime] S2C_MakeRoom endTime
     * @property {number|null} [make_Machine] S2C_MakeRoom make_Machine
     * @property {number|null} [succCount] S2C_MakeRoom succCount
     * @property {number|null} [level] S2C_MakeRoom level
     */

    /**
     * Constructs a new S2C_MakeRoom.
     * @exports S2C_MakeRoom
     * @classdesc Represents a S2C_MakeRoom.
     * @implements IS2C_MakeRoom
     * @constructor
     * @param {IS2C_MakeRoom=} [properties] Properties to set
     */
    function S2C_MakeRoom(properties) {
        this.instructions = [];
        this.machine = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MakeRoom instructions.
     * @member {Array.<number>} instructions
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.instructions = $util.emptyArray;

    /**
     * S2C_MakeRoom machine.
     * @member {Array.<number>} machine
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.machine = $util.emptyArray;

    /**
     * S2C_MakeRoom autoChoose.
     * @member {boolean} autoChoose
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.autoChoose = false;

    /**
     * S2C_MakeRoom normalLeft.
     * @member {number} normalLeft
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.normalLeft = 0;

    /**
     * S2C_MakeRoom bestLeft.
     * @member {number} bestLeft
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.bestLeft = 0;

    /**
     * S2C_MakeRoom type.
     * @member {BuildType} type
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.type = 1;

    /**
     * S2C_MakeRoom makeId.
     * @member {number} makeId
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.makeId = 0;

    /**
     * S2C_MakeRoom makeCount.
     * @member {number} makeCount
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.makeCount = 0;

    /**
     * S2C_MakeRoom endTime.
     * @member {number|Long} endTime
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_MakeRoom make_Machine.
     * @member {number} make_Machine
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.make_Machine = 0;

    /**
     * S2C_MakeRoom succCount.
     * @member {number} succCount
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.succCount = 0;

    /**
     * S2C_MakeRoom level.
     * @member {number} level
     * @memberof S2C_MakeRoom
     * @instance
     */
    S2C_MakeRoom.prototype.level = 0;

    /**
     * Creates a new S2C_MakeRoom instance using the specified properties.
     * @function create
     * @memberof S2C_MakeRoom
     * @static
     * @param {IS2C_MakeRoom=} [properties] Properties to set
     * @returns {S2C_MakeRoom} S2C_MakeRoom instance
     */
    S2C_MakeRoom.create = function create(properties) {
        return new S2C_MakeRoom(properties);
    };

    /**
     * Encodes the specified S2C_MakeRoom message. Does not implicitly {@link S2C_MakeRoom.verify|verify} messages.
     * @function encode
     * @memberof S2C_MakeRoom
     * @static
     * @param {IS2C_MakeRoom} message S2C_MakeRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MakeRoom.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.instructions != null && message.instructions.length)
            for (var i = 0; i < message.instructions.length; ++i)
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.instructions[i]);
        if (message.machine != null && message.machine.length)
            for (var i = 0; i < message.machine.length; ++i)
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.machine[i]);
        if (message.autoChoose != null && message.hasOwnProperty("autoChoose"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.autoChoose);
        if (message.normalLeft != null && message.hasOwnProperty("normalLeft"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.normalLeft);
        if (message.bestLeft != null && message.hasOwnProperty("bestLeft"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.bestLeft);
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
        if (message.makeId != null && message.hasOwnProperty("makeId"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.makeId);
        if (message.makeCount != null && message.hasOwnProperty("makeCount"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.makeCount);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.endTime);
        if (message.make_Machine != null && message.hasOwnProperty("make_Machine"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.make_Machine);
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.succCount);
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.level);
        return writer;
    };

    /**
     * Encodes the specified S2C_MakeRoom message, length delimited. Does not implicitly {@link S2C_MakeRoom.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MakeRoom
     * @static
     * @param {IS2C_MakeRoom} message S2C_MakeRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MakeRoom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MakeRoom message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MakeRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MakeRoom} S2C_MakeRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MakeRoom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MakeRoom();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.instructions && message.instructions.length))
                    message.instructions = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.instructions.push(reader.int32());
                } else
                    message.instructions.push(reader.int32());
                break;
            case 2:
                if (!(message.machine && message.machine.length))
                    message.machine = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.machine.push(reader.int32());
                } else
                    message.machine.push(reader.int32());
                break;
            case 3:
                message.autoChoose = reader.bool();
                break;
            case 4:
                message.normalLeft = reader.int32();
                break;
            case 5:
                message.bestLeft = reader.int32();
                break;
            case 6:
                message.type = reader.int32();
                break;
            case 7:
                message.makeId = reader.int32();
                break;
            case 8:
                message.makeCount = reader.int32();
                break;
            case 9:
                message.endTime = reader.int64();
                break;
            case 10:
                message.make_Machine = reader.int32();
                break;
            case 11:
                message.succCount = reader.int32();
                break;
            case 12:
                message.level = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MakeRoom message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MakeRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MakeRoom} S2C_MakeRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MakeRoom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MakeRoom message.
     * @function verify
     * @memberof S2C_MakeRoom
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MakeRoom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.instructions != null && message.hasOwnProperty("instructions")) {
            if (!Array.isArray(message.instructions))
                return "instructions: array expected";
            for (var i = 0; i < message.instructions.length; ++i)
                if (!$util.isInteger(message.instructions[i]))
                    return "instructions: integer[] expected";
        }
        if (message.machine != null && message.hasOwnProperty("machine")) {
            if (!Array.isArray(message.machine))
                return "machine: array expected";
            for (var i = 0; i < message.machine.length; ++i)
                if (!$util.isInteger(message.machine[i]))
                    return "machine: integer[] expected";
        }
        if (message.autoChoose != null && message.hasOwnProperty("autoChoose"))
            if (typeof message.autoChoose !== "boolean")
                return "autoChoose: boolean expected";
        if (message.normalLeft != null && message.hasOwnProperty("normalLeft"))
            if (!$util.isInteger(message.normalLeft))
                return "normalLeft: integer expected";
        if (message.bestLeft != null && message.hasOwnProperty("bestLeft"))
            if (!$util.isInteger(message.bestLeft))
                return "bestLeft: integer expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        if (message.makeId != null && message.hasOwnProperty("makeId"))
            if (!$util.isInteger(message.makeId))
                return "makeId: integer expected";
        if (message.makeCount != null && message.hasOwnProperty("makeCount"))
            if (!$util.isInteger(message.makeCount))
                return "makeCount: integer expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                return "endTime: integer|Long expected";
        if (message.make_Machine != null && message.hasOwnProperty("make_Machine"))
            if (!$util.isInteger(message.make_Machine))
                return "make_Machine: integer expected";
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            if (!$util.isInteger(message.succCount))
                return "succCount: integer expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        return null;
    };

    /**
     * Creates a S2C_MakeRoom message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MakeRoom
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MakeRoom} S2C_MakeRoom
     */
    S2C_MakeRoom.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MakeRoom)
            return object;
        var message = new $root.S2C_MakeRoom();
        if (object.instructions) {
            if (!Array.isArray(object.instructions))
                throw TypeError(".S2C_MakeRoom.instructions: array expected");
            message.instructions = [];
            for (var i = 0; i < object.instructions.length; ++i)
                message.instructions[i] = object.instructions[i] | 0;
        }
        if (object.machine) {
            if (!Array.isArray(object.machine))
                throw TypeError(".S2C_MakeRoom.machine: array expected");
            message.machine = [];
            for (var i = 0; i < object.machine.length; ++i)
                message.machine[i] = object.machine[i] | 0;
        }
        if (object.autoChoose != null)
            message.autoChoose = Boolean(object.autoChoose);
        if (object.normalLeft != null)
            message.normalLeft = object.normalLeft | 0;
        if (object.bestLeft != null)
            message.bestLeft = object.bestLeft | 0;
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        if (object.makeId != null)
            message.makeId = object.makeId | 0;
        if (object.makeCount != null)
            message.makeCount = object.makeCount | 0;
        if (object.endTime != null)
            if ($util.Long)
                (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
            else if (typeof object.endTime === "string")
                message.endTime = parseInt(object.endTime, 10);
            else if (typeof object.endTime === "number")
                message.endTime = object.endTime;
            else if (typeof object.endTime === "object")
                message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
        if (object.make_Machine != null)
            message.make_Machine = object.make_Machine | 0;
        if (object.succCount != null)
            message.succCount = object.succCount | 0;
        if (object.level != null)
            message.level = object.level | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_MakeRoom message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MakeRoom
     * @static
     * @param {S2C_MakeRoom} message S2C_MakeRoom
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MakeRoom.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.instructions = [];
            object.machine = [];
        }
        if (options.defaults) {
            object.autoChoose = false;
            object.normalLeft = 0;
            object.bestLeft = 0;
            object.type = options.enums === String ? "ShuGe" : 1;
            object.makeId = 0;
            object.makeCount = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.endTime = options.longs === String ? "0" : 0;
            object.make_Machine = 0;
            object.succCount = 0;
            object.level = 0;
        }
        if (message.instructions && message.instructions.length) {
            object.instructions = [];
            for (var j = 0; j < message.instructions.length; ++j)
                object.instructions[j] = message.instructions[j];
        }
        if (message.machine && message.machine.length) {
            object.machine = [];
            for (var j = 0; j < message.machine.length; ++j)
                object.machine[j] = message.machine[j];
        }
        if (message.autoChoose != null && message.hasOwnProperty("autoChoose"))
            object.autoChoose = message.autoChoose;
        if (message.normalLeft != null && message.hasOwnProperty("normalLeft"))
            object.normalLeft = message.normalLeft;
        if (message.bestLeft != null && message.hasOwnProperty("bestLeft"))
            object.bestLeft = message.bestLeft;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        if (message.makeId != null && message.hasOwnProperty("makeId"))
            object.makeId = message.makeId;
        if (message.makeCount != null && message.hasOwnProperty("makeCount"))
            object.makeCount = message.makeCount;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
                object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
                object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
        if (message.make_Machine != null && message.hasOwnProperty("make_Machine"))
            object.make_Machine = message.make_Machine;
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            object.succCount = message.succCount;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        return object;
    };

    /**
     * Converts this S2C_MakeRoom to JSON.
     * @function toJSON
     * @memberof S2C_MakeRoom
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MakeRoom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MakeRoom;
})();

$root.C2S_MakeTreasure = (function() {

    /**
     * Properties of a C2S_MakeTreasure.
     * @exports IC2S_MakeTreasure
     * @interface IC2S_MakeTreasure
     * @property {BuildType|null} [type] C2S_MakeTreasure type
     * @property {number|null} [id] C2S_MakeTreasure id
     * @property {number|null} [machinePinZhi] C2S_MakeTreasure machinePinZhi
     * @property {number|null} [count] C2S_MakeTreasure count
     */

    /**
     * Constructs a new C2S_MakeTreasure.
     * @exports C2S_MakeTreasure
     * @classdesc Represents a C2S_MakeTreasure.
     * @implements IC2S_MakeTreasure
     * @constructor
     * @param {IC2S_MakeTreasure=} [properties] Properties to set
     */
    function C2S_MakeTreasure(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MakeTreasure type.
     * @member {BuildType} type
     * @memberof C2S_MakeTreasure
     * @instance
     */
    C2S_MakeTreasure.prototype.type = 1;

    /**
     * C2S_MakeTreasure id.
     * @member {number} id
     * @memberof C2S_MakeTreasure
     * @instance
     */
    C2S_MakeTreasure.prototype.id = 0;

    /**
     * C2S_MakeTreasure machinePinZhi.
     * @member {number} machinePinZhi
     * @memberof C2S_MakeTreasure
     * @instance
     */
    C2S_MakeTreasure.prototype.machinePinZhi = 0;

    /**
     * C2S_MakeTreasure count.
     * @member {number} count
     * @memberof C2S_MakeTreasure
     * @instance
     */
    C2S_MakeTreasure.prototype.count = 0;

    /**
     * Creates a new C2S_MakeTreasure instance using the specified properties.
     * @function create
     * @memberof C2S_MakeTreasure
     * @static
     * @param {IC2S_MakeTreasure=} [properties] Properties to set
     * @returns {C2S_MakeTreasure} C2S_MakeTreasure instance
     */
    C2S_MakeTreasure.create = function create(properties) {
        return new C2S_MakeTreasure(properties);
    };

    /**
     * Encodes the specified C2S_MakeTreasure message. Does not implicitly {@link C2S_MakeTreasure.verify|verify} messages.
     * @function encode
     * @memberof C2S_MakeTreasure
     * @static
     * @param {IC2S_MakeTreasure} message C2S_MakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MakeTreasure.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
        if (message.machinePinZhi != null && message.hasOwnProperty("machinePinZhi"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.machinePinZhi);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified C2S_MakeTreasure message, length delimited. Does not implicitly {@link C2S_MakeTreasure.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MakeTreasure
     * @static
     * @param {IC2S_MakeTreasure} message C2S_MakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MakeTreasure.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MakeTreasure message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MakeTreasure} C2S_MakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MakeTreasure.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MakeTreasure();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.id = reader.int32();
                break;
            case 3:
                message.machinePinZhi = reader.int32();
                break;
            case 4:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MakeTreasure message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MakeTreasure} C2S_MakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MakeTreasure.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MakeTreasure message.
     * @function verify
     * @memberof C2S_MakeTreasure
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MakeTreasure.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.machinePinZhi != null && message.hasOwnProperty("machinePinZhi"))
            if (!$util.isInteger(message.machinePinZhi))
                return "machinePinZhi: integer expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a C2S_MakeTreasure message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MakeTreasure
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MakeTreasure} C2S_MakeTreasure
     */
    C2S_MakeTreasure.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MakeTreasure)
            return object;
        var message = new $root.C2S_MakeTreasure();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        if (object.id != null)
            message.id = object.id | 0;
        if (object.machinePinZhi != null)
            message.machinePinZhi = object.machinePinZhi | 0;
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MakeTreasure message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MakeTreasure
     * @static
     * @param {C2S_MakeTreasure} message C2S_MakeTreasure
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MakeTreasure.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "ShuGe" : 1;
            object.id = 0;
            object.machinePinZhi = 0;
            object.count = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.machinePinZhi != null && message.hasOwnProperty("machinePinZhi"))
            object.machinePinZhi = message.machinePinZhi;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this C2S_MakeTreasure to JSON.
     * @function toJSON
     * @memberof C2S_MakeTreasure
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MakeTreasure.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MakeTreasure;
})();

$root.S2C_MakeTreasure = (function() {

    /**
     * Properties of a S2C_MakeTreasure.
     * @exports IS2C_MakeTreasure
     * @interface IS2C_MakeTreasure
     * @property {BuildType|null} [type] S2C_MakeTreasure type
     * @property {number|null} [id] S2C_MakeTreasure id
     * @property {number|null} [machinePinZhi] S2C_MakeTreasure machinePinZhi
     * @property {number|null} [count] S2C_MakeTreasure count
     * @property {number|null} [succCount] S2C_MakeTreasure succCount
     */

    /**
     * Constructs a new S2C_MakeTreasure.
     * @exports S2C_MakeTreasure
     * @classdesc Represents a S2C_MakeTreasure.
     * @implements IS2C_MakeTreasure
     * @constructor
     * @param {IS2C_MakeTreasure=} [properties] Properties to set
     */
    function S2C_MakeTreasure(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MakeTreasure type.
     * @member {BuildType} type
     * @memberof S2C_MakeTreasure
     * @instance
     */
    S2C_MakeTreasure.prototype.type = 1;

    /**
     * S2C_MakeTreasure id.
     * @member {number} id
     * @memberof S2C_MakeTreasure
     * @instance
     */
    S2C_MakeTreasure.prototype.id = 0;

    /**
     * S2C_MakeTreasure machinePinZhi.
     * @member {number} machinePinZhi
     * @memberof S2C_MakeTreasure
     * @instance
     */
    S2C_MakeTreasure.prototype.machinePinZhi = 0;

    /**
     * S2C_MakeTreasure count.
     * @member {number} count
     * @memberof S2C_MakeTreasure
     * @instance
     */
    S2C_MakeTreasure.prototype.count = 0;

    /**
     * S2C_MakeTreasure succCount.
     * @member {number} succCount
     * @memberof S2C_MakeTreasure
     * @instance
     */
    S2C_MakeTreasure.prototype.succCount = 0;

    /**
     * Creates a new S2C_MakeTreasure instance using the specified properties.
     * @function create
     * @memberof S2C_MakeTreasure
     * @static
     * @param {IS2C_MakeTreasure=} [properties] Properties to set
     * @returns {S2C_MakeTreasure} S2C_MakeTreasure instance
     */
    S2C_MakeTreasure.create = function create(properties) {
        return new S2C_MakeTreasure(properties);
    };

    /**
     * Encodes the specified S2C_MakeTreasure message. Does not implicitly {@link S2C_MakeTreasure.verify|verify} messages.
     * @function encode
     * @memberof S2C_MakeTreasure
     * @static
     * @param {IS2C_MakeTreasure} message S2C_MakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MakeTreasure.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
        if (message.machinePinZhi != null && message.hasOwnProperty("machinePinZhi"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.machinePinZhi);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.succCount);
        return writer;
    };

    /**
     * Encodes the specified S2C_MakeTreasure message, length delimited. Does not implicitly {@link S2C_MakeTreasure.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MakeTreasure
     * @static
     * @param {IS2C_MakeTreasure} message S2C_MakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MakeTreasure.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MakeTreasure message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MakeTreasure} S2C_MakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MakeTreasure.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MakeTreasure();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.id = reader.int32();
                break;
            case 3:
                message.machinePinZhi = reader.int32();
                break;
            case 4:
                message.count = reader.int32();
                break;
            case 5:
                message.succCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MakeTreasure message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MakeTreasure} S2C_MakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MakeTreasure.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MakeTreasure message.
     * @function verify
     * @memberof S2C_MakeTreasure
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MakeTreasure.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.machinePinZhi != null && message.hasOwnProperty("machinePinZhi"))
            if (!$util.isInteger(message.machinePinZhi))
                return "machinePinZhi: integer expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            if (!$util.isInteger(message.succCount))
                return "succCount: integer expected";
        return null;
    };

    /**
     * Creates a S2C_MakeTreasure message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MakeTreasure
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MakeTreasure} S2C_MakeTreasure
     */
    S2C_MakeTreasure.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MakeTreasure)
            return object;
        var message = new $root.S2C_MakeTreasure();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        if (object.id != null)
            message.id = object.id | 0;
        if (object.machinePinZhi != null)
            message.machinePinZhi = object.machinePinZhi | 0;
        if (object.count != null)
            message.count = object.count | 0;
        if (object.succCount != null)
            message.succCount = object.succCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_MakeTreasure message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MakeTreasure
     * @static
     * @param {S2C_MakeTreasure} message S2C_MakeTreasure
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MakeTreasure.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "ShuGe" : 1;
            object.id = 0;
            object.machinePinZhi = 0;
            object.count = 0;
            object.succCount = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.machinePinZhi != null && message.hasOwnProperty("machinePinZhi"))
            object.machinePinZhi = message.machinePinZhi;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            object.succCount = message.succCount;
        return object;
    };

    /**
     * Converts this S2C_MakeTreasure to JSON.
     * @function toJSON
     * @memberof S2C_MakeTreasure
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MakeTreasure.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MakeTreasure;
})();

$root.C2S_TakeTreasure = (function() {

    /**
     * Properties of a C2S_TakeTreasure.
     * @exports IC2S_TakeTreasure
     * @interface IC2S_TakeTreasure
     * @property {BuildType|null} [type] C2S_TakeTreasure type
     */

    /**
     * Constructs a new C2S_TakeTreasure.
     * @exports C2S_TakeTreasure
     * @classdesc Represents a C2S_TakeTreasure.
     * @implements IC2S_TakeTreasure
     * @constructor
     * @param {IC2S_TakeTreasure=} [properties] Properties to set
     */
    function C2S_TakeTreasure(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_TakeTreasure type.
     * @member {BuildType} type
     * @memberof C2S_TakeTreasure
     * @instance
     */
    C2S_TakeTreasure.prototype.type = 1;

    /**
     * Creates a new C2S_TakeTreasure instance using the specified properties.
     * @function create
     * @memberof C2S_TakeTreasure
     * @static
     * @param {IC2S_TakeTreasure=} [properties] Properties to set
     * @returns {C2S_TakeTreasure} C2S_TakeTreasure instance
     */
    C2S_TakeTreasure.create = function create(properties) {
        return new C2S_TakeTreasure(properties);
    };

    /**
     * Encodes the specified C2S_TakeTreasure message. Does not implicitly {@link C2S_TakeTreasure.verify|verify} messages.
     * @function encode
     * @memberof C2S_TakeTreasure
     * @static
     * @param {IC2S_TakeTreasure} message C2S_TakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_TakeTreasure.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified C2S_TakeTreasure message, length delimited. Does not implicitly {@link C2S_TakeTreasure.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_TakeTreasure
     * @static
     * @param {IC2S_TakeTreasure} message C2S_TakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_TakeTreasure.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_TakeTreasure message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_TakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_TakeTreasure} C2S_TakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_TakeTreasure.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_TakeTreasure();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_TakeTreasure message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_TakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_TakeTreasure} C2S_TakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_TakeTreasure.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_TakeTreasure message.
     * @function verify
     * @memberof C2S_TakeTreasure
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_TakeTreasure.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        return null;
    };

    /**
     * Creates a C2S_TakeTreasure message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_TakeTreasure
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_TakeTreasure} C2S_TakeTreasure
     */
    C2S_TakeTreasure.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_TakeTreasure)
            return object;
        var message = new $root.C2S_TakeTreasure();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_TakeTreasure message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_TakeTreasure
     * @static
     * @param {C2S_TakeTreasure} message C2S_TakeTreasure
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_TakeTreasure.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "ShuGe" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this C2S_TakeTreasure to JSON.
     * @function toJSON
     * @memberof C2S_TakeTreasure
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_TakeTreasure.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_TakeTreasure;
})();

$root.S2C_TakeTreasure = (function() {

    /**
     * Properties of a S2C_TakeTreasure.
     * @exports IS2C_TakeTreasure
     * @interface IS2C_TakeTreasure
     * @property {BuildType|null} [type] S2C_TakeTreasure type
     * @property {number|null} [succCount] S2C_TakeTreasure succCount
     * @property {number|null} [failCount] S2C_TakeTreasure failCount
     */

    /**
     * Constructs a new S2C_TakeTreasure.
     * @exports S2C_TakeTreasure
     * @classdesc Represents a S2C_TakeTreasure.
     * @implements IS2C_TakeTreasure
     * @constructor
     * @param {IS2C_TakeTreasure=} [properties] Properties to set
     */
    function S2C_TakeTreasure(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_TakeTreasure type.
     * @member {BuildType} type
     * @memberof S2C_TakeTreasure
     * @instance
     */
    S2C_TakeTreasure.prototype.type = 1;

    /**
     * S2C_TakeTreasure succCount.
     * @member {number} succCount
     * @memberof S2C_TakeTreasure
     * @instance
     */
    S2C_TakeTreasure.prototype.succCount = 0;

    /**
     * S2C_TakeTreasure failCount.
     * @member {number} failCount
     * @memberof S2C_TakeTreasure
     * @instance
     */
    S2C_TakeTreasure.prototype.failCount = 0;

    /**
     * Creates a new S2C_TakeTreasure instance using the specified properties.
     * @function create
     * @memberof S2C_TakeTreasure
     * @static
     * @param {IS2C_TakeTreasure=} [properties] Properties to set
     * @returns {S2C_TakeTreasure} S2C_TakeTreasure instance
     */
    S2C_TakeTreasure.create = function create(properties) {
        return new S2C_TakeTreasure(properties);
    };

    /**
     * Encodes the specified S2C_TakeTreasure message. Does not implicitly {@link S2C_TakeTreasure.verify|verify} messages.
     * @function encode
     * @memberof S2C_TakeTreasure
     * @static
     * @param {IS2C_TakeTreasure} message S2C_TakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_TakeTreasure.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.succCount);
        if (message.failCount != null && message.hasOwnProperty("failCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.failCount);
        return writer;
    };

    /**
     * Encodes the specified S2C_TakeTreasure message, length delimited. Does not implicitly {@link S2C_TakeTreasure.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_TakeTreasure
     * @static
     * @param {IS2C_TakeTreasure} message S2C_TakeTreasure message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_TakeTreasure.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_TakeTreasure message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_TakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_TakeTreasure} S2C_TakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_TakeTreasure.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_TakeTreasure();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.succCount = reader.int32();
                break;
            case 3:
                message.failCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_TakeTreasure message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_TakeTreasure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_TakeTreasure} S2C_TakeTreasure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_TakeTreasure.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_TakeTreasure message.
     * @function verify
     * @memberof S2C_TakeTreasure
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_TakeTreasure.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            if (!$util.isInteger(message.succCount))
                return "succCount: integer expected";
        if (message.failCount != null && message.hasOwnProperty("failCount"))
            if (!$util.isInteger(message.failCount))
                return "failCount: integer expected";
        return null;
    };

    /**
     * Creates a S2C_TakeTreasure message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_TakeTreasure
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_TakeTreasure} S2C_TakeTreasure
     */
    S2C_TakeTreasure.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_TakeTreasure)
            return object;
        var message = new $root.S2C_TakeTreasure();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        if (object.succCount != null)
            message.succCount = object.succCount | 0;
        if (object.failCount != null)
            message.failCount = object.failCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_TakeTreasure message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_TakeTreasure
     * @static
     * @param {S2C_TakeTreasure} message S2C_TakeTreasure
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_TakeTreasure.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "ShuGe" : 1;
            object.succCount = 0;
            object.failCount = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        if (message.succCount != null && message.hasOwnProperty("succCount"))
            object.succCount = message.succCount;
        if (message.failCount != null && message.hasOwnProperty("failCount"))
            object.failCount = message.failCount;
        return object;
    };

    /**
     * Converts this S2C_TakeTreasure to JSON.
     * @function toJSON
     * @memberof S2C_TakeTreasure
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_TakeTreasure.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_TakeTreasure;
})();

$root.C2S_ReadBook = (function() {

    /**
     * Properties of a C2S_ReadBook.
     * @exports IC2S_ReadBook
     * @interface IC2S_ReadBook
     * @property {number|null} [id] C2S_ReadBook id
     */

    /**
     * Constructs a new C2S_ReadBook.
     * @exports C2S_ReadBook
     * @classdesc Represents a C2S_ReadBook.
     * @implements IC2S_ReadBook
     * @constructor
     * @param {IC2S_ReadBook=} [properties] Properties to set
     */
    function C2S_ReadBook(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_ReadBook id.
     * @member {number} id
     * @memberof C2S_ReadBook
     * @instance
     */
    C2S_ReadBook.prototype.id = 0;

    /**
     * Creates a new C2S_ReadBook instance using the specified properties.
     * @function create
     * @memberof C2S_ReadBook
     * @static
     * @param {IC2S_ReadBook=} [properties] Properties to set
     * @returns {C2S_ReadBook} C2S_ReadBook instance
     */
    C2S_ReadBook.create = function create(properties) {
        return new C2S_ReadBook(properties);
    };

    /**
     * Encodes the specified C2S_ReadBook message. Does not implicitly {@link C2S_ReadBook.verify|verify} messages.
     * @function encode
     * @memberof C2S_ReadBook
     * @static
     * @param {IC2S_ReadBook} message C2S_ReadBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ReadBook.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_ReadBook message, length delimited. Does not implicitly {@link C2S_ReadBook.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_ReadBook
     * @static
     * @param {IC2S_ReadBook} message C2S_ReadBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ReadBook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_ReadBook message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_ReadBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_ReadBook} C2S_ReadBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ReadBook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_ReadBook();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_ReadBook message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_ReadBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_ReadBook} C2S_ReadBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ReadBook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_ReadBook message.
     * @function verify
     * @memberof C2S_ReadBook
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_ReadBook.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_ReadBook message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_ReadBook
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_ReadBook} C2S_ReadBook
     */
    C2S_ReadBook.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_ReadBook)
            return object;
        var message = new $root.C2S_ReadBook();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_ReadBook message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_ReadBook
     * @static
     * @param {C2S_ReadBook} message C2S_ReadBook
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_ReadBook.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_ReadBook to JSON.
     * @function toJSON
     * @memberof C2S_ReadBook
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_ReadBook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_ReadBook;
})();

$root.S2C_ReadBook = (function() {

    /**
     * Properties of a S2C_ReadBook.
     * @exports IS2C_ReadBook
     * @interface IS2C_ReadBook
     * @property {number|null} [id] S2C_ReadBook id
     */

    /**
     * Constructs a new S2C_ReadBook.
     * @exports S2C_ReadBook
     * @classdesc Represents a S2C_ReadBook.
     * @implements IS2C_ReadBook
     * @constructor
     * @param {IS2C_ReadBook=} [properties] Properties to set
     */
    function S2C_ReadBook(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ReadBook id.
     * @member {number} id
     * @memberof S2C_ReadBook
     * @instance
     */
    S2C_ReadBook.prototype.id = 0;

    /**
     * Creates a new S2C_ReadBook instance using the specified properties.
     * @function create
     * @memberof S2C_ReadBook
     * @static
     * @param {IS2C_ReadBook=} [properties] Properties to set
     * @returns {S2C_ReadBook} S2C_ReadBook instance
     */
    S2C_ReadBook.create = function create(properties) {
        return new S2C_ReadBook(properties);
    };

    /**
     * Encodes the specified S2C_ReadBook message. Does not implicitly {@link S2C_ReadBook.verify|verify} messages.
     * @function encode
     * @memberof S2C_ReadBook
     * @static
     * @param {IS2C_ReadBook} message S2C_ReadBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ReadBook.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified S2C_ReadBook message, length delimited. Does not implicitly {@link S2C_ReadBook.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ReadBook
     * @static
     * @param {IS2C_ReadBook} message S2C_ReadBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ReadBook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ReadBook message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ReadBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ReadBook} S2C_ReadBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ReadBook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ReadBook();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ReadBook message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ReadBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ReadBook} S2C_ReadBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ReadBook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ReadBook message.
     * @function verify
     * @memberof S2C_ReadBook
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ReadBook.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a S2C_ReadBook message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ReadBook
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ReadBook} S2C_ReadBook
     */
    S2C_ReadBook.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ReadBook)
            return object;
        var message = new $root.S2C_ReadBook();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_ReadBook message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ReadBook
     * @static
     * @param {S2C_ReadBook} message S2C_ReadBook
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ReadBook.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this S2C_ReadBook to JSON.
     * @function toJSON
     * @memberof S2C_ReadBook
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ReadBook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ReadBook;
})();

$root.C2S_ReadBookLevelUp = (function() {

    /**
     * Properties of a C2S_ReadBookLevelUp.
     * @exports IC2S_ReadBookLevelUp
     * @interface IC2S_ReadBookLevelUp
     * @property {number|null} [id] C2S_ReadBookLevelUp id
     */

    /**
     * Constructs a new C2S_ReadBookLevelUp.
     * @exports C2S_ReadBookLevelUp
     * @classdesc Represents a C2S_ReadBookLevelUp.
     * @implements IC2S_ReadBookLevelUp
     * @constructor
     * @param {IC2S_ReadBookLevelUp=} [properties] Properties to set
     */
    function C2S_ReadBookLevelUp(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_ReadBookLevelUp id.
     * @member {number} id
     * @memberof C2S_ReadBookLevelUp
     * @instance
     */
    C2S_ReadBookLevelUp.prototype.id = 0;

    /**
     * Creates a new C2S_ReadBookLevelUp instance using the specified properties.
     * @function create
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {IC2S_ReadBookLevelUp=} [properties] Properties to set
     * @returns {C2S_ReadBookLevelUp} C2S_ReadBookLevelUp instance
     */
    C2S_ReadBookLevelUp.create = function create(properties) {
        return new C2S_ReadBookLevelUp(properties);
    };

    /**
     * Encodes the specified C2S_ReadBookLevelUp message. Does not implicitly {@link C2S_ReadBookLevelUp.verify|verify} messages.
     * @function encode
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {IC2S_ReadBookLevelUp} message C2S_ReadBookLevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ReadBookLevelUp.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_ReadBookLevelUp message, length delimited. Does not implicitly {@link C2S_ReadBookLevelUp.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {IC2S_ReadBookLevelUp} message C2S_ReadBookLevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ReadBookLevelUp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_ReadBookLevelUp message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_ReadBookLevelUp} C2S_ReadBookLevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ReadBookLevelUp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_ReadBookLevelUp();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_ReadBookLevelUp message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_ReadBookLevelUp} C2S_ReadBookLevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ReadBookLevelUp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_ReadBookLevelUp message.
     * @function verify
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_ReadBookLevelUp.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_ReadBookLevelUp message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_ReadBookLevelUp} C2S_ReadBookLevelUp
     */
    C2S_ReadBookLevelUp.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_ReadBookLevelUp)
            return object;
        var message = new $root.C2S_ReadBookLevelUp();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_ReadBookLevelUp message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_ReadBookLevelUp
     * @static
     * @param {C2S_ReadBookLevelUp} message C2S_ReadBookLevelUp
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_ReadBookLevelUp.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_ReadBookLevelUp to JSON.
     * @function toJSON
     * @memberof C2S_ReadBookLevelUp
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_ReadBookLevelUp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_ReadBookLevelUp;
})();

$root.S2C_ReadBookLevelUp = (function() {

    /**
     * Properties of a S2C_ReadBookLevelUp.
     * @exports IS2C_ReadBookLevelUp
     * @interface IS2C_ReadBookLevelUp
     * @property {number|null} [id] S2C_ReadBookLevelUp id
     */

    /**
     * Constructs a new S2C_ReadBookLevelUp.
     * @exports S2C_ReadBookLevelUp
     * @classdesc Represents a S2C_ReadBookLevelUp.
     * @implements IS2C_ReadBookLevelUp
     * @constructor
     * @param {IS2C_ReadBookLevelUp=} [properties] Properties to set
     */
    function S2C_ReadBookLevelUp(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ReadBookLevelUp id.
     * @member {number} id
     * @memberof S2C_ReadBookLevelUp
     * @instance
     */
    S2C_ReadBookLevelUp.prototype.id = 0;

    /**
     * Creates a new S2C_ReadBookLevelUp instance using the specified properties.
     * @function create
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {IS2C_ReadBookLevelUp=} [properties] Properties to set
     * @returns {S2C_ReadBookLevelUp} S2C_ReadBookLevelUp instance
     */
    S2C_ReadBookLevelUp.create = function create(properties) {
        return new S2C_ReadBookLevelUp(properties);
    };

    /**
     * Encodes the specified S2C_ReadBookLevelUp message. Does not implicitly {@link S2C_ReadBookLevelUp.verify|verify} messages.
     * @function encode
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {IS2C_ReadBookLevelUp} message S2C_ReadBookLevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ReadBookLevelUp.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified S2C_ReadBookLevelUp message, length delimited. Does not implicitly {@link S2C_ReadBookLevelUp.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {IS2C_ReadBookLevelUp} message S2C_ReadBookLevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ReadBookLevelUp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ReadBookLevelUp message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ReadBookLevelUp} S2C_ReadBookLevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ReadBookLevelUp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ReadBookLevelUp();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ReadBookLevelUp message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ReadBookLevelUp} S2C_ReadBookLevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ReadBookLevelUp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ReadBookLevelUp message.
     * @function verify
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ReadBookLevelUp.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a S2C_ReadBookLevelUp message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ReadBookLevelUp} S2C_ReadBookLevelUp
     */
    S2C_ReadBookLevelUp.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ReadBookLevelUp)
            return object;
        var message = new $root.S2C_ReadBookLevelUp();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_ReadBookLevelUp message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ReadBookLevelUp
     * @static
     * @param {S2C_ReadBookLevelUp} message S2C_ReadBookLevelUp
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ReadBookLevelUp.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this S2C_ReadBookLevelUp to JSON.
     * @function toJSON
     * @memberof S2C_ReadBookLevelUp
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ReadBookLevelUp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ReadBookLevelUp;
})();

$root.C2S_DongfuBuild = (function() {

    /**
     * Properties of a C2S_DongfuBuild.
     * @exports IC2S_DongfuBuild
     * @interface IC2S_DongfuBuild
     * @property {BuildType|null} [type] C2S_DongfuBuild type
     */

    /**
     * Constructs a new C2S_DongfuBuild.
     * @exports C2S_DongfuBuild
     * @classdesc Represents a C2S_DongfuBuild.
     * @implements IC2S_DongfuBuild
     * @constructor
     * @param {IC2S_DongfuBuild=} [properties] Properties to set
     */
    function C2S_DongfuBuild(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_DongfuBuild type.
     * @member {BuildType} type
     * @memberof C2S_DongfuBuild
     * @instance
     */
    C2S_DongfuBuild.prototype.type = 1;

    /**
     * Creates a new C2S_DongfuBuild instance using the specified properties.
     * @function create
     * @memberof C2S_DongfuBuild
     * @static
     * @param {IC2S_DongfuBuild=} [properties] Properties to set
     * @returns {C2S_DongfuBuild} C2S_DongfuBuild instance
     */
    C2S_DongfuBuild.create = function create(properties) {
        return new C2S_DongfuBuild(properties);
    };

    /**
     * Encodes the specified C2S_DongfuBuild message. Does not implicitly {@link C2S_DongfuBuild.verify|verify} messages.
     * @function encode
     * @memberof C2S_DongfuBuild
     * @static
     * @param {IC2S_DongfuBuild} message C2S_DongfuBuild message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_DongfuBuild.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified C2S_DongfuBuild message, length delimited. Does not implicitly {@link C2S_DongfuBuild.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_DongfuBuild
     * @static
     * @param {IC2S_DongfuBuild} message C2S_DongfuBuild message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_DongfuBuild.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_DongfuBuild message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_DongfuBuild
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_DongfuBuild} C2S_DongfuBuild
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_DongfuBuild.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_DongfuBuild();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_DongfuBuild message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_DongfuBuild
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_DongfuBuild} C2S_DongfuBuild
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_DongfuBuild.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_DongfuBuild message.
     * @function verify
     * @memberof C2S_DongfuBuild
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_DongfuBuild.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        return null;
    };

    /**
     * Creates a C2S_DongfuBuild message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_DongfuBuild
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_DongfuBuild} C2S_DongfuBuild
     */
    C2S_DongfuBuild.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_DongfuBuild)
            return object;
        var message = new $root.C2S_DongfuBuild();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_DongfuBuild message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_DongfuBuild
     * @static
     * @param {C2S_DongfuBuild} message C2S_DongfuBuild
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_DongfuBuild.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "ShuGe" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this C2S_DongfuBuild to JSON.
     * @function toJSON
     * @memberof C2S_DongfuBuild
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_DongfuBuild.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_DongfuBuild;
})();

$root.S2C_DongfuBuild = (function() {

    /**
     * Properties of a S2C_DongfuBuild.
     * @exports IS2C_DongfuBuild
     * @interface IS2C_DongfuBuild
     * @property {BuildType|null} [type] S2C_DongfuBuild type
     */

    /**
     * Constructs a new S2C_DongfuBuild.
     * @exports S2C_DongfuBuild
     * @classdesc Represents a S2C_DongfuBuild.
     * @implements IS2C_DongfuBuild
     * @constructor
     * @param {IS2C_DongfuBuild=} [properties] Properties to set
     */
    function S2C_DongfuBuild(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_DongfuBuild type.
     * @member {BuildType} type
     * @memberof S2C_DongfuBuild
     * @instance
     */
    S2C_DongfuBuild.prototype.type = 1;

    /**
     * Creates a new S2C_DongfuBuild instance using the specified properties.
     * @function create
     * @memberof S2C_DongfuBuild
     * @static
     * @param {IS2C_DongfuBuild=} [properties] Properties to set
     * @returns {S2C_DongfuBuild} S2C_DongfuBuild instance
     */
    S2C_DongfuBuild.create = function create(properties) {
        return new S2C_DongfuBuild(properties);
    };

    /**
     * Encodes the specified S2C_DongfuBuild message. Does not implicitly {@link S2C_DongfuBuild.verify|verify} messages.
     * @function encode
     * @memberof S2C_DongfuBuild
     * @static
     * @param {IS2C_DongfuBuild} message S2C_DongfuBuild message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_DongfuBuild.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified S2C_DongfuBuild message, length delimited. Does not implicitly {@link S2C_DongfuBuild.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_DongfuBuild
     * @static
     * @param {IS2C_DongfuBuild} message S2C_DongfuBuild message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_DongfuBuild.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_DongfuBuild message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_DongfuBuild
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_DongfuBuild} S2C_DongfuBuild
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_DongfuBuild.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_DongfuBuild();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_DongfuBuild message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_DongfuBuild
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_DongfuBuild} S2C_DongfuBuild
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_DongfuBuild.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_DongfuBuild message.
     * @function verify
     * @memberof S2C_DongfuBuild
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_DongfuBuild.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        return null;
    };

    /**
     * Creates a S2C_DongfuBuild message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_DongfuBuild
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_DongfuBuild} S2C_DongfuBuild
     */
    S2C_DongfuBuild.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_DongfuBuild)
            return object;
        var message = new $root.S2C_DongfuBuild();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_DongfuBuild message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_DongfuBuild
     * @static
     * @param {S2C_DongfuBuild} message S2C_DongfuBuild
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_DongfuBuild.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "ShuGe" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this S2C_DongfuBuild to JSON.
     * @function toJSON
     * @memberof S2C_DongfuBuild
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_DongfuBuild.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_DongfuBuild;
})();

$root.C2S_DongfuShuge = (function() {

    /**
     * Properties of a C2S_DongfuShuge.
     * @exports IC2S_DongfuShuge
     * @interface IC2S_DongfuShuge
     * @property {XiuLianType|null} [type] C2S_DongfuShuge type
     */

    /**
     * Constructs a new C2S_DongfuShuge.
     * @exports C2S_DongfuShuge
     * @classdesc Represents a C2S_DongfuShuge.
     * @implements IC2S_DongfuShuge
     * @constructor
     * @param {IC2S_DongfuShuge=} [properties] Properties to set
     */
    function C2S_DongfuShuge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_DongfuShuge type.
     * @member {XiuLianType} type
     * @memberof C2S_DongfuShuge
     * @instance
     */
    C2S_DongfuShuge.prototype.type = 1;

    /**
     * Creates a new C2S_DongfuShuge instance using the specified properties.
     * @function create
     * @memberof C2S_DongfuShuge
     * @static
     * @param {IC2S_DongfuShuge=} [properties] Properties to set
     * @returns {C2S_DongfuShuge} C2S_DongfuShuge instance
     */
    C2S_DongfuShuge.create = function create(properties) {
        return new C2S_DongfuShuge(properties);
    };

    /**
     * Encodes the specified C2S_DongfuShuge message. Does not implicitly {@link C2S_DongfuShuge.verify|verify} messages.
     * @function encode
     * @memberof C2S_DongfuShuge
     * @static
     * @param {IC2S_DongfuShuge} message C2S_DongfuShuge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_DongfuShuge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified C2S_DongfuShuge message, length delimited. Does not implicitly {@link C2S_DongfuShuge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_DongfuShuge
     * @static
     * @param {IC2S_DongfuShuge} message C2S_DongfuShuge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_DongfuShuge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_DongfuShuge message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_DongfuShuge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_DongfuShuge} C2S_DongfuShuge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_DongfuShuge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_DongfuShuge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_DongfuShuge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_DongfuShuge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_DongfuShuge} C2S_DongfuShuge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_DongfuShuge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_DongfuShuge message.
     * @function verify
     * @memberof C2S_DongfuShuge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_DongfuShuge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
                break;
            }
        return null;
    };

    /**
     * Creates a C2S_DongfuShuge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_DongfuShuge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_DongfuShuge} C2S_DongfuShuge
     */
    C2S_DongfuShuge.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_DongfuShuge)
            return object;
        var message = new $root.C2S_DongfuShuge();
        switch (object.type) {
        case "LianYao":
        case 1:
            message.type = 1;
            break;
        case "LianQi":
        case 2:
            message.type = 2;
            break;
        case "WuXing":
        case 3:
            message.type = 3;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_DongfuShuge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_DongfuShuge
     * @static
     * @param {C2S_DongfuShuge} message C2S_DongfuShuge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_DongfuShuge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "LianYao" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.XiuLianType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this C2S_DongfuShuge to JSON.
     * @function toJSON
     * @memberof C2S_DongfuShuge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_DongfuShuge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_DongfuShuge;
})();

$root.S2C_DongfuShuge = (function() {

    /**
     * Properties of a S2C_DongfuShuge.
     * @exports IS2C_DongfuShuge
     * @interface IS2C_DongfuShuge
     * @property {XiuLianType|null} [type] S2C_DongfuShuge type
     * @property {number|null} [level] S2C_DongfuShuge level
     * @property {number|null} [exp] S2C_DongfuShuge exp
     * @property {number|null} [year] S2C_DongfuShuge year
     * @property {number|Long|null} [endTime] S2C_DongfuShuge endTime
     * @property {number|null} [bookId] S2C_DongfuShuge bookId
     */

    /**
     * Constructs a new S2C_DongfuShuge.
     * @exports S2C_DongfuShuge
     * @classdesc Represents a S2C_DongfuShuge.
     * @implements IS2C_DongfuShuge
     * @constructor
     * @param {IS2C_DongfuShuge=} [properties] Properties to set
     */
    function S2C_DongfuShuge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_DongfuShuge type.
     * @member {XiuLianType} type
     * @memberof S2C_DongfuShuge
     * @instance
     */
    S2C_DongfuShuge.prototype.type = 1;

    /**
     * S2C_DongfuShuge level.
     * @member {number} level
     * @memberof S2C_DongfuShuge
     * @instance
     */
    S2C_DongfuShuge.prototype.level = 0;

    /**
     * S2C_DongfuShuge exp.
     * @member {number} exp
     * @memberof S2C_DongfuShuge
     * @instance
     */
    S2C_DongfuShuge.prototype.exp = 0;

    /**
     * S2C_DongfuShuge year.
     * @member {number} year
     * @memberof S2C_DongfuShuge
     * @instance
     */
    S2C_DongfuShuge.prototype.year = 0;

    /**
     * S2C_DongfuShuge endTime.
     * @member {number|Long} endTime
     * @memberof S2C_DongfuShuge
     * @instance
     */
    S2C_DongfuShuge.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_DongfuShuge bookId.
     * @member {number} bookId
     * @memberof S2C_DongfuShuge
     * @instance
     */
    S2C_DongfuShuge.prototype.bookId = 0;

    /**
     * Creates a new S2C_DongfuShuge instance using the specified properties.
     * @function create
     * @memberof S2C_DongfuShuge
     * @static
     * @param {IS2C_DongfuShuge=} [properties] Properties to set
     * @returns {S2C_DongfuShuge} S2C_DongfuShuge instance
     */
    S2C_DongfuShuge.create = function create(properties) {
        return new S2C_DongfuShuge(properties);
    };

    /**
     * Encodes the specified S2C_DongfuShuge message. Does not implicitly {@link S2C_DongfuShuge.verify|verify} messages.
     * @function encode
     * @memberof S2C_DongfuShuge
     * @static
     * @param {IS2C_DongfuShuge} message S2C_DongfuShuge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_DongfuShuge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
        if (message.exp != null && message.hasOwnProperty("exp"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.exp);
        if (message.year != null && message.hasOwnProperty("year"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.year);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.endTime);
        if (message.bookId != null && message.hasOwnProperty("bookId"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.bookId);
        return writer;
    };

    /**
     * Encodes the specified S2C_DongfuShuge message, length delimited. Does not implicitly {@link S2C_DongfuShuge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_DongfuShuge
     * @static
     * @param {IS2C_DongfuShuge} message S2C_DongfuShuge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_DongfuShuge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_DongfuShuge message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_DongfuShuge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_DongfuShuge} S2C_DongfuShuge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_DongfuShuge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_DongfuShuge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.level = reader.int32();
                break;
            case 3:
                message.exp = reader.int32();
                break;
            case 4:
                message.year = reader.int32();
                break;
            case 5:
                message.endTime = reader.int64();
                break;
            case 6:
                message.bookId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_DongfuShuge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_DongfuShuge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_DongfuShuge} S2C_DongfuShuge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_DongfuShuge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_DongfuShuge message.
     * @function verify
     * @memberof S2C_DongfuShuge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_DongfuShuge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
                break;
            }
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.exp != null && message.hasOwnProperty("exp"))
            if (!$util.isInteger(message.exp))
                return "exp: integer expected";
        if (message.year != null && message.hasOwnProperty("year"))
            if (!$util.isInteger(message.year))
                return "year: integer expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                return "endTime: integer|Long expected";
        if (message.bookId != null && message.hasOwnProperty("bookId"))
            if (!$util.isInteger(message.bookId))
                return "bookId: integer expected";
        return null;
    };

    /**
     * Creates a S2C_DongfuShuge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_DongfuShuge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_DongfuShuge} S2C_DongfuShuge
     */
    S2C_DongfuShuge.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_DongfuShuge)
            return object;
        var message = new $root.S2C_DongfuShuge();
        switch (object.type) {
        case "LianYao":
        case 1:
            message.type = 1;
            break;
        case "LianQi":
        case 2:
            message.type = 2;
            break;
        case "WuXing":
        case 3:
            message.type = 3;
            break;
        }
        if (object.level != null)
            message.level = object.level | 0;
        if (object.exp != null)
            message.exp = object.exp | 0;
        if (object.year != null)
            message.year = object.year | 0;
        if (object.endTime != null)
            if ($util.Long)
                (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
            else if (typeof object.endTime === "string")
                message.endTime = parseInt(object.endTime, 10);
            else if (typeof object.endTime === "number")
                message.endTime = object.endTime;
            else if (typeof object.endTime === "object")
                message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
        if (object.bookId != null)
            message.bookId = object.bookId | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_DongfuShuge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_DongfuShuge
     * @static
     * @param {S2C_DongfuShuge} message S2C_DongfuShuge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_DongfuShuge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "LianYao" : 1;
            object.level = 0;
            object.exp = 0;
            object.year = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.endTime = options.longs === String ? "0" : 0;
            object.bookId = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.XiuLianType[message.type] : message.type;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.exp != null && message.hasOwnProperty("exp"))
            object.exp = message.exp;
        if (message.year != null && message.hasOwnProperty("year"))
            object.year = message.year;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
                object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
                object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
        if (message.bookId != null && message.hasOwnProperty("bookId"))
            object.bookId = message.bookId;
        return object;
    };

    /**
     * Converts this S2C_DongfuShuge to JSON.
     * @function toJSON
     * @memberof S2C_DongfuShuge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_DongfuShuge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_DongfuShuge;
})();

$root.C2S_StopMake = (function() {

    /**
     * Properties of a C2S_StopMake.
     * @exports IC2S_StopMake
     * @interface IC2S_StopMake
     * @property {BuildType|null} [type] C2S_StopMake type
     */

    /**
     * Constructs a new C2S_StopMake.
     * @exports C2S_StopMake
     * @classdesc Represents a C2S_StopMake.
     * @implements IC2S_StopMake
     * @constructor
     * @param {IC2S_StopMake=} [properties] Properties to set
     */
    function C2S_StopMake(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_StopMake type.
     * @member {BuildType} type
     * @memberof C2S_StopMake
     * @instance
     */
    C2S_StopMake.prototype.type = 1;

    /**
     * Creates a new C2S_StopMake instance using the specified properties.
     * @function create
     * @memberof C2S_StopMake
     * @static
     * @param {IC2S_StopMake=} [properties] Properties to set
     * @returns {C2S_StopMake} C2S_StopMake instance
     */
    C2S_StopMake.create = function create(properties) {
        return new C2S_StopMake(properties);
    };

    /**
     * Encodes the specified C2S_StopMake message. Does not implicitly {@link C2S_StopMake.verify|verify} messages.
     * @function encode
     * @memberof C2S_StopMake
     * @static
     * @param {IC2S_StopMake} message C2S_StopMake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_StopMake.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified C2S_StopMake message, length delimited. Does not implicitly {@link C2S_StopMake.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_StopMake
     * @static
     * @param {IC2S_StopMake} message C2S_StopMake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_StopMake.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_StopMake message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_StopMake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_StopMake} C2S_StopMake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_StopMake.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_StopMake();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_StopMake message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_StopMake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_StopMake} C2S_StopMake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_StopMake.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_StopMake message.
     * @function verify
     * @memberof C2S_StopMake
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_StopMake.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        return null;
    };

    /**
     * Creates a C2S_StopMake message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_StopMake
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_StopMake} C2S_StopMake
     */
    C2S_StopMake.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_StopMake)
            return object;
        var message = new $root.C2S_StopMake();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_StopMake message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_StopMake
     * @static
     * @param {C2S_StopMake} message C2S_StopMake
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_StopMake.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "ShuGe" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this C2S_StopMake to JSON.
     * @function toJSON
     * @memberof C2S_StopMake
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_StopMake.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_StopMake;
})();

$root.S2C_StopMake = (function() {

    /**
     * Properties of a S2C_StopMake.
     * @exports IS2C_StopMake
     * @interface IS2C_StopMake
     * @property {BuildType|null} [type] S2C_StopMake type
     */

    /**
     * Constructs a new S2C_StopMake.
     * @exports S2C_StopMake
     * @classdesc Represents a S2C_StopMake.
     * @implements IS2C_StopMake
     * @constructor
     * @param {IS2C_StopMake=} [properties] Properties to set
     */
    function S2C_StopMake(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_StopMake type.
     * @member {BuildType} type
     * @memberof S2C_StopMake
     * @instance
     */
    S2C_StopMake.prototype.type = 1;

    /**
     * Creates a new S2C_StopMake instance using the specified properties.
     * @function create
     * @memberof S2C_StopMake
     * @static
     * @param {IS2C_StopMake=} [properties] Properties to set
     * @returns {S2C_StopMake} S2C_StopMake instance
     */
    S2C_StopMake.create = function create(properties) {
        return new S2C_StopMake(properties);
    };

    /**
     * Encodes the specified S2C_StopMake message. Does not implicitly {@link S2C_StopMake.verify|verify} messages.
     * @function encode
     * @memberof S2C_StopMake
     * @static
     * @param {IS2C_StopMake} message S2C_StopMake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_StopMake.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified S2C_StopMake message, length delimited. Does not implicitly {@link S2C_StopMake.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_StopMake
     * @static
     * @param {IS2C_StopMake} message S2C_StopMake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_StopMake.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_StopMake message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_StopMake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_StopMake} S2C_StopMake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_StopMake.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_StopMake();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_StopMake message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_StopMake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_StopMake} S2C_StopMake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_StopMake.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_StopMake message.
     * @function verify
     * @memberof S2C_StopMake
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_StopMake.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        return null;
    };

    /**
     * Creates a S2C_StopMake message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_StopMake
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_StopMake} S2C_StopMake
     */
    S2C_StopMake.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_StopMake)
            return object;
        var message = new $root.S2C_StopMake();
        switch (object.type) {
        case "ShuGe":
        case 1:
            message.type = 1;
            break;
        case "DanFang":
        case 2:
            message.type = 2;
            break;
        case "QiShi":
        case 3:
            message.type = 3;
            break;
        case "YaoGu":
        case 4:
            message.type = 4;
            break;
        case "XianNiang":
        case 5:
            message.type = 5;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_StopMake message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_StopMake
     * @static
     * @param {S2C_StopMake} message S2C_StopMake
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_StopMake.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "ShuGe" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.BuildType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this S2C_StopMake to JSON.
     * @function toJSON
     * @memberof S2C_StopMake
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_StopMake.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_StopMake;
})();

$root.WudaoBook = (function() {

    /**
     * Properties of a WudaoBook.
     * @exports IWudaoBook
     * @interface IWudaoBook
     * @property {number|null} [id] WudaoBook id
     * @property {number|null} [level] WudaoBook level
     * @property {number|null} [readNum] WudaoBook readNum
     * @property {number|Long|null} [endTime] WudaoBook endTime
     */

    /**
     * Constructs a new WudaoBook.
     * @exports WudaoBook
     * @classdesc Represents a WudaoBook.
     * @implements IWudaoBook
     * @constructor
     * @param {IWudaoBook=} [properties] Properties to set
     */
    function WudaoBook(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WudaoBook id.
     * @member {number} id
     * @memberof WudaoBook
     * @instance
     */
    WudaoBook.prototype.id = 0;

    /**
     * WudaoBook level.
     * @member {number} level
     * @memberof WudaoBook
     * @instance
     */
    WudaoBook.prototype.level = 0;

    /**
     * WudaoBook readNum.
     * @member {number} readNum
     * @memberof WudaoBook
     * @instance
     */
    WudaoBook.prototype.readNum = 0;

    /**
     * WudaoBook endTime.
     * @member {number|Long} endTime
     * @memberof WudaoBook
     * @instance
     */
    WudaoBook.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new WudaoBook instance using the specified properties.
     * @function create
     * @memberof WudaoBook
     * @static
     * @param {IWudaoBook=} [properties] Properties to set
     * @returns {WudaoBook} WudaoBook instance
     */
    WudaoBook.create = function create(properties) {
        return new WudaoBook(properties);
    };

    /**
     * Encodes the specified WudaoBook message. Does not implicitly {@link WudaoBook.verify|verify} messages.
     * @function encode
     * @memberof WudaoBook
     * @static
     * @param {IWudaoBook} message WudaoBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WudaoBook.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
        if (message.readNum != null && message.hasOwnProperty("readNum"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.readNum);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.endTime);
        return writer;
    };

    /**
     * Encodes the specified WudaoBook message, length delimited. Does not implicitly {@link WudaoBook.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WudaoBook
     * @static
     * @param {IWudaoBook} message WudaoBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WudaoBook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WudaoBook message from the specified reader or buffer.
     * @function decode
     * @memberof WudaoBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WudaoBook} WudaoBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WudaoBook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WudaoBook();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.level = reader.int32();
                break;
            case 3:
                message.readNum = reader.int32();
                break;
            case 4:
                message.endTime = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WudaoBook message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WudaoBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WudaoBook} WudaoBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WudaoBook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WudaoBook message.
     * @function verify
     * @memberof WudaoBook
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WudaoBook.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.readNum != null && message.hasOwnProperty("readNum"))
            if (!$util.isInteger(message.readNum))
                return "readNum: integer expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                return "endTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a WudaoBook message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WudaoBook
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WudaoBook} WudaoBook
     */
    WudaoBook.fromObject = function fromObject(object) {
        if (object instanceof $root.WudaoBook)
            return object;
        var message = new $root.WudaoBook();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.level != null)
            message.level = object.level | 0;
        if (object.readNum != null)
            message.readNum = object.readNum | 0;
        if (object.endTime != null)
            if ($util.Long)
                (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
            else if (typeof object.endTime === "string")
                message.endTime = parseInt(object.endTime, 10);
            else if (typeof object.endTime === "number")
                message.endTime = object.endTime;
            else if (typeof object.endTime === "object")
                message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a WudaoBook message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WudaoBook
     * @static
     * @param {WudaoBook} message WudaoBook
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WudaoBook.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            object.level = 0;
            object.readNum = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.endTime = options.longs === String ? "0" : 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.readNum != null && message.hasOwnProperty("readNum"))
            object.readNum = message.readNum;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
                object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
                object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
        return object;
    };

    /**
     * Converts this WudaoBook to JSON.
     * @function toJSON
     * @memberof WudaoBook
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WudaoBook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WudaoBook;
})();

$root.C2S_AllBook = (function() {

    /**
     * Properties of a C2S_AllBook.
     * @exports IC2S_AllBook
     * @interface IC2S_AllBook
     */

    /**
     * Constructs a new C2S_AllBook.
     * @exports C2S_AllBook
     * @classdesc Represents a C2S_AllBook.
     * @implements IC2S_AllBook
     * @constructor
     * @param {IC2S_AllBook=} [properties] Properties to set
     */
    function C2S_AllBook(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_AllBook instance using the specified properties.
     * @function create
     * @memberof C2S_AllBook
     * @static
     * @param {IC2S_AllBook=} [properties] Properties to set
     * @returns {C2S_AllBook} C2S_AllBook instance
     */
    C2S_AllBook.create = function create(properties) {
        return new C2S_AllBook(properties);
    };

    /**
     * Encodes the specified C2S_AllBook message. Does not implicitly {@link C2S_AllBook.verify|verify} messages.
     * @function encode
     * @memberof C2S_AllBook
     * @static
     * @param {IC2S_AllBook} message C2S_AllBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_AllBook.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_AllBook message, length delimited. Does not implicitly {@link C2S_AllBook.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_AllBook
     * @static
     * @param {IC2S_AllBook} message C2S_AllBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_AllBook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_AllBook message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_AllBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_AllBook} C2S_AllBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_AllBook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_AllBook();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_AllBook message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_AllBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_AllBook} C2S_AllBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_AllBook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_AllBook message.
     * @function verify
     * @memberof C2S_AllBook
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_AllBook.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_AllBook message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_AllBook
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_AllBook} C2S_AllBook
     */
    C2S_AllBook.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_AllBook)
            return object;
        return new $root.C2S_AllBook();
    };

    /**
     * Creates a plain object from a C2S_AllBook message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_AllBook
     * @static
     * @param {C2S_AllBook} message C2S_AllBook
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_AllBook.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_AllBook to JSON.
     * @function toJSON
     * @memberof C2S_AllBook
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_AllBook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_AllBook;
})();

$root.S2C_AllBook = (function() {

    /**
     * Properties of a S2C_AllBook.
     * @exports IS2C_AllBook
     * @interface IS2C_AllBook
     * @property {Array.<IWudaoBook>|null} [book] S2C_AllBook book
     */

    /**
     * Constructs a new S2C_AllBook.
     * @exports S2C_AllBook
     * @classdesc Represents a S2C_AllBook.
     * @implements IS2C_AllBook
     * @constructor
     * @param {IS2C_AllBook=} [properties] Properties to set
     */
    function S2C_AllBook(properties) {
        this.book = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_AllBook book.
     * @member {Array.<IWudaoBook>} book
     * @memberof S2C_AllBook
     * @instance
     */
    S2C_AllBook.prototype.book = $util.emptyArray;

    /**
     * Creates a new S2C_AllBook instance using the specified properties.
     * @function create
     * @memberof S2C_AllBook
     * @static
     * @param {IS2C_AllBook=} [properties] Properties to set
     * @returns {S2C_AllBook} S2C_AllBook instance
     */
    S2C_AllBook.create = function create(properties) {
        return new S2C_AllBook(properties);
    };

    /**
     * Encodes the specified S2C_AllBook message. Does not implicitly {@link S2C_AllBook.verify|verify} messages.
     * @function encode
     * @memberof S2C_AllBook
     * @static
     * @param {IS2C_AllBook} message S2C_AllBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_AllBook.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.book != null && message.book.length)
            for (var i = 0; i < message.book.length; ++i)
                $root.WudaoBook.encode(message.book[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_AllBook message, length delimited. Does not implicitly {@link S2C_AllBook.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_AllBook
     * @static
     * @param {IS2C_AllBook} message S2C_AllBook message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_AllBook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_AllBook message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_AllBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_AllBook} S2C_AllBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_AllBook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_AllBook();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.book && message.book.length))
                    message.book = [];
                message.book.push($root.WudaoBook.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_AllBook message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_AllBook
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_AllBook} S2C_AllBook
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_AllBook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_AllBook message.
     * @function verify
     * @memberof S2C_AllBook
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_AllBook.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.book != null && message.hasOwnProperty("book")) {
            if (!Array.isArray(message.book))
                return "book: array expected";
            for (var i = 0; i < message.book.length; ++i) {
                var error = $root.WudaoBook.verify(message.book[i]);
                if (error)
                    return "book." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_AllBook message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_AllBook
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_AllBook} S2C_AllBook
     */
    S2C_AllBook.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_AllBook)
            return object;
        var message = new $root.S2C_AllBook();
        if (object.book) {
            if (!Array.isArray(object.book))
                throw TypeError(".S2C_AllBook.book: array expected");
            message.book = [];
            for (var i = 0; i < object.book.length; ++i) {
                if (typeof object.book[i] !== "object")
                    throw TypeError(".S2C_AllBook.book: object expected");
                message.book[i] = $root.WudaoBook.fromObject(object.book[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_AllBook message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_AllBook
     * @static
     * @param {S2C_AllBook} message S2C_AllBook
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_AllBook.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.book = [];
        if (message.book && message.book.length) {
            object.book = [];
            for (var j = 0; j < message.book.length; ++j)
                object.book[j] = $root.WudaoBook.toObject(message.book[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_AllBook to JSON.
     * @function toJSON
     * @memberof S2C_AllBook
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_AllBook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_AllBook;
})();

$root.C2S_Booking = (function() {

    /**
     * Properties of a C2S_Booking.
     * @exports IC2S_Booking
     * @interface IC2S_Booking
     * @property {number|null} [id] C2S_Booking id
     */

    /**
     * Constructs a new C2S_Booking.
     * @exports C2S_Booking
     * @classdesc Represents a C2S_Booking.
     * @implements IC2S_Booking
     * @constructor
     * @param {IC2S_Booking=} [properties] Properties to set
     */
    function C2S_Booking(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_Booking id.
     * @member {number} id
     * @memberof C2S_Booking
     * @instance
     */
    C2S_Booking.prototype.id = 0;

    /**
     * Creates a new C2S_Booking instance using the specified properties.
     * @function create
     * @memberof C2S_Booking
     * @static
     * @param {IC2S_Booking=} [properties] Properties to set
     * @returns {C2S_Booking} C2S_Booking instance
     */
    C2S_Booking.create = function create(properties) {
        return new C2S_Booking(properties);
    };

    /**
     * Encodes the specified C2S_Booking message. Does not implicitly {@link C2S_Booking.verify|verify} messages.
     * @function encode
     * @memberof C2S_Booking
     * @static
     * @param {IC2S_Booking} message C2S_Booking message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Booking.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_Booking message, length delimited. Does not implicitly {@link C2S_Booking.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Booking
     * @static
     * @param {IC2S_Booking} message C2S_Booking message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Booking.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Booking message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Booking
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Booking} C2S_Booking
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Booking.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Booking();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Booking message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Booking
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Booking} C2S_Booking
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Booking.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Booking message.
     * @function verify
     * @memberof C2S_Booking
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Booking.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_Booking message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Booking
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Booking} C2S_Booking
     */
    C2S_Booking.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Booking)
            return object;
        var message = new $root.C2S_Booking();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_Booking message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Booking
     * @static
     * @param {C2S_Booking} message C2S_Booking
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Booking.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_Booking to JSON.
     * @function toJSON
     * @memberof C2S_Booking
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Booking.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Booking;
})();

$root.S2C_Booking = (function() {

    /**
     * Properties of a S2C_Booking.
     * @exports IS2C_Booking
     * @interface IS2C_Booking
     * @property {number|null} [id] S2C_Booking id
     */

    /**
     * Constructs a new S2C_Booking.
     * @exports S2C_Booking
     * @classdesc Represents a S2C_Booking.
     * @implements IS2C_Booking
     * @constructor
     * @param {IS2C_Booking=} [properties] Properties to set
     */
    function S2C_Booking(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Booking id.
     * @member {number} id
     * @memberof S2C_Booking
     * @instance
     */
    S2C_Booking.prototype.id = 0;

    /**
     * Creates a new S2C_Booking instance using the specified properties.
     * @function create
     * @memberof S2C_Booking
     * @static
     * @param {IS2C_Booking=} [properties] Properties to set
     * @returns {S2C_Booking} S2C_Booking instance
     */
    S2C_Booking.create = function create(properties) {
        return new S2C_Booking(properties);
    };

    /**
     * Encodes the specified S2C_Booking message. Does not implicitly {@link S2C_Booking.verify|verify} messages.
     * @function encode
     * @memberof S2C_Booking
     * @static
     * @param {IS2C_Booking} message S2C_Booking message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Booking.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified S2C_Booking message, length delimited. Does not implicitly {@link S2C_Booking.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Booking
     * @static
     * @param {IS2C_Booking} message S2C_Booking message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Booking.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Booking message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Booking
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Booking} S2C_Booking
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Booking.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Booking();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Booking message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Booking
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Booking} S2C_Booking
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Booking.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Booking message.
     * @function verify
     * @memberof S2C_Booking
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Booking.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a S2C_Booking message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Booking
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Booking} S2C_Booking
     */
    S2C_Booking.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Booking)
            return object;
        var message = new $root.S2C_Booking();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_Booking message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Booking
     * @static
     * @param {S2C_Booking} message S2C_Booking
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Booking.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this S2C_Booking to JSON.
     * @function toJSON
     * @memberof S2C_Booking
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Booking.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Booking;
})();

/**
 * FengYinBossType enum.
 * @exports FengYinBossType
 * @enum {string}
 * @property {number} QiLin=1 QiLin value
 * @property {number} JuKun=3 JuKun value
 * @property {number} SuanNi=2 SuanNi value
 * @property {number} XuanWU=4 XuanWU value
 * @property {number} GuLong=5 GuLong value
 */
$root.FengYinBossType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "QiLin"] = 1;
    values[valuesById[3] = "JuKun"] = 3;
    values[valuesById[2] = "SuanNi"] = 2;
    values[valuesById[4] = "XuanWU"] = 4;
    values[valuesById[5] = "GuLong"] = 5;
    return values;
})();

/**
 * FengYinStateType enum.
 * @exports FengYinStateType
 * @enum {string}
 * @property {number} Ordering=1 Ordering value
 * @property {number} Fighting=2 Fighting value
 * @property {number} GameOver=3 GameOver value
 */
$root.FengYinStateType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "Ordering"] = 1;
    values[valuesById[2] = "Fighting"] = 2;
    values[valuesById[3] = "GameOver"] = 3;
    return values;
})();

/**
 * FengYinCmdType enum.
 * @exports FengYinCmdType
 * @enum {string}
 * @property {number} GetFengYinBoss_Cmd=1 GetFengYinBoss_Cmd value
 * @property {number} OrderFengYinBoss_Cmd=2 OrderFengYinBoss_Cmd value
 */
$root.FengYinCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "GetFengYinBoss_Cmd"] = 1;
    values[valuesById[2] = "OrderFengYinBoss_Cmd"] = 2;
    return values;
})();

$root.C2S_FengYinBoss = (function() {

    /**
     * Properties of a C2S_FengYinBoss.
     * @exports IC2S_FengYinBoss
     * @interface IC2S_FengYinBoss
     * @property {FengYinCmdType} cmdType C2S_FengYinBoss cmdType
     */

    /**
     * Constructs a new C2S_FengYinBoss.
     * @exports C2S_FengYinBoss
     * @classdesc Represents a C2S_FengYinBoss.
     * @implements IC2S_FengYinBoss
     * @constructor
     * @param {IC2S_FengYinBoss=} [properties] Properties to set
     */
    function C2S_FengYinBoss(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_FengYinBoss cmdType.
     * @member {FengYinCmdType} cmdType
     * @memberof C2S_FengYinBoss
     * @instance
     */
    C2S_FengYinBoss.prototype.cmdType = 1;

    /**
     * Creates a new C2S_FengYinBoss instance using the specified properties.
     * @function create
     * @memberof C2S_FengYinBoss
     * @static
     * @param {IC2S_FengYinBoss=} [properties] Properties to set
     * @returns {C2S_FengYinBoss} C2S_FengYinBoss instance
     */
    C2S_FengYinBoss.create = function create(properties) {
        return new C2S_FengYinBoss(properties);
    };

    /**
     * Encodes the specified C2S_FengYinBoss message. Does not implicitly {@link C2S_FengYinBoss.verify|verify} messages.
     * @function encode
     * @memberof C2S_FengYinBoss
     * @static
     * @param {IC2S_FengYinBoss} message C2S_FengYinBoss message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_FengYinBoss.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        return writer;
    };

    /**
     * Encodes the specified C2S_FengYinBoss message, length delimited. Does not implicitly {@link C2S_FengYinBoss.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_FengYinBoss
     * @static
     * @param {IC2S_FengYinBoss} message C2S_FengYinBoss message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_FengYinBoss.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_FengYinBoss message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_FengYinBoss
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_FengYinBoss} C2S_FengYinBoss
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_FengYinBoss.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_FengYinBoss();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_FengYinBoss message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_FengYinBoss
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_FengYinBoss} C2S_FengYinBoss
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_FengYinBoss.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_FengYinBoss message.
     * @function verify
     * @memberof C2S_FengYinBoss
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_FengYinBoss.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
            break;
        }
        return null;
    };

    /**
     * Creates a C2S_FengYinBoss message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_FengYinBoss
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_FengYinBoss} C2S_FengYinBoss
     */
    C2S_FengYinBoss.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_FengYinBoss)
            return object;
        var message = new $root.C2S_FengYinBoss();
        switch (object.cmdType) {
        case "GetFengYinBoss_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "OrderFengYinBoss_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_FengYinBoss message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_FengYinBoss
     * @static
     * @param {C2S_FengYinBoss} message C2S_FengYinBoss
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_FengYinBoss.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.cmdType = options.enums === String ? "GetFengYinBoss_Cmd" : 1;
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.FengYinCmdType[message.cmdType] : message.cmdType;
        return object;
    };

    /**
     * Converts this C2S_FengYinBoss to JSON.
     * @function toJSON
     * @memberof C2S_FengYinBoss
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_FengYinBoss.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_FengYinBoss;
})();

$root.S2C_FengYinBoss = (function() {

    /**
     * Properties of a S2C_FengYinBoss.
     * @exports IS2C_FengYinBoss
     * @interface IS2C_FengYinBoss
     * @property {FengYinCmdType} cmdType S2C_FengYinBoss cmdType
     * @property {number|null} [bossID] S2C_FengYinBoss bossID
     * @property {boolean|null} [isOrder] S2C_FengYinBoss isOrder
     * @property {number|null} [fengYinState] S2C_FengYinBoss fengYinState
     * @property {IFightingBossInfoPB|null} [fightingBossInfo] S2C_FengYinBoss fightingBossInfo
     */

    /**
     * Constructs a new S2C_FengYinBoss.
     * @exports S2C_FengYinBoss
     * @classdesc Represents a S2C_FengYinBoss.
     * @implements IS2C_FengYinBoss
     * @constructor
     * @param {IS2C_FengYinBoss=} [properties] Properties to set
     */
    function S2C_FengYinBoss(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_FengYinBoss cmdType.
     * @member {FengYinCmdType} cmdType
     * @memberof S2C_FengYinBoss
     * @instance
     */
    S2C_FengYinBoss.prototype.cmdType = 1;

    /**
     * S2C_FengYinBoss bossID.
     * @member {number} bossID
     * @memberof S2C_FengYinBoss
     * @instance
     */
    S2C_FengYinBoss.prototype.bossID = 0;

    /**
     * S2C_FengYinBoss isOrder.
     * @member {boolean} isOrder
     * @memberof S2C_FengYinBoss
     * @instance
     */
    S2C_FengYinBoss.prototype.isOrder = false;

    /**
     * S2C_FengYinBoss fengYinState.
     * @member {number} fengYinState
     * @memberof S2C_FengYinBoss
     * @instance
     */
    S2C_FengYinBoss.prototype.fengYinState = 0;

    /**
     * S2C_FengYinBoss fightingBossInfo.
     * @member {IFightingBossInfoPB|null|undefined} fightingBossInfo
     * @memberof S2C_FengYinBoss
     * @instance
     */
    S2C_FengYinBoss.prototype.fightingBossInfo = null;

    /**
     * Creates a new S2C_FengYinBoss instance using the specified properties.
     * @function create
     * @memberof S2C_FengYinBoss
     * @static
     * @param {IS2C_FengYinBoss=} [properties] Properties to set
     * @returns {S2C_FengYinBoss} S2C_FengYinBoss instance
     */
    S2C_FengYinBoss.create = function create(properties) {
        return new S2C_FengYinBoss(properties);
    };

    /**
     * Encodes the specified S2C_FengYinBoss message. Does not implicitly {@link S2C_FengYinBoss.verify|verify} messages.
     * @function encode
     * @memberof S2C_FengYinBoss
     * @static
     * @param {IS2C_FengYinBoss} message S2C_FengYinBoss message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_FengYinBoss.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.bossID != null && message.hasOwnProperty("bossID"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bossID);
        if (message.isOrder != null && message.hasOwnProperty("isOrder"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOrder);
        if (message.fengYinState != null && message.hasOwnProperty("fengYinState"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fengYinState);
        if (message.fightingBossInfo != null && message.hasOwnProperty("fightingBossInfo"))
            $root.FightingBossInfoPB.encode(message.fightingBossInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_FengYinBoss message, length delimited. Does not implicitly {@link S2C_FengYinBoss.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_FengYinBoss
     * @static
     * @param {IS2C_FengYinBoss} message S2C_FengYinBoss message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_FengYinBoss.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_FengYinBoss message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_FengYinBoss
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_FengYinBoss} S2C_FengYinBoss
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_FengYinBoss.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_FengYinBoss();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                message.bossID = reader.int32();
                break;
            case 3:
                message.isOrder = reader.bool();
                break;
            case 4:
                message.fengYinState = reader.int32();
                break;
            case 5:
                message.fightingBossInfo = $root.FightingBossInfoPB.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_FengYinBoss message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_FengYinBoss
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_FengYinBoss} S2C_FengYinBoss
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_FengYinBoss.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_FengYinBoss message.
     * @function verify
     * @memberof S2C_FengYinBoss
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_FengYinBoss.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
            break;
        }
        if (message.bossID != null && message.hasOwnProperty("bossID"))
            if (!$util.isInteger(message.bossID))
                return "bossID: integer expected";
        if (message.isOrder != null && message.hasOwnProperty("isOrder"))
            if (typeof message.isOrder !== "boolean")
                return "isOrder: boolean expected";
        if (message.fengYinState != null && message.hasOwnProperty("fengYinState"))
            if (!$util.isInteger(message.fengYinState))
                return "fengYinState: integer expected";
        if (message.fightingBossInfo != null && message.hasOwnProperty("fightingBossInfo")) {
            var error = $root.FightingBossInfoPB.verify(message.fightingBossInfo);
            if (error)
                return "fightingBossInfo." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_FengYinBoss message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_FengYinBoss
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_FengYinBoss} S2C_FengYinBoss
     */
    S2C_FengYinBoss.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_FengYinBoss)
            return object;
        var message = new $root.S2C_FengYinBoss();
        switch (object.cmdType) {
        case "GetFengYinBoss_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "OrderFengYinBoss_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        }
        if (object.bossID != null)
            message.bossID = object.bossID | 0;
        if (object.isOrder != null)
            message.isOrder = Boolean(object.isOrder);
        if (object.fengYinState != null)
            message.fengYinState = object.fengYinState | 0;
        if (object.fightingBossInfo != null) {
            if (typeof object.fightingBossInfo !== "object")
                throw TypeError(".S2C_FengYinBoss.fightingBossInfo: object expected");
            message.fightingBossInfo = $root.FightingBossInfoPB.fromObject(object.fightingBossInfo);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_FengYinBoss message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_FengYinBoss
     * @static
     * @param {S2C_FengYinBoss} message S2C_FengYinBoss
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_FengYinBoss.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmdType = options.enums === String ? "GetFengYinBoss_Cmd" : 1;
            object.bossID = 0;
            object.isOrder = false;
            object.fengYinState = 0;
            object.fightingBossInfo = null;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.FengYinCmdType[message.cmdType] : message.cmdType;
        if (message.bossID != null && message.hasOwnProperty("bossID"))
            object.bossID = message.bossID;
        if (message.isOrder != null && message.hasOwnProperty("isOrder"))
            object.isOrder = message.isOrder;
        if (message.fengYinState != null && message.hasOwnProperty("fengYinState"))
            object.fengYinState = message.fengYinState;
        if (message.fightingBossInfo != null && message.hasOwnProperty("fightingBossInfo"))
            object.fightingBossInfo = $root.FightingBossInfoPB.toObject(message.fightingBossInfo, options);
        return object;
    };

    /**
     * Converts this S2C_FengYinBoss to JSON.
     * @function toJSON
     * @memberof S2C_FengYinBoss
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_FengYinBoss.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_FengYinBoss;
})();

$root.FightingBossInfoPB = (function() {

    /**
     * Properties of a FightingBossInfoPB.
     * @exports IFightingBossInfoPB
     * @interface IFightingBossInfoPB
     * @property {number} curBloodVolume FightingBossInfoPB curBloodVolume
     * @property {number} averagePlayerLevel FightingBossInfoPB averagePlayerLevel
     * @property {number} totalOrder FightingBossInfoPB totalOrder
     * @property {Array.<IPlayerOrderInfoPB>|null} [orderInfos] FightingBossInfoPB orderInfos
     */

    /**
     * Constructs a new FightingBossInfoPB.
     * @exports FightingBossInfoPB
     * @classdesc Represents a FightingBossInfoPB.
     * @implements IFightingBossInfoPB
     * @constructor
     * @param {IFightingBossInfoPB=} [properties] Properties to set
     */
    function FightingBossInfoPB(properties) {
        this.orderInfos = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FightingBossInfoPB curBloodVolume.
     * @member {number} curBloodVolume
     * @memberof FightingBossInfoPB
     * @instance
     */
    FightingBossInfoPB.prototype.curBloodVolume = 0;

    /**
     * FightingBossInfoPB averagePlayerLevel.
     * @member {number} averagePlayerLevel
     * @memberof FightingBossInfoPB
     * @instance
     */
    FightingBossInfoPB.prototype.averagePlayerLevel = 0;

    /**
     * FightingBossInfoPB totalOrder.
     * @member {number} totalOrder
     * @memberof FightingBossInfoPB
     * @instance
     */
    FightingBossInfoPB.prototype.totalOrder = 0;

    /**
     * FightingBossInfoPB orderInfos.
     * @member {Array.<IPlayerOrderInfoPB>} orderInfos
     * @memberof FightingBossInfoPB
     * @instance
     */
    FightingBossInfoPB.prototype.orderInfos = $util.emptyArray;

    /**
     * Creates a new FightingBossInfoPB instance using the specified properties.
     * @function create
     * @memberof FightingBossInfoPB
     * @static
     * @param {IFightingBossInfoPB=} [properties] Properties to set
     * @returns {FightingBossInfoPB} FightingBossInfoPB instance
     */
    FightingBossInfoPB.create = function create(properties) {
        return new FightingBossInfoPB(properties);
    };

    /**
     * Encodes the specified FightingBossInfoPB message. Does not implicitly {@link FightingBossInfoPB.verify|verify} messages.
     * @function encode
     * @memberof FightingBossInfoPB
     * @static
     * @param {IFightingBossInfoPB} message FightingBossInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightingBossInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.curBloodVolume);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.averagePlayerLevel);
        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.totalOrder);
        if (message.orderInfos != null && message.orderInfos.length)
            for (var i = 0; i < message.orderInfos.length; ++i)
                $root.PlayerOrderInfoPB.encode(message.orderInfos[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified FightingBossInfoPB message, length delimited. Does not implicitly {@link FightingBossInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FightingBossInfoPB
     * @static
     * @param {IFightingBossInfoPB} message FightingBossInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightingBossInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FightingBossInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof FightingBossInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FightingBossInfoPB} FightingBossInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightingBossInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FightingBossInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.curBloodVolume = reader.int32();
                break;
            case 2:
                message.averagePlayerLevel = reader.int32();
                break;
            case 3:
                message.totalOrder = reader.int32();
                break;
            case 4:
                if (!(message.orderInfos && message.orderInfos.length))
                    message.orderInfos = [];
                message.orderInfos.push($root.PlayerOrderInfoPB.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("curBloodVolume"))
            throw $util.ProtocolError("missing required 'curBloodVolume'", { instance: message });
        if (!message.hasOwnProperty("averagePlayerLevel"))
            throw $util.ProtocolError("missing required 'averagePlayerLevel'", { instance: message });
        if (!message.hasOwnProperty("totalOrder"))
            throw $util.ProtocolError("missing required 'totalOrder'", { instance: message });
        return message;
    };

    /**
     * Decodes a FightingBossInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FightingBossInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FightingBossInfoPB} FightingBossInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightingBossInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FightingBossInfoPB message.
     * @function verify
     * @memberof FightingBossInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FightingBossInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.curBloodVolume))
            return "curBloodVolume: integer expected";
        if (!$util.isInteger(message.averagePlayerLevel))
            return "averagePlayerLevel: integer expected";
        if (!$util.isInteger(message.totalOrder))
            return "totalOrder: integer expected";
        if (message.orderInfos != null && message.hasOwnProperty("orderInfos")) {
            if (!Array.isArray(message.orderInfos))
                return "orderInfos: array expected";
            for (var i = 0; i < message.orderInfos.length; ++i) {
                var error = $root.PlayerOrderInfoPB.verify(message.orderInfos[i]);
                if (error)
                    return "orderInfos." + error;
            }
        }
        return null;
    };

    /**
     * Creates a FightingBossInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FightingBossInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FightingBossInfoPB} FightingBossInfoPB
     */
    FightingBossInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.FightingBossInfoPB)
            return object;
        var message = new $root.FightingBossInfoPB();
        if (object.curBloodVolume != null)
            message.curBloodVolume = object.curBloodVolume | 0;
        if (object.averagePlayerLevel != null)
            message.averagePlayerLevel = object.averagePlayerLevel | 0;
        if (object.totalOrder != null)
            message.totalOrder = object.totalOrder | 0;
        if (object.orderInfos) {
            if (!Array.isArray(object.orderInfos))
                throw TypeError(".FightingBossInfoPB.orderInfos: array expected");
            message.orderInfos = [];
            for (var i = 0; i < object.orderInfos.length; ++i) {
                if (typeof object.orderInfos[i] !== "object")
                    throw TypeError(".FightingBossInfoPB.orderInfos: object expected");
                message.orderInfos[i] = $root.PlayerOrderInfoPB.fromObject(object.orderInfos[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a FightingBossInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FightingBossInfoPB
     * @static
     * @param {FightingBossInfoPB} message FightingBossInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FightingBossInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.orderInfos = [];
        if (options.defaults) {
            object.curBloodVolume = 0;
            object.averagePlayerLevel = 0;
            object.totalOrder = 0;
        }
        if (message.curBloodVolume != null && message.hasOwnProperty("curBloodVolume"))
            object.curBloodVolume = message.curBloodVolume;
        if (message.averagePlayerLevel != null && message.hasOwnProperty("averagePlayerLevel"))
            object.averagePlayerLevel = message.averagePlayerLevel;
        if (message.totalOrder != null && message.hasOwnProperty("totalOrder"))
            object.totalOrder = message.totalOrder;
        if (message.orderInfos && message.orderInfos.length) {
            object.orderInfos = [];
            for (var j = 0; j < message.orderInfos.length; ++j)
                object.orderInfos[j] = $root.PlayerOrderInfoPB.toObject(message.orderInfos[j], options);
        }
        return object;
    };

    /**
     * Converts this FightingBossInfoPB to JSON.
     * @function toJSON
     * @memberof FightingBossInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FightingBossInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FightingBossInfoPB;
})();

$root.PlayerOrderInfoPB = (function() {

    /**
     * Properties of a PlayerOrderInfoPB.
     * @exports IPlayerOrderInfoPB
     * @interface IPlayerOrderInfoPB
     * @property {number|Long} playerID PlayerOrderInfoPB playerID
     * @property {string|null} [nickName] PlayerOrderInfoPB nickName
     * @property {number|Long|null} [registerTime] PlayerOrderInfoPB registerTime
     * @property {number} level PlayerOrderInfoPB level
     * @property {number|null} [output] PlayerOrderInfoPB output
     */

    /**
     * Constructs a new PlayerOrderInfoPB.
     * @exports PlayerOrderInfoPB
     * @classdesc Represents a PlayerOrderInfoPB.
     * @implements IPlayerOrderInfoPB
     * @constructor
     * @param {IPlayerOrderInfoPB=} [properties] Properties to set
     */
    function PlayerOrderInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PlayerOrderInfoPB playerID.
     * @member {number|Long} playerID
     * @memberof PlayerOrderInfoPB
     * @instance
     */
    PlayerOrderInfoPB.prototype.playerID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PlayerOrderInfoPB nickName.
     * @member {string} nickName
     * @memberof PlayerOrderInfoPB
     * @instance
     */
    PlayerOrderInfoPB.prototype.nickName = "";

    /**
     * PlayerOrderInfoPB registerTime.
     * @member {number|Long} registerTime
     * @memberof PlayerOrderInfoPB
     * @instance
     */
    PlayerOrderInfoPB.prototype.registerTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PlayerOrderInfoPB level.
     * @member {number} level
     * @memberof PlayerOrderInfoPB
     * @instance
     */
    PlayerOrderInfoPB.prototype.level = 0;

    /**
     * PlayerOrderInfoPB output.
     * @member {number} output
     * @memberof PlayerOrderInfoPB
     * @instance
     */
    PlayerOrderInfoPB.prototype.output = 0;

    /**
     * Creates a new PlayerOrderInfoPB instance using the specified properties.
     * @function create
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {IPlayerOrderInfoPB=} [properties] Properties to set
     * @returns {PlayerOrderInfoPB} PlayerOrderInfoPB instance
     */
    PlayerOrderInfoPB.create = function create(properties) {
        return new PlayerOrderInfoPB(properties);
    };

    /**
     * Encodes the specified PlayerOrderInfoPB message. Does not implicitly {@link PlayerOrderInfoPB.verify|verify} messages.
     * @function encode
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {IPlayerOrderInfoPB} message PlayerOrderInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlayerOrderInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerID);
        if (message.nickName != null && message.hasOwnProperty("nickName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickName);
        if (message.registerTime != null && message.hasOwnProperty("registerTime"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.registerTime);
        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.level);
        if (message.output != null && message.hasOwnProperty("output"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.output);
        return writer;
    };

    /**
     * Encodes the specified PlayerOrderInfoPB message, length delimited. Does not implicitly {@link PlayerOrderInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {IPlayerOrderInfoPB} message PlayerOrderInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlayerOrderInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PlayerOrderInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerOrderInfoPB} PlayerOrderInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerOrderInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerOrderInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.playerID = reader.int64();
                break;
            case 2:
                message.nickName = reader.string();
                break;
            case 3:
                message.registerTime = reader.int64();
                break;
            case 4:
                message.level = reader.int32();
                break;
            case 5:
                message.output = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("playerID"))
            throw $util.ProtocolError("missing required 'playerID'", { instance: message });
        if (!message.hasOwnProperty("level"))
            throw $util.ProtocolError("missing required 'level'", { instance: message });
        return message;
    };

    /**
     * Decodes a PlayerOrderInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PlayerOrderInfoPB} PlayerOrderInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerOrderInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PlayerOrderInfoPB message.
     * @function verify
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PlayerOrderInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.playerID) && !(message.playerID && $util.isInteger(message.playerID.low) && $util.isInteger(message.playerID.high)))
            return "playerID: integer|Long expected";
        if (message.nickName != null && message.hasOwnProperty("nickName"))
            if (!$util.isString(message.nickName))
                return "nickName: string expected";
        if (message.registerTime != null && message.hasOwnProperty("registerTime"))
            if (!$util.isInteger(message.registerTime) && !(message.registerTime && $util.isInteger(message.registerTime.low) && $util.isInteger(message.registerTime.high)))
                return "registerTime: integer|Long expected";
        if (!$util.isInteger(message.level))
            return "level: integer expected";
        if (message.output != null && message.hasOwnProperty("output"))
            if (!$util.isInteger(message.output))
                return "output: integer expected";
        return null;
    };

    /**
     * Creates a PlayerOrderInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PlayerOrderInfoPB} PlayerOrderInfoPB
     */
    PlayerOrderInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.PlayerOrderInfoPB)
            return object;
        var message = new $root.PlayerOrderInfoPB();
        if (object.playerID != null)
            if ($util.Long)
                (message.playerID = $util.Long.fromValue(object.playerID)).unsigned = false;
            else if (typeof object.playerID === "string")
                message.playerID = parseInt(object.playerID, 10);
            else if (typeof object.playerID === "number")
                message.playerID = object.playerID;
            else if (typeof object.playerID === "object")
                message.playerID = new $util.LongBits(object.playerID.low >>> 0, object.playerID.high >>> 0).toNumber();
        if (object.nickName != null)
            message.nickName = String(object.nickName);
        if (object.registerTime != null)
            if ($util.Long)
                (message.registerTime = $util.Long.fromValue(object.registerTime)).unsigned = false;
            else if (typeof object.registerTime === "string")
                message.registerTime = parseInt(object.registerTime, 10);
            else if (typeof object.registerTime === "number")
                message.registerTime = object.registerTime;
            else if (typeof object.registerTime === "object")
                message.registerTime = new $util.LongBits(object.registerTime.low >>> 0, object.registerTime.high >>> 0).toNumber();
        if (object.level != null)
            message.level = object.level | 0;
        if (object.output != null)
            message.output = object.output | 0;
        return message;
    };

    /**
     * Creates a plain object from a PlayerOrderInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PlayerOrderInfoPB
     * @static
     * @param {PlayerOrderInfoPB} message PlayerOrderInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PlayerOrderInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.playerID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.playerID = options.longs === String ? "0" : 0;
            object.nickName = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.registerTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.registerTime = options.longs === String ? "0" : 0;
            object.level = 0;
            object.output = 0;
        }
        if (message.playerID != null && message.hasOwnProperty("playerID"))
            if (typeof message.playerID === "number")
                object.playerID = options.longs === String ? String(message.playerID) : message.playerID;
            else
                object.playerID = options.longs === String ? $util.Long.prototype.toString.call(message.playerID) : options.longs === Number ? new $util.LongBits(message.playerID.low >>> 0, message.playerID.high >>> 0).toNumber() : message.playerID;
        if (message.nickName != null && message.hasOwnProperty("nickName"))
            object.nickName = message.nickName;
        if (message.registerTime != null && message.hasOwnProperty("registerTime"))
            if (typeof message.registerTime === "number")
                object.registerTime = options.longs === String ? String(message.registerTime) : message.registerTime;
            else
                object.registerTime = options.longs === String ? $util.Long.prototype.toString.call(message.registerTime) : options.longs === Number ? new $util.LongBits(message.registerTime.low >>> 0, message.registerTime.high >>> 0).toNumber() : message.registerTime;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.output != null && message.hasOwnProperty("output"))
            object.output = message.output;
        return object;
    };

    /**
     * Converts this PlayerOrderInfoPB to JSON.
     * @function toJSON
     * @memberof PlayerOrderInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PlayerOrderInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PlayerOrderInfoPB;
})();

$root.FightInitInfo = (function() {

    /**
     * Properties of a FightInitInfo.
     * @exports IFightInitInfo
     * @interface IFightInitInfo
     * @property {number|Long|null} [id] FightInitInfo id
     * @property {number|null} [skill] FightInitInfo skill
     * @property {number|null} [hp] FightInitInfo hp
     */

    /**
     * Constructs a new FightInitInfo.
     * @exports FightInitInfo
     * @classdesc Represents a FightInitInfo.
     * @implements IFightInitInfo
     * @constructor
     * @param {IFightInitInfo=} [properties] Properties to set
     */
    function FightInitInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FightInitInfo id.
     * @member {number|Long} id
     * @memberof FightInitInfo
     * @instance
     */
    FightInitInfo.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * FightInitInfo skill.
     * @member {number} skill
     * @memberof FightInitInfo
     * @instance
     */
    FightInitInfo.prototype.skill = 0;

    /**
     * FightInitInfo hp.
     * @member {number} hp
     * @memberof FightInitInfo
     * @instance
     */
    FightInitInfo.prototype.hp = 0;

    /**
     * Creates a new FightInitInfo instance using the specified properties.
     * @function create
     * @memberof FightInitInfo
     * @static
     * @param {IFightInitInfo=} [properties] Properties to set
     * @returns {FightInitInfo} FightInitInfo instance
     */
    FightInitInfo.create = function create(properties) {
        return new FightInitInfo(properties);
    };

    /**
     * Encodes the specified FightInitInfo message. Does not implicitly {@link FightInitInfo.verify|verify} messages.
     * @function encode
     * @memberof FightInitInfo
     * @static
     * @param {IFightInitInfo} message FightInitInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightInitInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
        if (message.skill != null && message.hasOwnProperty("skill"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.skill);
        if (message.hp != null && message.hasOwnProperty("hp"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.hp);
        return writer;
    };

    /**
     * Encodes the specified FightInitInfo message, length delimited. Does not implicitly {@link FightInitInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FightInitInfo
     * @static
     * @param {IFightInitInfo} message FightInitInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightInitInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FightInitInfo message from the specified reader or buffer.
     * @function decode
     * @memberof FightInitInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FightInitInfo} FightInitInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightInitInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FightInitInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int64();
                break;
            case 2:
                message.skill = reader.int32();
                break;
            case 3:
                message.hp = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FightInitInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FightInitInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FightInitInfo} FightInitInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightInitInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FightInitInfo message.
     * @function verify
     * @memberof FightInitInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FightInitInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.skill != null && message.hasOwnProperty("skill"))
            if (!$util.isInteger(message.skill))
                return "skill: integer expected";
        if (message.hp != null && message.hasOwnProperty("hp"))
            if (!$util.isInteger(message.hp))
                return "hp: integer expected";
        return null;
    };

    /**
     * Creates a FightInitInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FightInitInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FightInitInfo} FightInitInfo
     */
    FightInitInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.FightInitInfo)
            return object;
        var message = new $root.FightInitInfo();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.skill != null)
            message.skill = object.skill | 0;
        if (object.hp != null)
            message.hp = object.hp | 0;
        return message;
    };

    /**
     * Creates a plain object from a FightInitInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FightInitInfo
     * @static
     * @param {FightInitInfo} message FightInitInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FightInitInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.skill = 0;
            object.hp = 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.skill != null && message.hasOwnProperty("skill"))
            object.skill = message.skill;
        if (message.hp != null && message.hasOwnProperty("hp"))
            object.hp = message.hp;
        return object;
    };

    /**
     * Converts this FightInitInfo to JSON.
     * @function toJSON
     * @memberof FightInitInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FightInitInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FightInitInfo;
})();

$root.FightInfo = (function() {

    /**
     * Properties of a FightInfo.
     * @exports IFightInfo
     * @interface IFightInfo
     * @property {number|Long|null} [attack] FightInfo attack
     * @property {number|Long|null} [defense] FightInfo defense
     * @property {number|null} [status] FightInfo status
     * @property {number|null} [hurt] FightInfo hurt
     */

    /**
     * Constructs a new FightInfo.
     * @exports FightInfo
     * @classdesc Represents a FightInfo.
     * @implements IFightInfo
     * @constructor
     * @param {IFightInfo=} [properties] Properties to set
     */
    function FightInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FightInfo attack.
     * @member {number|Long} attack
     * @memberof FightInfo
     * @instance
     */
    FightInfo.prototype.attack = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * FightInfo defense.
     * @member {number|Long} defense
     * @memberof FightInfo
     * @instance
     */
    FightInfo.prototype.defense = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * FightInfo status.
     * @member {number} status
     * @memberof FightInfo
     * @instance
     */
    FightInfo.prototype.status = 0;

    /**
     * FightInfo hurt.
     * @member {number} hurt
     * @memberof FightInfo
     * @instance
     */
    FightInfo.prototype.hurt = 0;

    /**
     * Creates a new FightInfo instance using the specified properties.
     * @function create
     * @memberof FightInfo
     * @static
     * @param {IFightInfo=} [properties] Properties to set
     * @returns {FightInfo} FightInfo instance
     */
    FightInfo.create = function create(properties) {
        return new FightInfo(properties);
    };

    /**
     * Encodes the specified FightInfo message. Does not implicitly {@link FightInfo.verify|verify} messages.
     * @function encode
     * @memberof FightInfo
     * @static
     * @param {IFightInfo} message FightInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.attack != null && message.hasOwnProperty("attack"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.attack);
        if (message.defense != null && message.hasOwnProperty("defense"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.defense);
        if (message.status != null && message.hasOwnProperty("status"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
        if (message.hurt != null && message.hasOwnProperty("hurt"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hurt);
        return writer;
    };

    /**
     * Encodes the specified FightInfo message, length delimited. Does not implicitly {@link FightInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FightInfo
     * @static
     * @param {IFightInfo} message FightInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FightInfo message from the specified reader or buffer.
     * @function decode
     * @memberof FightInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FightInfo} FightInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FightInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.attack = reader.int64();
                break;
            case 2:
                message.defense = reader.int64();
                break;
            case 3:
                message.status = reader.int32();
                break;
            case 4:
                message.hurt = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FightInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FightInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FightInfo} FightInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FightInfo message.
     * @function verify
     * @memberof FightInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FightInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.attack != null && message.hasOwnProperty("attack"))
            if (!$util.isInteger(message.attack) && !(message.attack && $util.isInteger(message.attack.low) && $util.isInteger(message.attack.high)))
                return "attack: integer|Long expected";
        if (message.defense != null && message.hasOwnProperty("defense"))
            if (!$util.isInteger(message.defense) && !(message.defense && $util.isInteger(message.defense.low) && $util.isInteger(message.defense.high)))
                return "defense: integer|Long expected";
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        if (message.hurt != null && message.hasOwnProperty("hurt"))
            if (!$util.isInteger(message.hurt))
                return "hurt: integer expected";
        return null;
    };

    /**
     * Creates a FightInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FightInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FightInfo} FightInfo
     */
    FightInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.FightInfo)
            return object;
        var message = new $root.FightInfo();
        if (object.attack != null)
            if ($util.Long)
                (message.attack = $util.Long.fromValue(object.attack)).unsigned = false;
            else if (typeof object.attack === "string")
                message.attack = parseInt(object.attack, 10);
            else if (typeof object.attack === "number")
                message.attack = object.attack;
            else if (typeof object.attack === "object")
                message.attack = new $util.LongBits(object.attack.low >>> 0, object.attack.high >>> 0).toNumber();
        if (object.defense != null)
            if ($util.Long)
                (message.defense = $util.Long.fromValue(object.defense)).unsigned = false;
            else if (typeof object.defense === "string")
                message.defense = parseInt(object.defense, 10);
            else if (typeof object.defense === "number")
                message.defense = object.defense;
            else if (typeof object.defense === "object")
                message.defense = new $util.LongBits(object.defense.low >>> 0, object.defense.high >>> 0).toNumber();
        if (object.status != null)
            message.status = object.status | 0;
        if (object.hurt != null)
            message.hurt = object.hurt | 0;
        return message;
    };

    /**
     * Creates a plain object from a FightInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FightInfo
     * @static
     * @param {FightInfo} message FightInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FightInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.attack = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.attack = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.defense = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.defense = options.longs === String ? "0" : 0;
            object.status = 0;
            object.hurt = 0;
        }
        if (message.attack != null && message.hasOwnProperty("attack"))
            if (typeof message.attack === "number")
                object.attack = options.longs === String ? String(message.attack) : message.attack;
            else
                object.attack = options.longs === String ? $util.Long.prototype.toString.call(message.attack) : options.longs === Number ? new $util.LongBits(message.attack.low >>> 0, message.attack.high >>> 0).toNumber() : message.attack;
        if (message.defense != null && message.hasOwnProperty("defense"))
            if (typeof message.defense === "number")
                object.defense = options.longs === String ? String(message.defense) : message.defense;
            else
                object.defense = options.longs === String ? $util.Long.prototype.toString.call(message.defense) : options.longs === Number ? new $util.LongBits(message.defense.low >>> 0, message.defense.high >>> 0).toNumber() : message.defense;
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        if (message.hurt != null && message.hasOwnProperty("hurt"))
            object.hurt = message.hurt;
        return object;
    };

    /**
     * Converts this FightInfo to JSON.
     * @function toJSON
     * @memberof FightInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FightInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FightInfo;
})();

$root.FightResultMsg = (function() {

    /**
     * Properties of a FightResultMsg.
     * @exports IFightResultMsg
     * @interface IFightResultMsg
     * @property {IFightInitInfo|null} [init1] FightResultMsg init1
     * @property {IFightInitInfo|null} [init2] FightResultMsg init2
     * @property {Array.<IFightInfo>|null} [fightInfo] FightResultMsg fightInfo
     * @property {boolean|null} [win] FightResultMsg win
     * @property {Array.<IItemMsg>|null} [drop] FightResultMsg drop
     */

    /**
     * Constructs a new FightResultMsg.
     * @exports FightResultMsg
     * @classdesc Represents a FightResultMsg.
     * @implements IFightResultMsg
     * @constructor
     * @param {IFightResultMsg=} [properties] Properties to set
     */
    function FightResultMsg(properties) {
        this.fightInfo = [];
        this.drop = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FightResultMsg init1.
     * @member {IFightInitInfo|null|undefined} init1
     * @memberof FightResultMsg
     * @instance
     */
    FightResultMsg.prototype.init1 = null;

    /**
     * FightResultMsg init2.
     * @member {IFightInitInfo|null|undefined} init2
     * @memberof FightResultMsg
     * @instance
     */
    FightResultMsg.prototype.init2 = null;

    /**
     * FightResultMsg fightInfo.
     * @member {Array.<IFightInfo>} fightInfo
     * @memberof FightResultMsg
     * @instance
     */
    FightResultMsg.prototype.fightInfo = $util.emptyArray;

    /**
     * FightResultMsg win.
     * @member {boolean} win
     * @memberof FightResultMsg
     * @instance
     */
    FightResultMsg.prototype.win = false;

    /**
     * FightResultMsg drop.
     * @member {Array.<IItemMsg>} drop
     * @memberof FightResultMsg
     * @instance
     */
    FightResultMsg.prototype.drop = $util.emptyArray;

    /**
     * Creates a new FightResultMsg instance using the specified properties.
     * @function create
     * @memberof FightResultMsg
     * @static
     * @param {IFightResultMsg=} [properties] Properties to set
     * @returns {FightResultMsg} FightResultMsg instance
     */
    FightResultMsg.create = function create(properties) {
        return new FightResultMsg(properties);
    };

    /**
     * Encodes the specified FightResultMsg message. Does not implicitly {@link FightResultMsg.verify|verify} messages.
     * @function encode
     * @memberof FightResultMsg
     * @static
     * @param {IFightResultMsg} message FightResultMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightResultMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.init1 != null && message.hasOwnProperty("init1"))
            $root.FightInitInfo.encode(message.init1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.init2 != null && message.hasOwnProperty("init2"))
            $root.FightInitInfo.encode(message.init2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.fightInfo != null && message.fightInfo.length)
            for (var i = 0; i < message.fightInfo.length; ++i)
                $root.FightInfo.encode(message.fightInfo[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.win != null && message.hasOwnProperty("win"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.win);
        if (message.drop != null && message.drop.length)
            for (var i = 0; i < message.drop.length; ++i)
                $root.ItemMsg.encode(message.drop[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified FightResultMsg message, length delimited. Does not implicitly {@link FightResultMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FightResultMsg
     * @static
     * @param {IFightResultMsg} message FightResultMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FightResultMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FightResultMsg message from the specified reader or buffer.
     * @function decode
     * @memberof FightResultMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FightResultMsg} FightResultMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightResultMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FightResultMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.init1 = $root.FightInitInfo.decode(reader, reader.uint32());
                break;
            case 2:
                message.init2 = $root.FightInitInfo.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.fightInfo && message.fightInfo.length))
                    message.fightInfo = [];
                message.fightInfo.push($root.FightInfo.decode(reader, reader.uint32()));
                break;
            case 4:
                message.win = reader.bool();
                break;
            case 5:
                if (!(message.drop && message.drop.length))
                    message.drop = [];
                message.drop.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FightResultMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FightResultMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FightResultMsg} FightResultMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FightResultMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FightResultMsg message.
     * @function verify
     * @memberof FightResultMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FightResultMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.init1 != null && message.hasOwnProperty("init1")) {
            var error = $root.FightInitInfo.verify(message.init1);
            if (error)
                return "init1." + error;
        }
        if (message.init2 != null && message.hasOwnProperty("init2")) {
            var error = $root.FightInitInfo.verify(message.init2);
            if (error)
                return "init2." + error;
        }
        if (message.fightInfo != null && message.hasOwnProperty("fightInfo")) {
            if (!Array.isArray(message.fightInfo))
                return "fightInfo: array expected";
            for (var i = 0; i < message.fightInfo.length; ++i) {
                var error = $root.FightInfo.verify(message.fightInfo[i]);
                if (error)
                    return "fightInfo." + error;
            }
        }
        if (message.win != null && message.hasOwnProperty("win"))
            if (typeof message.win !== "boolean")
                return "win: boolean expected";
        if (message.drop != null && message.hasOwnProperty("drop")) {
            if (!Array.isArray(message.drop))
                return "drop: array expected";
            for (var i = 0; i < message.drop.length; ++i) {
                var error = $root.ItemMsg.verify(message.drop[i]);
                if (error)
                    return "drop." + error;
            }
        }
        return null;
    };

    /**
     * Creates a FightResultMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FightResultMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FightResultMsg} FightResultMsg
     */
    FightResultMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.FightResultMsg)
            return object;
        var message = new $root.FightResultMsg();
        if (object.init1 != null) {
            if (typeof object.init1 !== "object")
                throw TypeError(".FightResultMsg.init1: object expected");
            message.init1 = $root.FightInitInfo.fromObject(object.init1);
        }
        if (object.init2 != null) {
            if (typeof object.init2 !== "object")
                throw TypeError(".FightResultMsg.init2: object expected");
            message.init2 = $root.FightInitInfo.fromObject(object.init2);
        }
        if (object.fightInfo) {
            if (!Array.isArray(object.fightInfo))
                throw TypeError(".FightResultMsg.fightInfo: array expected");
            message.fightInfo = [];
            for (var i = 0; i < object.fightInfo.length; ++i) {
                if (typeof object.fightInfo[i] !== "object")
                    throw TypeError(".FightResultMsg.fightInfo: object expected");
                message.fightInfo[i] = $root.FightInfo.fromObject(object.fightInfo[i]);
            }
        }
        if (object.win != null)
            message.win = Boolean(object.win);
        if (object.drop) {
            if (!Array.isArray(object.drop))
                throw TypeError(".FightResultMsg.drop: array expected");
            message.drop = [];
            for (var i = 0; i < object.drop.length; ++i) {
                if (typeof object.drop[i] !== "object")
                    throw TypeError(".FightResultMsg.drop: object expected");
                message.drop[i] = $root.ItemMsg.fromObject(object.drop[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a FightResultMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FightResultMsg
     * @static
     * @param {FightResultMsg} message FightResultMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FightResultMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.fightInfo = [];
            object.drop = [];
        }
        if (options.defaults) {
            object.init1 = null;
            object.init2 = null;
            object.win = false;
        }
        if (message.init1 != null && message.hasOwnProperty("init1"))
            object.init1 = $root.FightInitInfo.toObject(message.init1, options);
        if (message.init2 != null && message.hasOwnProperty("init2"))
            object.init2 = $root.FightInitInfo.toObject(message.init2, options);
        if (message.fightInfo && message.fightInfo.length) {
            object.fightInfo = [];
            for (var j = 0; j < message.fightInfo.length; ++j)
                object.fightInfo[j] = $root.FightInfo.toObject(message.fightInfo[j], options);
        }
        if (message.win != null && message.hasOwnProperty("win"))
            object.win = message.win;
        if (message.drop && message.drop.length) {
            object.drop = [];
            for (var j = 0; j < message.drop.length; ++j)
                object.drop[j] = $root.ItemMsg.toObject(message.drop[j], options);
        }
        return object;
    };

    /**
     * Converts this FightResultMsg to JSON.
     * @function toJSON
     * @memberof FightResultMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FightResultMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FightResultMsg;
})();

$root.C2S_GoFishing = (function() {

    /**
     * Properties of a C2S_GoFishing.
     * @exports IC2S_GoFishing
     * @interface IC2S_GoFishing
     * @property {GoFishingCmdType} cmdType C2S_GoFishing cmdType
     * @property {GoFishingFieldType} fieldType C2S_GoFishing fieldType
     * @property {number|null} [piaoType] C2S_GoFishing piaoType
     */

    /**
     * Constructs a new C2S_GoFishing.
     * @exports C2S_GoFishing
     * @classdesc Represents a C2S_GoFishing.
     * @implements IC2S_GoFishing
     * @constructor
     * @param {IC2S_GoFishing=} [properties] Properties to set
     */
    function C2S_GoFishing(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_GoFishing cmdType.
     * @member {GoFishingCmdType} cmdType
     * @memberof C2S_GoFishing
     * @instance
     */
    C2S_GoFishing.prototype.cmdType = 1;

    /**
     * C2S_GoFishing fieldType.
     * @member {GoFishingFieldType} fieldType
     * @memberof C2S_GoFishing
     * @instance
     */
    C2S_GoFishing.prototype.fieldType = 1;

    /**
     * C2S_GoFishing piaoType.
     * @member {number} piaoType
     * @memberof C2S_GoFishing
     * @instance
     */
    C2S_GoFishing.prototype.piaoType = 0;

    /**
     * Creates a new C2S_GoFishing instance using the specified properties.
     * @function create
     * @memberof C2S_GoFishing
     * @static
     * @param {IC2S_GoFishing=} [properties] Properties to set
     * @returns {C2S_GoFishing} C2S_GoFishing instance
     */
    C2S_GoFishing.create = function create(properties) {
        return new C2S_GoFishing(properties);
    };

    /**
     * Encodes the specified C2S_GoFishing message. Does not implicitly {@link C2S_GoFishing.verify|verify} messages.
     * @function encode
     * @memberof C2S_GoFishing
     * @static
     * @param {IC2S_GoFishing} message C2S_GoFishing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GoFishing.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fieldType);
        if (message.piaoType != null && message.hasOwnProperty("piaoType"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.piaoType);
        return writer;
    };

    /**
     * Encodes the specified C2S_GoFishing message, length delimited. Does not implicitly {@link C2S_GoFishing.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_GoFishing
     * @static
     * @param {IC2S_GoFishing} message C2S_GoFishing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GoFishing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_GoFishing message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_GoFishing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_GoFishing} C2S_GoFishing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GoFishing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_GoFishing();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                message.fieldType = reader.int32();
                break;
            case 3:
                message.piaoType = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        if (!message.hasOwnProperty("fieldType"))
            throw $util.ProtocolError("missing required 'fieldType'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_GoFishing message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_GoFishing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_GoFishing} C2S_GoFishing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GoFishing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_GoFishing message.
     * @function verify
     * @memberof C2S_GoFishing
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_GoFishing.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
            break;
        }
        switch (message.fieldType) {
        default:
            return "fieldType: enum value expected";
        case 1:
        case 2:
            break;
        }
        if (message.piaoType != null && message.hasOwnProperty("piaoType"))
            if (!$util.isInteger(message.piaoType))
                return "piaoType: integer expected";
        return null;
    };

    /**
     * Creates a C2S_GoFishing message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_GoFishing
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_GoFishing} C2S_GoFishing
     */
    C2S_GoFishing.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_GoFishing)
            return object;
        var message = new $root.C2S_GoFishing();
        switch (object.cmdType) {
        case "EnterField_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "PaoGan_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        case "System_Calc_LaGan":
        case 3:
            message.cmdType = 3;
            break;
        case "LaGan_Cmd":
        case 4:
            message.cmdType = 4;
            break;
        case "ChangeState_Cmd":
        case 5:
            message.cmdType = 5;
            break;
        case "Reconnect_Cmd":
        case 6:
            message.cmdType = 6;
            break;
        case "GetConsume_Cmd":
        case 7:
            message.cmdType = 7;
            break;
        case "GetFishingRod_Cmd":
        case 8:
            message.cmdType = 8;
            break;
        }
        switch (object.fieldType) {
        case "AboveGround":
        case 1:
            message.fieldType = 1;
            break;
        case "TheSky":
        case 2:
            message.fieldType = 2;
            break;
        }
        if (object.piaoType != null)
            message.piaoType = object.piaoType | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_GoFishing message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_GoFishing
     * @static
     * @param {C2S_GoFishing} message C2S_GoFishing
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_GoFishing.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmdType = options.enums === String ? "EnterField_Cmd" : 1;
            object.fieldType = options.enums === String ? "AboveGround" : 1;
            object.piaoType = 0;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.GoFishingCmdType[message.cmdType] : message.cmdType;
        if (message.fieldType != null && message.hasOwnProperty("fieldType"))
            object.fieldType = options.enums === String ? $root.GoFishingFieldType[message.fieldType] : message.fieldType;
        if (message.piaoType != null && message.hasOwnProperty("piaoType"))
            object.piaoType = message.piaoType;
        return object;
    };

    /**
     * Converts this C2S_GoFishing to JSON.
     * @function toJSON
     * @memberof C2S_GoFishing
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_GoFishing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_GoFishing;
})();

$root.S2C_GoFishing = (function() {

    /**
     * Properties of a S2C_GoFishing.
     * @exports IS2C_GoFishing
     * @interface IS2C_GoFishing
     * @property {GoFishingCmdType} cmdType S2C_GoFishing cmdType
     * @property {number|null} [piaoType] S2C_GoFishing piaoType
     * @property {Array.<IRewardInfoPB>|null} [reward] S2C_GoFishing reward
     * @property {number|null} [countDown] S2C_GoFishing countDown
     * @property {number|null} [gameState] S2C_GoFishing gameState
     * @property {GoFishingFieldType|null} [fieldType] S2C_GoFishing fieldType
     * @property {number|null} [gameRemainTime] S2C_GoFishing gameRemainTime
     * @property {IGoFishingConsumeInfoPB|null} [consume] S2C_GoFishing consume
     * @property {IFishingRodInfoPB|null} [fishingRodInfo] S2C_GoFishing fishingRodInfo
     */

    /**
     * Constructs a new S2C_GoFishing.
     * @exports S2C_GoFishing
     * @classdesc Represents a S2C_GoFishing.
     * @implements IS2C_GoFishing
     * @constructor
     * @param {IS2C_GoFishing=} [properties] Properties to set
     */
    function S2C_GoFishing(properties) {
        this.reward = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_GoFishing cmdType.
     * @member {GoFishingCmdType} cmdType
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.cmdType = 1;

    /**
     * S2C_GoFishing piaoType.
     * @member {number} piaoType
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.piaoType = 0;

    /**
     * S2C_GoFishing reward.
     * @member {Array.<IRewardInfoPB>} reward
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.reward = $util.emptyArray;

    /**
     * S2C_GoFishing countDown.
     * @member {number} countDown
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.countDown = 0;

    /**
     * S2C_GoFishing gameState.
     * @member {number} gameState
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.gameState = 0;

    /**
     * S2C_GoFishing fieldType.
     * @member {GoFishingFieldType} fieldType
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.fieldType = 1;

    /**
     * S2C_GoFishing gameRemainTime.
     * @member {number} gameRemainTime
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.gameRemainTime = 0;

    /**
     * S2C_GoFishing consume.
     * @member {IGoFishingConsumeInfoPB|null|undefined} consume
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.consume = null;

    /**
     * S2C_GoFishing fishingRodInfo.
     * @member {IFishingRodInfoPB|null|undefined} fishingRodInfo
     * @memberof S2C_GoFishing
     * @instance
     */
    S2C_GoFishing.prototype.fishingRodInfo = null;

    /**
     * Creates a new S2C_GoFishing instance using the specified properties.
     * @function create
     * @memberof S2C_GoFishing
     * @static
     * @param {IS2C_GoFishing=} [properties] Properties to set
     * @returns {S2C_GoFishing} S2C_GoFishing instance
     */
    S2C_GoFishing.create = function create(properties) {
        return new S2C_GoFishing(properties);
    };

    /**
     * Encodes the specified S2C_GoFishing message. Does not implicitly {@link S2C_GoFishing.verify|verify} messages.
     * @function encode
     * @memberof S2C_GoFishing
     * @static
     * @param {IS2C_GoFishing} message S2C_GoFishing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GoFishing.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.piaoType != null && message.hasOwnProperty("piaoType"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.piaoType);
        if (message.reward != null && message.reward.length)
            for (var i = 0; i < message.reward.length; ++i)
                $root.RewardInfoPB.encode(message.reward[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.countDown != null && message.hasOwnProperty("countDown"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.countDown);
        if (message.gameState != null && message.hasOwnProperty("gameState"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.gameState);
        if (message.fieldType != null && message.hasOwnProperty("fieldType"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.fieldType);
        if (message.gameRemainTime != null && message.hasOwnProperty("gameRemainTime"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.gameRemainTime);
        if (message.consume != null && message.hasOwnProperty("consume"))
            $root.GoFishingConsumeInfoPB.encode(message.consume, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.fishingRodInfo != null && message.hasOwnProperty("fishingRodInfo"))
            $root.FishingRodInfoPB.encode(message.fishingRodInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_GoFishing message, length delimited. Does not implicitly {@link S2C_GoFishing.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_GoFishing
     * @static
     * @param {IS2C_GoFishing} message S2C_GoFishing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GoFishing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_GoFishing message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_GoFishing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_GoFishing} S2C_GoFishing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GoFishing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_GoFishing();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                message.piaoType = reader.int32();
                break;
            case 3:
                if (!(message.reward && message.reward.length))
                    message.reward = [];
                message.reward.push($root.RewardInfoPB.decode(reader, reader.uint32()));
                break;
            case 4:
                message.countDown = reader.int32();
                break;
            case 5:
                message.gameState = reader.int32();
                break;
            case 6:
                message.fieldType = reader.int32();
                break;
            case 7:
                message.gameRemainTime = reader.int32();
                break;
            case 8:
                message.consume = $root.GoFishingConsumeInfoPB.decode(reader, reader.uint32());
                break;
            case 9:
                message.fishingRodInfo = $root.FishingRodInfoPB.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_GoFishing message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_GoFishing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_GoFishing} S2C_GoFishing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GoFishing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_GoFishing message.
     * @function verify
     * @memberof S2C_GoFishing
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_GoFishing.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
            break;
        }
        if (message.piaoType != null && message.hasOwnProperty("piaoType"))
            if (!$util.isInteger(message.piaoType))
                return "piaoType: integer expected";
        if (message.reward != null && message.hasOwnProperty("reward")) {
            if (!Array.isArray(message.reward))
                return "reward: array expected";
            for (var i = 0; i < message.reward.length; ++i) {
                var error = $root.RewardInfoPB.verify(message.reward[i]);
                if (error)
                    return "reward." + error;
            }
        }
        if (message.countDown != null && message.hasOwnProperty("countDown"))
            if (!$util.isInteger(message.countDown))
                return "countDown: integer expected";
        if (message.gameState != null && message.hasOwnProperty("gameState"))
            if (!$util.isInteger(message.gameState))
                return "gameState: integer expected";
        if (message.fieldType != null && message.hasOwnProperty("fieldType"))
            switch (message.fieldType) {
            default:
                return "fieldType: enum value expected";
            case 1:
            case 2:
                break;
            }
        if (message.gameRemainTime != null && message.hasOwnProperty("gameRemainTime"))
            if (!$util.isInteger(message.gameRemainTime))
                return "gameRemainTime: integer expected";
        if (message.consume != null && message.hasOwnProperty("consume")) {
            var error = $root.GoFishingConsumeInfoPB.verify(message.consume);
            if (error)
                return "consume." + error;
        }
        if (message.fishingRodInfo != null && message.hasOwnProperty("fishingRodInfo")) {
            var error = $root.FishingRodInfoPB.verify(message.fishingRodInfo);
            if (error)
                return "fishingRodInfo." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_GoFishing message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_GoFishing
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_GoFishing} S2C_GoFishing
     */
    S2C_GoFishing.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_GoFishing)
            return object;
        var message = new $root.S2C_GoFishing();
        switch (object.cmdType) {
        case "EnterField_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "PaoGan_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        case "System_Calc_LaGan":
        case 3:
            message.cmdType = 3;
            break;
        case "LaGan_Cmd":
        case 4:
            message.cmdType = 4;
            break;
        case "ChangeState_Cmd":
        case 5:
            message.cmdType = 5;
            break;
        case "Reconnect_Cmd":
        case 6:
            message.cmdType = 6;
            break;
        case "GetConsume_Cmd":
        case 7:
            message.cmdType = 7;
            break;
        case "GetFishingRod_Cmd":
        case 8:
            message.cmdType = 8;
            break;
        }
        if (object.piaoType != null)
            message.piaoType = object.piaoType | 0;
        if (object.reward) {
            if (!Array.isArray(object.reward))
                throw TypeError(".S2C_GoFishing.reward: array expected");
            message.reward = [];
            for (var i = 0; i < object.reward.length; ++i) {
                if (typeof object.reward[i] !== "object")
                    throw TypeError(".S2C_GoFishing.reward: object expected");
                message.reward[i] = $root.RewardInfoPB.fromObject(object.reward[i]);
            }
        }
        if (object.countDown != null)
            message.countDown = object.countDown | 0;
        if (object.gameState != null)
            message.gameState = object.gameState | 0;
        switch (object.fieldType) {
        case "AboveGround":
        case 1:
            message.fieldType = 1;
            break;
        case "TheSky":
        case 2:
            message.fieldType = 2;
            break;
        }
        if (object.gameRemainTime != null)
            message.gameRemainTime = object.gameRemainTime | 0;
        if (object.consume != null) {
            if (typeof object.consume !== "object")
                throw TypeError(".S2C_GoFishing.consume: object expected");
            message.consume = $root.GoFishingConsumeInfoPB.fromObject(object.consume);
        }
        if (object.fishingRodInfo != null) {
            if (typeof object.fishingRodInfo !== "object")
                throw TypeError(".S2C_GoFishing.fishingRodInfo: object expected");
            message.fishingRodInfo = $root.FishingRodInfoPB.fromObject(object.fishingRodInfo);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_GoFishing message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_GoFishing
     * @static
     * @param {S2C_GoFishing} message S2C_GoFishing
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_GoFishing.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.reward = [];
        if (options.defaults) {
            object.cmdType = options.enums === String ? "EnterField_Cmd" : 1;
            object.piaoType = 0;
            object.countDown = 0;
            object.gameState = 0;
            object.fieldType = options.enums === String ? "AboveGround" : 1;
            object.gameRemainTime = 0;
            object.consume = null;
            object.fishingRodInfo = null;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.GoFishingCmdType[message.cmdType] : message.cmdType;
        if (message.piaoType != null && message.hasOwnProperty("piaoType"))
            object.piaoType = message.piaoType;
        if (message.reward && message.reward.length) {
            object.reward = [];
            for (var j = 0; j < message.reward.length; ++j)
                object.reward[j] = $root.RewardInfoPB.toObject(message.reward[j], options);
        }
        if (message.countDown != null && message.hasOwnProperty("countDown"))
            object.countDown = message.countDown;
        if (message.gameState != null && message.hasOwnProperty("gameState"))
            object.gameState = message.gameState;
        if (message.fieldType != null && message.hasOwnProperty("fieldType"))
            object.fieldType = options.enums === String ? $root.GoFishingFieldType[message.fieldType] : message.fieldType;
        if (message.gameRemainTime != null && message.hasOwnProperty("gameRemainTime"))
            object.gameRemainTime = message.gameRemainTime;
        if (message.consume != null && message.hasOwnProperty("consume"))
            object.consume = $root.GoFishingConsumeInfoPB.toObject(message.consume, options);
        if (message.fishingRodInfo != null && message.hasOwnProperty("fishingRodInfo"))
            object.fishingRodInfo = $root.FishingRodInfoPB.toObject(message.fishingRodInfo, options);
        return object;
    };

    /**
     * Converts this S2C_GoFishing to JSON.
     * @function toJSON
     * @memberof S2C_GoFishing
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_GoFishing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_GoFishing;
})();

/**
 * GoFishingFieldType enum.
 * @exports GoFishingFieldType
 * @enum {string}
 * @property {number} AboveGround=1 AboveGround value
 * @property {number} TheSky=2 TheSky value
 */
$root.GoFishingFieldType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "AboveGround"] = 1;
    values[valuesById[2] = "TheSky"] = 2;
    return values;
})();

/**
 * GoFishingCmdType enum.
 * @exports GoFishingCmdType
 * @enum {string}
 * @property {number} EnterField_Cmd=1 EnterField_Cmd value
 * @property {number} PaoGan_Cmd=2 PaoGan_Cmd value
 * @property {number} System_Calc_LaGan=3 System_Calc_LaGan value
 * @property {number} LaGan_Cmd=4 LaGan_Cmd value
 * @property {number} ChangeState_Cmd=5 ChangeState_Cmd value
 * @property {number} Reconnect_Cmd=6 Reconnect_Cmd value
 * @property {number} GetConsume_Cmd=7 GetConsume_Cmd value
 * @property {number} GetFishingRod_Cmd=8 GetFishingRod_Cmd value
 */
$root.GoFishingCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "EnterField_Cmd"] = 1;
    values[valuesById[2] = "PaoGan_Cmd"] = 2;
    values[valuesById[3] = "System_Calc_LaGan"] = 3;
    values[valuesById[4] = "LaGan_Cmd"] = 4;
    values[valuesById[5] = "ChangeState_Cmd"] = 5;
    values[valuesById[6] = "Reconnect_Cmd"] = 6;
    values[valuesById[7] = "GetConsume_Cmd"] = 7;
    values[valuesById[8] = "GetFishingRod_Cmd"] = 8;
    return values;
})();

/**
 * PiaoType enum.
 * @exports PiaoType
 * @enum {string}
 * @property {number} DaLi=1 DaLi value
 * @property {number} YuHui=2 YuHui value
 * @property {number} KuaiSu=3 KuaiSu value
 */
$root.PiaoType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "DaLi"] = 1;
    values[valuesById[2] = "YuHui"] = 2;
    values[valuesById[3] = "KuaiSu"] = 3;
    return values;
})();

/**
 * GameState enum.
 * @exports GameState
 * @enum {string}
 * @property {number} Inited=1 Inited value
 * @property {number} PaoGan=2 PaoGan value
 * @property {number} LaGan=3 LaGan value
 * @property {number} GameOver=4 GameOver value
 * @property {number} Stop=5 Stop value
 */
$root.GameState = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "Inited"] = 1;
    values[valuesById[2] = "PaoGan"] = 2;
    values[valuesById[3] = "LaGan"] = 3;
    values[valuesById[4] = "GameOver"] = 4;
    values[valuesById[5] = "Stop"] = 5;
    return values;
})();

$root.RewardInfoPB = (function() {

    /**
     * Properties of a RewardInfoPB.
     * @exports IRewardInfoPB
     * @interface IRewardInfoPB
     * @property {number} itemID RewardInfoPB itemID
     * @property {number} count RewardInfoPB count
     */

    /**
     * Constructs a new RewardInfoPB.
     * @exports RewardInfoPB
     * @classdesc Represents a RewardInfoPB.
     * @implements IRewardInfoPB
     * @constructor
     * @param {IRewardInfoPB=} [properties] Properties to set
     */
    function RewardInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RewardInfoPB itemID.
     * @member {number} itemID
     * @memberof RewardInfoPB
     * @instance
     */
    RewardInfoPB.prototype.itemID = 0;

    /**
     * RewardInfoPB count.
     * @member {number} count
     * @memberof RewardInfoPB
     * @instance
     */
    RewardInfoPB.prototype.count = 0;

    /**
     * Creates a new RewardInfoPB instance using the specified properties.
     * @function create
     * @memberof RewardInfoPB
     * @static
     * @param {IRewardInfoPB=} [properties] Properties to set
     * @returns {RewardInfoPB} RewardInfoPB instance
     */
    RewardInfoPB.create = function create(properties) {
        return new RewardInfoPB(properties);
    };

    /**
     * Encodes the specified RewardInfoPB message. Does not implicitly {@link RewardInfoPB.verify|verify} messages.
     * @function encode
     * @memberof RewardInfoPB
     * @static
     * @param {IRewardInfoPB} message RewardInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RewardInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemID);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified RewardInfoPB message, length delimited. Does not implicitly {@link RewardInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RewardInfoPB
     * @static
     * @param {IRewardInfoPB} message RewardInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RewardInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RewardInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof RewardInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RewardInfoPB} RewardInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RewardInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RewardInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.itemID = reader.int32();
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("itemID"))
            throw $util.ProtocolError("missing required 'itemID'", { instance: message });
        if (!message.hasOwnProperty("count"))
            throw $util.ProtocolError("missing required 'count'", { instance: message });
        return message;
    };

    /**
     * Decodes a RewardInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RewardInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RewardInfoPB} RewardInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RewardInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RewardInfoPB message.
     * @function verify
     * @memberof RewardInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RewardInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.itemID))
            return "itemID: integer expected";
        if (!$util.isInteger(message.count))
            return "count: integer expected";
        return null;
    };

    /**
     * Creates a RewardInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RewardInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RewardInfoPB} RewardInfoPB
     */
    RewardInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.RewardInfoPB)
            return object;
        var message = new $root.RewardInfoPB();
        if (object.itemID != null)
            message.itemID = object.itemID | 0;
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a RewardInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RewardInfoPB
     * @static
     * @param {RewardInfoPB} message RewardInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RewardInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.itemID = 0;
            object.count = 0;
        }
        if (message.itemID != null && message.hasOwnProperty("itemID"))
            object.itemID = message.itemID;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this RewardInfoPB to JSON.
     * @function toJSON
     * @memberof RewardInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RewardInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RewardInfoPB;
})();

$root.GoFishingConsumeInfoPB = (function() {

    /**
     * Properties of a GoFishingConsumeInfoPB.
     * @exports IGoFishingConsumeInfoPB
     * @interface IGoFishingConsumeInfoPB
     * @property {Array.<IResourceMsg>|null} [resource] GoFishingConsumeInfoPB resource
     * @property {number|null} [count] GoFishingConsumeInfoPB count
     */

    /**
     * Constructs a new GoFishingConsumeInfoPB.
     * @exports GoFishingConsumeInfoPB
     * @classdesc Represents a GoFishingConsumeInfoPB.
     * @implements IGoFishingConsumeInfoPB
     * @constructor
     * @param {IGoFishingConsumeInfoPB=} [properties] Properties to set
     */
    function GoFishingConsumeInfoPB(properties) {
        this.resource = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GoFishingConsumeInfoPB resource.
     * @member {Array.<IResourceMsg>} resource
     * @memberof GoFishingConsumeInfoPB
     * @instance
     */
    GoFishingConsumeInfoPB.prototype.resource = $util.emptyArray;

    /**
     * GoFishingConsumeInfoPB count.
     * @member {number} count
     * @memberof GoFishingConsumeInfoPB
     * @instance
     */
    GoFishingConsumeInfoPB.prototype.count = 0;

    /**
     * Creates a new GoFishingConsumeInfoPB instance using the specified properties.
     * @function create
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {IGoFishingConsumeInfoPB=} [properties] Properties to set
     * @returns {GoFishingConsumeInfoPB} GoFishingConsumeInfoPB instance
     */
    GoFishingConsumeInfoPB.create = function create(properties) {
        return new GoFishingConsumeInfoPB(properties);
    };

    /**
     * Encodes the specified GoFishingConsumeInfoPB message. Does not implicitly {@link GoFishingConsumeInfoPB.verify|verify} messages.
     * @function encode
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {IGoFishingConsumeInfoPB} message GoFishingConsumeInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GoFishingConsumeInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.resource != null && message.resource.length)
            for (var i = 0; i < message.resource.length; ++i)
                $root.ResourceMsg.encode(message.resource[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified GoFishingConsumeInfoPB message, length delimited. Does not implicitly {@link GoFishingConsumeInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {IGoFishingConsumeInfoPB} message GoFishingConsumeInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GoFishingConsumeInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GoFishingConsumeInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GoFishingConsumeInfoPB} GoFishingConsumeInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GoFishingConsumeInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GoFishingConsumeInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.resource && message.resource.length))
                    message.resource = [];
                message.resource.push($root.ResourceMsg.decode(reader, reader.uint32()));
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GoFishingConsumeInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GoFishingConsumeInfoPB} GoFishingConsumeInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GoFishingConsumeInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GoFishingConsumeInfoPB message.
     * @function verify
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GoFishingConsumeInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.resource != null && message.hasOwnProperty("resource")) {
            if (!Array.isArray(message.resource))
                return "resource: array expected";
            for (var i = 0; i < message.resource.length; ++i) {
                var error = $root.ResourceMsg.verify(message.resource[i]);
                if (error)
                    return "resource." + error;
            }
        }
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a GoFishingConsumeInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GoFishingConsumeInfoPB} GoFishingConsumeInfoPB
     */
    GoFishingConsumeInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.GoFishingConsumeInfoPB)
            return object;
        var message = new $root.GoFishingConsumeInfoPB();
        if (object.resource) {
            if (!Array.isArray(object.resource))
                throw TypeError(".GoFishingConsumeInfoPB.resource: array expected");
            message.resource = [];
            for (var i = 0; i < object.resource.length; ++i) {
                if (typeof object.resource[i] !== "object")
                    throw TypeError(".GoFishingConsumeInfoPB.resource: object expected");
                message.resource[i] = $root.ResourceMsg.fromObject(object.resource[i]);
            }
        }
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a GoFishingConsumeInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GoFishingConsumeInfoPB
     * @static
     * @param {GoFishingConsumeInfoPB} message GoFishingConsumeInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GoFishingConsumeInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.resource = [];
        if (options.defaults)
            object.count = 0;
        if (message.resource && message.resource.length) {
            object.resource = [];
            for (var j = 0; j < message.resource.length; ++j)
                object.resource[j] = $root.ResourceMsg.toObject(message.resource[j], options);
        }
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this GoFishingConsumeInfoPB to JSON.
     * @function toJSON
     * @memberof GoFishingConsumeInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GoFishingConsumeInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GoFishingConsumeInfoPB;
})();

$root.FishingRodInfoPB = (function() {

    /**
     * Properties of a FishingRodInfoPB.
     * @exports IFishingRodInfoPB
     * @interface IFishingRodInfoPB
     * @property {number|null} [useing] FishingRodInfoPB useing
     * @property {Array.<number>|null} [ownedFishingRod] FishingRodInfoPB ownedFishingRod
     */

    /**
     * Constructs a new FishingRodInfoPB.
     * @exports FishingRodInfoPB
     * @classdesc Represents a FishingRodInfoPB.
     * @implements IFishingRodInfoPB
     * @constructor
     * @param {IFishingRodInfoPB=} [properties] Properties to set
     */
    function FishingRodInfoPB(properties) {
        this.ownedFishingRod = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FishingRodInfoPB useing.
     * @member {number} useing
     * @memberof FishingRodInfoPB
     * @instance
     */
    FishingRodInfoPB.prototype.useing = 0;

    /**
     * FishingRodInfoPB ownedFishingRod.
     * @member {Array.<number>} ownedFishingRod
     * @memberof FishingRodInfoPB
     * @instance
     */
    FishingRodInfoPB.prototype.ownedFishingRod = $util.emptyArray;

    /**
     * Creates a new FishingRodInfoPB instance using the specified properties.
     * @function create
     * @memberof FishingRodInfoPB
     * @static
     * @param {IFishingRodInfoPB=} [properties] Properties to set
     * @returns {FishingRodInfoPB} FishingRodInfoPB instance
     */
    FishingRodInfoPB.create = function create(properties) {
        return new FishingRodInfoPB(properties);
    };

    /**
     * Encodes the specified FishingRodInfoPB message. Does not implicitly {@link FishingRodInfoPB.verify|verify} messages.
     * @function encode
     * @memberof FishingRodInfoPB
     * @static
     * @param {IFishingRodInfoPB} message FishingRodInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FishingRodInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.useing != null && message.hasOwnProperty("useing"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.useing);
        if (message.ownedFishingRod != null && message.ownedFishingRod.length)
            for (var i = 0; i < message.ownedFishingRod.length; ++i)
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ownedFishingRod[i]);
        return writer;
    };

    /**
     * Encodes the specified FishingRodInfoPB message, length delimited. Does not implicitly {@link FishingRodInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FishingRodInfoPB
     * @static
     * @param {IFishingRodInfoPB} message FishingRodInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FishingRodInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FishingRodInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof FishingRodInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FishingRodInfoPB} FishingRodInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FishingRodInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FishingRodInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.useing = reader.int32();
                break;
            case 2:
                if (!(message.ownedFishingRod && message.ownedFishingRod.length))
                    message.ownedFishingRod = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.ownedFishingRod.push(reader.int32());
                } else
                    message.ownedFishingRod.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FishingRodInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FishingRodInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FishingRodInfoPB} FishingRodInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FishingRodInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FishingRodInfoPB message.
     * @function verify
     * @memberof FishingRodInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FishingRodInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.useing != null && message.hasOwnProperty("useing"))
            if (!$util.isInteger(message.useing))
                return "useing: integer expected";
        if (message.ownedFishingRod != null && message.hasOwnProperty("ownedFishingRod")) {
            if (!Array.isArray(message.ownedFishingRod))
                return "ownedFishingRod: array expected";
            for (var i = 0; i < message.ownedFishingRod.length; ++i)
                if (!$util.isInteger(message.ownedFishingRod[i]))
                    return "ownedFishingRod: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a FishingRodInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FishingRodInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FishingRodInfoPB} FishingRodInfoPB
     */
    FishingRodInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.FishingRodInfoPB)
            return object;
        var message = new $root.FishingRodInfoPB();
        if (object.useing != null)
            message.useing = object.useing | 0;
        if (object.ownedFishingRod) {
            if (!Array.isArray(object.ownedFishingRod))
                throw TypeError(".FishingRodInfoPB.ownedFishingRod: array expected");
            message.ownedFishingRod = [];
            for (var i = 0; i < object.ownedFishingRod.length; ++i)
                message.ownedFishingRod[i] = object.ownedFishingRod[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a FishingRodInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FishingRodInfoPB
     * @static
     * @param {FishingRodInfoPB} message FishingRodInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FishingRodInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ownedFishingRod = [];
        if (options.defaults)
            object.useing = 0;
        if (message.useing != null && message.hasOwnProperty("useing"))
            object.useing = message.useing;
        if (message.ownedFishingRod && message.ownedFishingRod.length) {
            object.ownedFishingRod = [];
            for (var j = 0; j < message.ownedFishingRod.length; ++j)
                object.ownedFishingRod[j] = message.ownedFishingRod[j];
        }
        return object;
    };

    /**
     * Converts this FishingRodInfoPB to JSON.
     * @function toJSON
     * @memberof FishingRodInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FishingRodInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FishingRodInfoPB;
})();

$root.C2S_GetGongFa = (function() {

    /**
     * Properties of a C2S_GetGongFa.
     * @exports IC2S_GetGongFa
     * @interface IC2S_GetGongFa
     */

    /**
     * Constructs a new C2S_GetGongFa.
     * @exports C2S_GetGongFa
     * @classdesc Represents a C2S_GetGongFa.
     * @implements IC2S_GetGongFa
     * @constructor
     * @param {IC2S_GetGongFa=} [properties] Properties to set
     */
    function C2S_GetGongFa(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_GetGongFa instance using the specified properties.
     * @function create
     * @memberof C2S_GetGongFa
     * @static
     * @param {IC2S_GetGongFa=} [properties] Properties to set
     * @returns {C2S_GetGongFa} C2S_GetGongFa instance
     */
    C2S_GetGongFa.create = function create(properties) {
        return new C2S_GetGongFa(properties);
    };

    /**
     * Encodes the specified C2S_GetGongFa message. Does not implicitly {@link C2S_GetGongFa.verify|verify} messages.
     * @function encode
     * @memberof C2S_GetGongFa
     * @static
     * @param {IC2S_GetGongFa} message C2S_GetGongFa message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetGongFa.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_GetGongFa message, length delimited. Does not implicitly {@link C2S_GetGongFa.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_GetGongFa
     * @static
     * @param {IC2S_GetGongFa} message C2S_GetGongFa message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetGongFa.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_GetGongFa message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_GetGongFa
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_GetGongFa} C2S_GetGongFa
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetGongFa.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_GetGongFa();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_GetGongFa message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_GetGongFa
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_GetGongFa} C2S_GetGongFa
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetGongFa.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_GetGongFa message.
     * @function verify
     * @memberof C2S_GetGongFa
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_GetGongFa.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_GetGongFa message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_GetGongFa
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_GetGongFa} C2S_GetGongFa
     */
    C2S_GetGongFa.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_GetGongFa)
            return object;
        return new $root.C2S_GetGongFa();
    };

    /**
     * Creates a plain object from a C2S_GetGongFa message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_GetGongFa
     * @static
     * @param {C2S_GetGongFa} message C2S_GetGongFa
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_GetGongFa.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_GetGongFa to JSON.
     * @function toJSON
     * @memberof C2S_GetGongFa
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_GetGongFa.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_GetGongFa;
})();

$root.S2C_GetGongFa = (function() {

    /**
     * Properties of a S2C_GetGongFa.
     * @exports IS2C_GetGongFa
     * @interface IS2C_GetGongFa
     * @property {Array.<IGongFaInfoPB>|null} [gongFaInfo] S2C_GetGongFa gongFaInfo
     * @property {number} skillNumID S2C_GetGongFa skillNumID
     * @property {number} zhaoShi S2C_GetGongFa zhaoShi
     */

    /**
     * Constructs a new S2C_GetGongFa.
     * @exports S2C_GetGongFa
     * @classdesc Represents a S2C_GetGongFa.
     * @implements IS2C_GetGongFa
     * @constructor
     * @param {IS2C_GetGongFa=} [properties] Properties to set
     */
    function S2C_GetGongFa(properties) {
        this.gongFaInfo = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_GetGongFa gongFaInfo.
     * @member {Array.<IGongFaInfoPB>} gongFaInfo
     * @memberof S2C_GetGongFa
     * @instance
     */
    S2C_GetGongFa.prototype.gongFaInfo = $util.emptyArray;

    /**
     * S2C_GetGongFa skillNumID.
     * @member {number} skillNumID
     * @memberof S2C_GetGongFa
     * @instance
     */
    S2C_GetGongFa.prototype.skillNumID = 0;

    /**
     * S2C_GetGongFa zhaoShi.
     * @member {number} zhaoShi
     * @memberof S2C_GetGongFa
     * @instance
     */
    S2C_GetGongFa.prototype.zhaoShi = 0;

    /**
     * Creates a new S2C_GetGongFa instance using the specified properties.
     * @function create
     * @memberof S2C_GetGongFa
     * @static
     * @param {IS2C_GetGongFa=} [properties] Properties to set
     * @returns {S2C_GetGongFa} S2C_GetGongFa instance
     */
    S2C_GetGongFa.create = function create(properties) {
        return new S2C_GetGongFa(properties);
    };

    /**
     * Encodes the specified S2C_GetGongFa message. Does not implicitly {@link S2C_GetGongFa.verify|verify} messages.
     * @function encode
     * @memberof S2C_GetGongFa
     * @static
     * @param {IS2C_GetGongFa} message S2C_GetGongFa message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetGongFa.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.gongFaInfo != null && message.gongFaInfo.length)
            for (var i = 0; i < message.gongFaInfo.length; ++i)
                $root.GongFaInfoPB.encode(message.gongFaInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.skillNumID);
        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.zhaoShi);
        return writer;
    };

    /**
     * Encodes the specified S2C_GetGongFa message, length delimited. Does not implicitly {@link S2C_GetGongFa.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_GetGongFa
     * @static
     * @param {IS2C_GetGongFa} message S2C_GetGongFa message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetGongFa.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_GetGongFa message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_GetGongFa
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_GetGongFa} S2C_GetGongFa
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetGongFa.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_GetGongFa();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.gongFaInfo && message.gongFaInfo.length))
                    message.gongFaInfo = [];
                message.gongFaInfo.push($root.GongFaInfoPB.decode(reader, reader.uint32()));
                break;
            case 2:
                message.skillNumID = reader.int32();
                break;
            case 3:
                message.zhaoShi = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("skillNumID"))
            throw $util.ProtocolError("missing required 'skillNumID'", { instance: message });
        if (!message.hasOwnProperty("zhaoShi"))
            throw $util.ProtocolError("missing required 'zhaoShi'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_GetGongFa message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_GetGongFa
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_GetGongFa} S2C_GetGongFa
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetGongFa.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_GetGongFa message.
     * @function verify
     * @memberof S2C_GetGongFa
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_GetGongFa.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.gongFaInfo != null && message.hasOwnProperty("gongFaInfo")) {
            if (!Array.isArray(message.gongFaInfo))
                return "gongFaInfo: array expected";
            for (var i = 0; i < message.gongFaInfo.length; ++i) {
                var error = $root.GongFaInfoPB.verify(message.gongFaInfo[i]);
                if (error)
                    return "gongFaInfo." + error;
            }
        }
        if (!$util.isInteger(message.skillNumID))
            return "skillNumID: integer expected";
        if (!$util.isInteger(message.zhaoShi))
            return "zhaoShi: integer expected";
        return null;
    };

    /**
     * Creates a S2C_GetGongFa message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_GetGongFa
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_GetGongFa} S2C_GetGongFa
     */
    S2C_GetGongFa.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_GetGongFa)
            return object;
        var message = new $root.S2C_GetGongFa();
        if (object.gongFaInfo) {
            if (!Array.isArray(object.gongFaInfo))
                throw TypeError(".S2C_GetGongFa.gongFaInfo: array expected");
            message.gongFaInfo = [];
            for (var i = 0; i < object.gongFaInfo.length; ++i) {
                if (typeof object.gongFaInfo[i] !== "object")
                    throw TypeError(".S2C_GetGongFa.gongFaInfo: object expected");
                message.gongFaInfo[i] = $root.GongFaInfoPB.fromObject(object.gongFaInfo[i]);
            }
        }
        if (object.skillNumID != null)
            message.skillNumID = object.skillNumID | 0;
        if (object.zhaoShi != null)
            message.zhaoShi = object.zhaoShi | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_GetGongFa message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_GetGongFa
     * @static
     * @param {S2C_GetGongFa} message S2C_GetGongFa
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_GetGongFa.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.gongFaInfo = [];
        if (options.defaults) {
            object.skillNumID = 0;
            object.zhaoShi = 0;
        }
        if (message.gongFaInfo && message.gongFaInfo.length) {
            object.gongFaInfo = [];
            for (var j = 0; j < message.gongFaInfo.length; ++j)
                object.gongFaInfo[j] = $root.GongFaInfoPB.toObject(message.gongFaInfo[j], options);
        }
        if (message.skillNumID != null && message.hasOwnProperty("skillNumID"))
            object.skillNumID = message.skillNumID;
        if (message.zhaoShi != null && message.hasOwnProperty("zhaoShi"))
            object.zhaoShi = message.zhaoShi;
        return object;
    };

    /**
     * Converts this S2C_GetGongFa to JSON.
     * @function toJSON
     * @memberof S2C_GetGongFa
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_GetGongFa.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_GetGongFa;
})();

$root.C2S_AddMenPaiSkillNumID = (function() {

    /**
     * Properties of a C2S_AddMenPaiSkillNumID.
     * @exports IC2S_AddMenPaiSkillNumID
     * @interface IC2S_AddMenPaiSkillNumID
     */

    /**
     * Constructs a new C2S_AddMenPaiSkillNumID.
     * @exports C2S_AddMenPaiSkillNumID
     * @classdesc Represents a C2S_AddMenPaiSkillNumID.
     * @implements IC2S_AddMenPaiSkillNumID
     * @constructor
     * @param {IC2S_AddMenPaiSkillNumID=} [properties] Properties to set
     */
    function C2S_AddMenPaiSkillNumID(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_AddMenPaiSkillNumID instance using the specified properties.
     * @function create
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {IC2S_AddMenPaiSkillNumID=} [properties] Properties to set
     * @returns {C2S_AddMenPaiSkillNumID} C2S_AddMenPaiSkillNumID instance
     */
    C2S_AddMenPaiSkillNumID.create = function create(properties) {
        return new C2S_AddMenPaiSkillNumID(properties);
    };

    /**
     * Encodes the specified C2S_AddMenPaiSkillNumID message. Does not implicitly {@link C2S_AddMenPaiSkillNumID.verify|verify} messages.
     * @function encode
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {IC2S_AddMenPaiSkillNumID} message C2S_AddMenPaiSkillNumID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_AddMenPaiSkillNumID.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_AddMenPaiSkillNumID message, length delimited. Does not implicitly {@link C2S_AddMenPaiSkillNumID.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {IC2S_AddMenPaiSkillNumID} message C2S_AddMenPaiSkillNumID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_AddMenPaiSkillNumID.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_AddMenPaiSkillNumID message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_AddMenPaiSkillNumID} C2S_AddMenPaiSkillNumID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_AddMenPaiSkillNumID.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_AddMenPaiSkillNumID();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_AddMenPaiSkillNumID message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_AddMenPaiSkillNumID} C2S_AddMenPaiSkillNumID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_AddMenPaiSkillNumID.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_AddMenPaiSkillNumID message.
     * @function verify
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_AddMenPaiSkillNumID.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_AddMenPaiSkillNumID message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_AddMenPaiSkillNumID} C2S_AddMenPaiSkillNumID
     */
    C2S_AddMenPaiSkillNumID.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_AddMenPaiSkillNumID)
            return object;
        return new $root.C2S_AddMenPaiSkillNumID();
    };

    /**
     * Creates a plain object from a C2S_AddMenPaiSkillNumID message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_AddMenPaiSkillNumID
     * @static
     * @param {C2S_AddMenPaiSkillNumID} message C2S_AddMenPaiSkillNumID
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_AddMenPaiSkillNumID.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_AddMenPaiSkillNumID to JSON.
     * @function toJSON
     * @memberof C2S_AddMenPaiSkillNumID
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_AddMenPaiSkillNumID.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_AddMenPaiSkillNumID;
})();

$root.S2C_AddMenPaiSkillNumID = (function() {

    /**
     * Properties of a S2C_AddMenPaiSkillNumID.
     * @exports IS2C_AddMenPaiSkillNumID
     * @interface IS2C_AddMenPaiSkillNumID
     * @property {number} skillNumID S2C_AddMenPaiSkillNumID skillNumID
     */

    /**
     * Constructs a new S2C_AddMenPaiSkillNumID.
     * @exports S2C_AddMenPaiSkillNumID
     * @classdesc Represents a S2C_AddMenPaiSkillNumID.
     * @implements IS2C_AddMenPaiSkillNumID
     * @constructor
     * @param {IS2C_AddMenPaiSkillNumID=} [properties] Properties to set
     */
    function S2C_AddMenPaiSkillNumID(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_AddMenPaiSkillNumID skillNumID.
     * @member {number} skillNumID
     * @memberof S2C_AddMenPaiSkillNumID
     * @instance
     */
    S2C_AddMenPaiSkillNumID.prototype.skillNumID = 0;

    /**
     * Creates a new S2C_AddMenPaiSkillNumID instance using the specified properties.
     * @function create
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {IS2C_AddMenPaiSkillNumID=} [properties] Properties to set
     * @returns {S2C_AddMenPaiSkillNumID} S2C_AddMenPaiSkillNumID instance
     */
    S2C_AddMenPaiSkillNumID.create = function create(properties) {
        return new S2C_AddMenPaiSkillNumID(properties);
    };

    /**
     * Encodes the specified S2C_AddMenPaiSkillNumID message. Does not implicitly {@link S2C_AddMenPaiSkillNumID.verify|verify} messages.
     * @function encode
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {IS2C_AddMenPaiSkillNumID} message S2C_AddMenPaiSkillNumID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_AddMenPaiSkillNumID.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.skillNumID);
        return writer;
    };

    /**
     * Encodes the specified S2C_AddMenPaiSkillNumID message, length delimited. Does not implicitly {@link S2C_AddMenPaiSkillNumID.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {IS2C_AddMenPaiSkillNumID} message S2C_AddMenPaiSkillNumID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_AddMenPaiSkillNumID.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_AddMenPaiSkillNumID message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_AddMenPaiSkillNumID} S2C_AddMenPaiSkillNumID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_AddMenPaiSkillNumID.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_AddMenPaiSkillNumID();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.skillNumID = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("skillNumID"))
            throw $util.ProtocolError("missing required 'skillNumID'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_AddMenPaiSkillNumID message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_AddMenPaiSkillNumID} S2C_AddMenPaiSkillNumID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_AddMenPaiSkillNumID.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_AddMenPaiSkillNumID message.
     * @function verify
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_AddMenPaiSkillNumID.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.skillNumID))
            return "skillNumID: integer expected";
        return null;
    };

    /**
     * Creates a S2C_AddMenPaiSkillNumID message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_AddMenPaiSkillNumID} S2C_AddMenPaiSkillNumID
     */
    S2C_AddMenPaiSkillNumID.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_AddMenPaiSkillNumID)
            return object;
        var message = new $root.S2C_AddMenPaiSkillNumID();
        if (object.skillNumID != null)
            message.skillNumID = object.skillNumID | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_AddMenPaiSkillNumID message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_AddMenPaiSkillNumID
     * @static
     * @param {S2C_AddMenPaiSkillNumID} message S2C_AddMenPaiSkillNumID
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_AddMenPaiSkillNumID.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.skillNumID = 0;
        if (message.skillNumID != null && message.hasOwnProperty("skillNumID"))
            object.skillNumID = message.skillNumID;
        return object;
    };

    /**
     * Converts this S2C_AddMenPaiSkillNumID to JSON.
     * @function toJSON
     * @memberof S2C_AddMenPaiSkillNumID
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_AddMenPaiSkillNumID.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_AddMenPaiSkillNumID;
})();

$root.C2S_GongFaChange = (function() {

    /**
     * Properties of a C2S_GongFaChange.
     * @exports IC2S_GongFaChange
     * @interface IC2S_GongFaChange
     * @property {GongFaCmdType} operateType C2S_GongFaChange operateType
     * @property {number} gongFaType C2S_GongFaChange gongFaType
     * @property {number} id C2S_GongFaChange id
     */

    /**
     * Constructs a new C2S_GongFaChange.
     * @exports C2S_GongFaChange
     * @classdesc Represents a C2S_GongFaChange.
     * @implements IC2S_GongFaChange
     * @constructor
     * @param {IC2S_GongFaChange=} [properties] Properties to set
     */
    function C2S_GongFaChange(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_GongFaChange operateType.
     * @member {GongFaCmdType} operateType
     * @memberof C2S_GongFaChange
     * @instance
     */
    C2S_GongFaChange.prototype.operateType = 1;

    /**
     * C2S_GongFaChange gongFaType.
     * @member {number} gongFaType
     * @memberof C2S_GongFaChange
     * @instance
     */
    C2S_GongFaChange.prototype.gongFaType = 0;

    /**
     * C2S_GongFaChange id.
     * @member {number} id
     * @memberof C2S_GongFaChange
     * @instance
     */
    C2S_GongFaChange.prototype.id = 0;

    /**
     * Creates a new C2S_GongFaChange instance using the specified properties.
     * @function create
     * @memberof C2S_GongFaChange
     * @static
     * @param {IC2S_GongFaChange=} [properties] Properties to set
     * @returns {C2S_GongFaChange} C2S_GongFaChange instance
     */
    C2S_GongFaChange.create = function create(properties) {
        return new C2S_GongFaChange(properties);
    };

    /**
     * Encodes the specified C2S_GongFaChange message. Does not implicitly {@link C2S_GongFaChange.verify|verify} messages.
     * @function encode
     * @memberof C2S_GongFaChange
     * @static
     * @param {IC2S_GongFaChange} message C2S_GongFaChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GongFaChange.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operateType);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gongFaType);
        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_GongFaChange message, length delimited. Does not implicitly {@link C2S_GongFaChange.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_GongFaChange
     * @static
     * @param {IC2S_GongFaChange} message C2S_GongFaChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GongFaChange.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_GongFaChange message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_GongFaChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_GongFaChange} C2S_GongFaChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GongFaChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_GongFaChange();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.operateType = reader.int32();
                break;
            case 2:
                message.gongFaType = reader.int32();
                break;
            case 3:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("operateType"))
            throw $util.ProtocolError("missing required 'operateType'", { instance: message });
        if (!message.hasOwnProperty("gongFaType"))
            throw $util.ProtocolError("missing required 'gongFaType'", { instance: message });
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_GongFaChange message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_GongFaChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_GongFaChange} C2S_GongFaChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GongFaChange.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_GongFaChange message.
     * @function verify
     * @memberof C2S_GongFaChange
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_GongFaChange.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.operateType) {
        default:
            return "operateType: enum value expected";
        case 1:
        case 2:
        case 3:
        case 4:
            break;
        }
        if (!$util.isInteger(message.gongFaType))
            return "gongFaType: integer expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_GongFaChange message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_GongFaChange
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_GongFaChange} C2S_GongFaChange
     */
    C2S_GongFaChange.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_GongFaChange)
            return object;
        var message = new $root.C2S_GongFaChange();
        switch (object.operateType) {
        case "AddSkill":
        case 1:
            message.operateType = 1;
            break;
        case "UpGradeSkill":
        case 2:
            message.operateType = 2;
            break;
        case "DeleteMenPaiSkill":
        case 3:
            message.operateType = 3;
            break;
        case "ChangeZhaoShi":
        case 4:
            message.operateType = 4;
            break;
        }
        if (object.gongFaType != null)
            message.gongFaType = object.gongFaType | 0;
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_GongFaChange message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_GongFaChange
     * @static
     * @param {C2S_GongFaChange} message C2S_GongFaChange
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_GongFaChange.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.operateType = options.enums === String ? "AddSkill" : 1;
            object.gongFaType = 0;
            object.id = 0;
        }
        if (message.operateType != null && message.hasOwnProperty("operateType"))
            object.operateType = options.enums === String ? $root.GongFaCmdType[message.operateType] : message.operateType;
        if (message.gongFaType != null && message.hasOwnProperty("gongFaType"))
            object.gongFaType = message.gongFaType;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_GongFaChange to JSON.
     * @function toJSON
     * @memberof C2S_GongFaChange
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_GongFaChange.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_GongFaChange;
})();

$root.S2C_GongFaChange = (function() {

    /**
     * Properties of a S2C_GongFaChange.
     * @exports IS2C_GongFaChange
     * @interface IS2C_GongFaChange
     * @property {GongFaCmdType} operateType S2C_GongFaChange operateType
     * @property {IGongFaInfoPB} gongFaInfo S2C_GongFaChange gongFaInfo
     * @property {number|null} [zhaoShi] S2C_GongFaChange zhaoShi
     */

    /**
     * Constructs a new S2C_GongFaChange.
     * @exports S2C_GongFaChange
     * @classdesc Represents a S2C_GongFaChange.
     * @implements IS2C_GongFaChange
     * @constructor
     * @param {IS2C_GongFaChange=} [properties] Properties to set
     */
    function S2C_GongFaChange(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_GongFaChange operateType.
     * @member {GongFaCmdType} operateType
     * @memberof S2C_GongFaChange
     * @instance
     */
    S2C_GongFaChange.prototype.operateType = 1;

    /**
     * S2C_GongFaChange gongFaInfo.
     * @member {IGongFaInfoPB} gongFaInfo
     * @memberof S2C_GongFaChange
     * @instance
     */
    S2C_GongFaChange.prototype.gongFaInfo = null;

    /**
     * S2C_GongFaChange zhaoShi.
     * @member {number} zhaoShi
     * @memberof S2C_GongFaChange
     * @instance
     */
    S2C_GongFaChange.prototype.zhaoShi = 0;

    /**
     * Creates a new S2C_GongFaChange instance using the specified properties.
     * @function create
     * @memberof S2C_GongFaChange
     * @static
     * @param {IS2C_GongFaChange=} [properties] Properties to set
     * @returns {S2C_GongFaChange} S2C_GongFaChange instance
     */
    S2C_GongFaChange.create = function create(properties) {
        return new S2C_GongFaChange(properties);
    };

    /**
     * Encodes the specified S2C_GongFaChange message. Does not implicitly {@link S2C_GongFaChange.verify|verify} messages.
     * @function encode
     * @memberof S2C_GongFaChange
     * @static
     * @param {IS2C_GongFaChange} message S2C_GongFaChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GongFaChange.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operateType);
        $root.GongFaInfoPB.encode(message.gongFaInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.zhaoShi != null && message.hasOwnProperty("zhaoShi"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.zhaoShi);
        return writer;
    };

    /**
     * Encodes the specified S2C_GongFaChange message, length delimited. Does not implicitly {@link S2C_GongFaChange.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_GongFaChange
     * @static
     * @param {IS2C_GongFaChange} message S2C_GongFaChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GongFaChange.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_GongFaChange message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_GongFaChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_GongFaChange} S2C_GongFaChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GongFaChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_GongFaChange();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.operateType = reader.int32();
                break;
            case 2:
                message.gongFaInfo = $root.GongFaInfoPB.decode(reader, reader.uint32());
                break;
            case 3:
                message.zhaoShi = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("operateType"))
            throw $util.ProtocolError("missing required 'operateType'", { instance: message });
        if (!message.hasOwnProperty("gongFaInfo"))
            throw $util.ProtocolError("missing required 'gongFaInfo'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_GongFaChange message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_GongFaChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_GongFaChange} S2C_GongFaChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GongFaChange.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_GongFaChange message.
     * @function verify
     * @memberof S2C_GongFaChange
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_GongFaChange.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.operateType) {
        default:
            return "operateType: enum value expected";
        case 1:
        case 2:
        case 3:
        case 4:
            break;
        }
        {
            var error = $root.GongFaInfoPB.verify(message.gongFaInfo);
            if (error)
                return "gongFaInfo." + error;
        }
        if (message.zhaoShi != null && message.hasOwnProperty("zhaoShi"))
            if (!$util.isInteger(message.zhaoShi))
                return "zhaoShi: integer expected";
        return null;
    };

    /**
     * Creates a S2C_GongFaChange message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_GongFaChange
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_GongFaChange} S2C_GongFaChange
     */
    S2C_GongFaChange.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_GongFaChange)
            return object;
        var message = new $root.S2C_GongFaChange();
        switch (object.operateType) {
        case "AddSkill":
        case 1:
            message.operateType = 1;
            break;
        case "UpGradeSkill":
        case 2:
            message.operateType = 2;
            break;
        case "DeleteMenPaiSkill":
        case 3:
            message.operateType = 3;
            break;
        case "ChangeZhaoShi":
        case 4:
            message.operateType = 4;
            break;
        }
        if (object.gongFaInfo != null) {
            if (typeof object.gongFaInfo !== "object")
                throw TypeError(".S2C_GongFaChange.gongFaInfo: object expected");
            message.gongFaInfo = $root.GongFaInfoPB.fromObject(object.gongFaInfo);
        }
        if (object.zhaoShi != null)
            message.zhaoShi = object.zhaoShi | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_GongFaChange message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_GongFaChange
     * @static
     * @param {S2C_GongFaChange} message S2C_GongFaChange
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_GongFaChange.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.operateType = options.enums === String ? "AddSkill" : 1;
            object.gongFaInfo = null;
            object.zhaoShi = 0;
        }
        if (message.operateType != null && message.hasOwnProperty("operateType"))
            object.operateType = options.enums === String ? $root.GongFaCmdType[message.operateType] : message.operateType;
        if (message.gongFaInfo != null && message.hasOwnProperty("gongFaInfo"))
            object.gongFaInfo = $root.GongFaInfoPB.toObject(message.gongFaInfo, options);
        if (message.zhaoShi != null && message.hasOwnProperty("zhaoShi"))
            object.zhaoShi = message.zhaoShi;
        return object;
    };

    /**
     * Converts this S2C_GongFaChange to JSON.
     * @function toJSON
     * @memberof S2C_GongFaChange
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_GongFaChange.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_GongFaChange;
})();

/**
 * GongFaType enum.
 * @exports GongFaType
 * @enum {string}
 * @property {number} XinJing=5 XinJing value
 * @property {number} ZhaoShi=1 ZhaoShi value
 * @property {number} MiJi=2 MiJi value
 * @property {number} DunShu=3 DunShu value
 * @property {number} JueXue=4 JueXue value
 * @property {number} ZhenJue=6 ZhenJue value
 * @property {number} CanYe=7 CanYe value
 * @property {number} MenPai=8 MenPai value
 */
$root.GongFaType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[5] = "XinJing"] = 5;
    values[valuesById[1] = "ZhaoShi"] = 1;
    values[valuesById[2] = "MiJi"] = 2;
    values[valuesById[3] = "DunShu"] = 3;
    values[valuesById[4] = "JueXue"] = 4;
    values[valuesById[6] = "ZhenJue"] = 6;
    values[valuesById[7] = "CanYe"] = 7;
    values[valuesById[8] = "MenPai"] = 8;
    return values;
})();

/**
 * GongFaCmdType enum.
 * @exports GongFaCmdType
 * @enum {string}
 * @property {number} AddSkill=1 AddSkill value
 * @property {number} UpGradeSkill=2 UpGradeSkill value
 * @property {number} DeleteMenPaiSkill=3 DeleteMenPaiSkill value
 * @property {number} ChangeZhaoShi=4 ChangeZhaoShi value
 */
$root.GongFaCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "AddSkill"] = 1;
    values[valuesById[2] = "UpGradeSkill"] = 2;
    values[valuesById[3] = "DeleteMenPaiSkill"] = 3;
    values[valuesById[4] = "ChangeZhaoShi"] = 4;
    return values;
})();

$root.GongFaInfoPB = (function() {

    /**
     * Properties of a GongFaInfoPB.
     * @exports IGongFaInfoPB
     * @interface IGongFaInfoPB
     * @property {number} gongFaType GongFaInfoPB gongFaType
     * @property {number} id GongFaInfoPB id
     * @property {number|null} [level] GongFaInfoPB level
     */

    /**
     * Constructs a new GongFaInfoPB.
     * @exports GongFaInfoPB
     * @classdesc Represents a GongFaInfoPB.
     * @implements IGongFaInfoPB
     * @constructor
     * @param {IGongFaInfoPB=} [properties] Properties to set
     */
    function GongFaInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GongFaInfoPB gongFaType.
     * @member {number} gongFaType
     * @memberof GongFaInfoPB
     * @instance
     */
    GongFaInfoPB.prototype.gongFaType = 0;

    /**
     * GongFaInfoPB id.
     * @member {number} id
     * @memberof GongFaInfoPB
     * @instance
     */
    GongFaInfoPB.prototype.id = 0;

    /**
     * GongFaInfoPB level.
     * @member {number} level
     * @memberof GongFaInfoPB
     * @instance
     */
    GongFaInfoPB.prototype.level = 0;

    /**
     * Creates a new GongFaInfoPB instance using the specified properties.
     * @function create
     * @memberof GongFaInfoPB
     * @static
     * @param {IGongFaInfoPB=} [properties] Properties to set
     * @returns {GongFaInfoPB} GongFaInfoPB instance
     */
    GongFaInfoPB.create = function create(properties) {
        return new GongFaInfoPB(properties);
    };

    /**
     * Encodes the specified GongFaInfoPB message. Does not implicitly {@link GongFaInfoPB.verify|verify} messages.
     * @function encode
     * @memberof GongFaInfoPB
     * @static
     * @param {IGongFaInfoPB} message GongFaInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GongFaInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gongFaType);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
        return writer;
    };

    /**
     * Encodes the specified GongFaInfoPB message, length delimited. Does not implicitly {@link GongFaInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GongFaInfoPB
     * @static
     * @param {IGongFaInfoPB} message GongFaInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GongFaInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GongFaInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof GongFaInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GongFaInfoPB} GongFaInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GongFaInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GongFaInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.gongFaType = reader.int32();
                break;
            case 2:
                message.id = reader.int32();
                break;
            case 3:
                message.level = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("gongFaType"))
            throw $util.ProtocolError("missing required 'gongFaType'", { instance: message });
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a GongFaInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GongFaInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GongFaInfoPB} GongFaInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GongFaInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GongFaInfoPB message.
     * @function verify
     * @memberof GongFaInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GongFaInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.gongFaType))
            return "gongFaType: integer expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        return null;
    };

    /**
     * Creates a GongFaInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GongFaInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GongFaInfoPB} GongFaInfoPB
     */
    GongFaInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.GongFaInfoPB)
            return object;
        var message = new $root.GongFaInfoPB();
        if (object.gongFaType != null)
            message.gongFaType = object.gongFaType | 0;
        if (object.id != null)
            message.id = object.id | 0;
        if (object.level != null)
            message.level = object.level | 0;
        return message;
    };

    /**
     * Creates a plain object from a GongFaInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GongFaInfoPB
     * @static
     * @param {GongFaInfoPB} message GongFaInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GongFaInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.gongFaType = 0;
            object.id = 0;
            object.level = 0;
        }
        if (message.gongFaType != null && message.hasOwnProperty("gongFaType"))
            object.gongFaType = message.gongFaType;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        return object;
    };

    /**
     * Converts this GongFaInfoPB to JSON.
     * @function toJSON
     * @memberof GongFaInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GongFaInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GongFaInfoPB;
})();

/**
 * JiYuanTriggerType enum.
 * @exports JiYuanTriggerType
 * @enum {string}
 * @property {number} Level=1 Level value
 * @property {number} Properties=2 Properties value
 */
$root.JiYuanTriggerType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "Level"] = 1;
    values[valuesById[2] = "Properties"] = 2;
    return values;
})();

/**
 * JiYuanType enum.
 * @exports JiYuanType
 * @enum {string}
 * @property {number} GuDing=1 GuDing value
 * @property {number} DaoLv=2 DaoLv value
 * @property {number} MenPai=3 MenPai value
 * @property {number} DuBo=4 DuBo value
 * @property {number} QiYu=5 QiYu value
 */
$root.JiYuanType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "GuDing"] = 1;
    values[valuesById[2] = "DaoLv"] = 2;
    values[valuesById[3] = "MenPai"] = 3;
    values[valuesById[4] = "DuBo"] = 4;
    values[valuesById[5] = "QiYu"] = 5;
    return values;
})();

$root.C2S_GetJiYuan = (function() {

    /**
     * Properties of a C2S_GetJiYuan.
     * @exports IC2S_GetJiYuan
     * @interface IC2S_GetJiYuan
     */

    /**
     * Constructs a new C2S_GetJiYuan.
     * @exports C2S_GetJiYuan
     * @classdesc Represents a C2S_GetJiYuan.
     * @implements IC2S_GetJiYuan
     * @constructor
     * @param {IC2S_GetJiYuan=} [properties] Properties to set
     */
    function C2S_GetJiYuan(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_GetJiYuan instance using the specified properties.
     * @function create
     * @memberof C2S_GetJiYuan
     * @static
     * @param {IC2S_GetJiYuan=} [properties] Properties to set
     * @returns {C2S_GetJiYuan} C2S_GetJiYuan instance
     */
    C2S_GetJiYuan.create = function create(properties) {
        return new C2S_GetJiYuan(properties);
    };

    /**
     * Encodes the specified C2S_GetJiYuan message. Does not implicitly {@link C2S_GetJiYuan.verify|verify} messages.
     * @function encode
     * @memberof C2S_GetJiYuan
     * @static
     * @param {IC2S_GetJiYuan} message C2S_GetJiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetJiYuan.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_GetJiYuan message, length delimited. Does not implicitly {@link C2S_GetJiYuan.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_GetJiYuan
     * @static
     * @param {IC2S_GetJiYuan} message C2S_GetJiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetJiYuan.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_GetJiYuan message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_GetJiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_GetJiYuan} C2S_GetJiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetJiYuan.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_GetJiYuan();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_GetJiYuan message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_GetJiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_GetJiYuan} C2S_GetJiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetJiYuan.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_GetJiYuan message.
     * @function verify
     * @memberof C2S_GetJiYuan
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_GetJiYuan.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_GetJiYuan message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_GetJiYuan
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_GetJiYuan} C2S_GetJiYuan
     */
    C2S_GetJiYuan.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_GetJiYuan)
            return object;
        return new $root.C2S_GetJiYuan();
    };

    /**
     * Creates a plain object from a C2S_GetJiYuan message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_GetJiYuan
     * @static
     * @param {C2S_GetJiYuan} message C2S_GetJiYuan
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_GetJiYuan.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_GetJiYuan to JSON.
     * @function toJSON
     * @memberof C2S_GetJiYuan
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_GetJiYuan.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_GetJiYuan;
})();

$root.S2C_GetJiYuan = (function() {

    /**
     * Properties of a S2C_GetJiYuan.
     * @exports IS2C_GetJiYuan
     * @interface IS2C_GetJiYuan
     * @property {Array.<IJiYuanInfoPB>|null} [infos] S2C_GetJiYuan infos
     */

    /**
     * Constructs a new S2C_GetJiYuan.
     * @exports S2C_GetJiYuan
     * @classdesc Represents a S2C_GetJiYuan.
     * @implements IS2C_GetJiYuan
     * @constructor
     * @param {IS2C_GetJiYuan=} [properties] Properties to set
     */
    function S2C_GetJiYuan(properties) {
        this.infos = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_GetJiYuan infos.
     * @member {Array.<IJiYuanInfoPB>} infos
     * @memberof S2C_GetJiYuan
     * @instance
     */
    S2C_GetJiYuan.prototype.infos = $util.emptyArray;

    /**
     * Creates a new S2C_GetJiYuan instance using the specified properties.
     * @function create
     * @memberof S2C_GetJiYuan
     * @static
     * @param {IS2C_GetJiYuan=} [properties] Properties to set
     * @returns {S2C_GetJiYuan} S2C_GetJiYuan instance
     */
    S2C_GetJiYuan.create = function create(properties) {
        return new S2C_GetJiYuan(properties);
    };

    /**
     * Encodes the specified S2C_GetJiYuan message. Does not implicitly {@link S2C_GetJiYuan.verify|verify} messages.
     * @function encode
     * @memberof S2C_GetJiYuan
     * @static
     * @param {IS2C_GetJiYuan} message S2C_GetJiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetJiYuan.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.infos != null && message.infos.length)
            for (var i = 0; i < message.infos.length; ++i)
                $root.JiYuanInfoPB.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_GetJiYuan message, length delimited. Does not implicitly {@link S2C_GetJiYuan.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_GetJiYuan
     * @static
     * @param {IS2C_GetJiYuan} message S2C_GetJiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetJiYuan.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_GetJiYuan message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_GetJiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_GetJiYuan} S2C_GetJiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetJiYuan.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_GetJiYuan();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.infos && message.infos.length))
                    message.infos = [];
                message.infos.push($root.JiYuanInfoPB.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_GetJiYuan message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_GetJiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_GetJiYuan} S2C_GetJiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetJiYuan.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_GetJiYuan message.
     * @function verify
     * @memberof S2C_GetJiYuan
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_GetJiYuan.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.infos != null && message.hasOwnProperty("infos")) {
            if (!Array.isArray(message.infos))
                return "infos: array expected";
            for (var i = 0; i < message.infos.length; ++i) {
                var error = $root.JiYuanInfoPB.verify(message.infos[i]);
                if (error)
                    return "infos." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_GetJiYuan message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_GetJiYuan
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_GetJiYuan} S2C_GetJiYuan
     */
    S2C_GetJiYuan.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_GetJiYuan)
            return object;
        var message = new $root.S2C_GetJiYuan();
        if (object.infos) {
            if (!Array.isArray(object.infos))
                throw TypeError(".S2C_GetJiYuan.infos: array expected");
            message.infos = [];
            for (var i = 0; i < object.infos.length; ++i) {
                if (typeof object.infos[i] !== "object")
                    throw TypeError(".S2C_GetJiYuan.infos: object expected");
                message.infos[i] = $root.JiYuanInfoPB.fromObject(object.infos[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_GetJiYuan message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_GetJiYuan
     * @static
     * @param {S2C_GetJiYuan} message S2C_GetJiYuan
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_GetJiYuan.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.infos = [];
        if (message.infos && message.infos.length) {
            object.infos = [];
            for (var j = 0; j < message.infos.length; ++j)
                object.infos[j] = $root.JiYuanInfoPB.toObject(message.infos[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_GetJiYuan to JSON.
     * @function toJSON
     * @memberof S2C_GetJiYuan
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_GetJiYuan.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_GetJiYuan;
})();

$root.C2S_JiYuan = (function() {

    /**
     * Properties of a C2S_JiYuan.
     * @exports IC2S_JiYuan
     * @interface IC2S_JiYuan
     * @property {IJiYuanInfoPB} info C2S_JiYuan info
     * @property {number} index C2S_JiYuan index
     */

    /**
     * Constructs a new C2S_JiYuan.
     * @exports C2S_JiYuan
     * @classdesc Represents a C2S_JiYuan.
     * @implements IC2S_JiYuan
     * @constructor
     * @param {IC2S_JiYuan=} [properties] Properties to set
     */
    function C2S_JiYuan(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_JiYuan info.
     * @member {IJiYuanInfoPB} info
     * @memberof C2S_JiYuan
     * @instance
     */
    C2S_JiYuan.prototype.info = null;

    /**
     * C2S_JiYuan index.
     * @member {number} index
     * @memberof C2S_JiYuan
     * @instance
     */
    C2S_JiYuan.prototype.index = 0;

    /**
     * Creates a new C2S_JiYuan instance using the specified properties.
     * @function create
     * @memberof C2S_JiYuan
     * @static
     * @param {IC2S_JiYuan=} [properties] Properties to set
     * @returns {C2S_JiYuan} C2S_JiYuan instance
     */
    C2S_JiYuan.create = function create(properties) {
        return new C2S_JiYuan(properties);
    };

    /**
     * Encodes the specified C2S_JiYuan message. Does not implicitly {@link C2S_JiYuan.verify|verify} messages.
     * @function encode
     * @memberof C2S_JiYuan
     * @static
     * @param {IC2S_JiYuan} message C2S_JiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_JiYuan.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        $root.JiYuanInfoPB.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
        return writer;
    };

    /**
     * Encodes the specified C2S_JiYuan message, length delimited. Does not implicitly {@link C2S_JiYuan.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_JiYuan
     * @static
     * @param {IC2S_JiYuan} message C2S_JiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_JiYuan.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_JiYuan message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_JiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_JiYuan} C2S_JiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_JiYuan.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_JiYuan();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.info = $root.JiYuanInfoPB.decode(reader, reader.uint32());
                break;
            case 2:
                message.index = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("info"))
            throw $util.ProtocolError("missing required 'info'", { instance: message });
        if (!message.hasOwnProperty("index"))
            throw $util.ProtocolError("missing required 'index'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_JiYuan message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_JiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_JiYuan} C2S_JiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_JiYuan.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_JiYuan message.
     * @function verify
     * @memberof C2S_JiYuan
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_JiYuan.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        {
            var error = $root.JiYuanInfoPB.verify(message.info);
            if (error)
                return "info." + error;
        }
        if (!$util.isInteger(message.index))
            return "index: integer expected";
        return null;
    };

    /**
     * Creates a C2S_JiYuan message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_JiYuan
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_JiYuan} C2S_JiYuan
     */
    C2S_JiYuan.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_JiYuan)
            return object;
        var message = new $root.C2S_JiYuan();
        if (object.info != null) {
            if (typeof object.info !== "object")
                throw TypeError(".C2S_JiYuan.info: object expected");
            message.info = $root.JiYuanInfoPB.fromObject(object.info);
        }
        if (object.index != null)
            message.index = object.index | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_JiYuan message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_JiYuan
     * @static
     * @param {C2S_JiYuan} message C2S_JiYuan
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_JiYuan.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.info = null;
            object.index = 0;
        }
        if (message.info != null && message.hasOwnProperty("info"))
            object.info = $root.JiYuanInfoPB.toObject(message.info, options);
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        return object;
    };

    /**
     * Converts this C2S_JiYuan to JSON.
     * @function toJSON
     * @memberof C2S_JiYuan
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_JiYuan.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_JiYuan;
})();

$root.S2C_JiYuan = (function() {

    /**
     * Properties of a S2C_JiYuan.
     * @exports IS2C_JiYuan
     * @interface IS2C_JiYuan
     * @property {Array.<IResourceMsg>|null} [cost] S2C_JiYuan cost
     * @property {Array.<IResourceMsg>|null} [resource] S2C_JiYuan resource
     * @property {number|null} [intimacy] S2C_JiYuan intimacy
     * @property {IJiYuanInfoPB|null} [info] S2C_JiYuan info
     * @property {number|null} [index] S2C_JiYuan index
     * @property {IFightResultMsg|null} [result] S2C_JiYuan result
     */

    /**
     * Constructs a new S2C_JiYuan.
     * @exports S2C_JiYuan
     * @classdesc Represents a S2C_JiYuan.
     * @implements IS2C_JiYuan
     * @constructor
     * @param {IS2C_JiYuan=} [properties] Properties to set
     */
    function S2C_JiYuan(properties) {
        this.cost = [];
        this.resource = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_JiYuan cost.
     * @member {Array.<IResourceMsg>} cost
     * @memberof S2C_JiYuan
     * @instance
     */
    S2C_JiYuan.prototype.cost = $util.emptyArray;

    /**
     * S2C_JiYuan resource.
     * @member {Array.<IResourceMsg>} resource
     * @memberof S2C_JiYuan
     * @instance
     */
    S2C_JiYuan.prototype.resource = $util.emptyArray;

    /**
     * S2C_JiYuan intimacy.
     * @member {number} intimacy
     * @memberof S2C_JiYuan
     * @instance
     */
    S2C_JiYuan.prototype.intimacy = 0;

    /**
     * S2C_JiYuan info.
     * @member {IJiYuanInfoPB|null|undefined} info
     * @memberof S2C_JiYuan
     * @instance
     */
    S2C_JiYuan.prototype.info = null;

    /**
     * S2C_JiYuan index.
     * @member {number} index
     * @memberof S2C_JiYuan
     * @instance
     */
    S2C_JiYuan.prototype.index = 0;

    /**
     * S2C_JiYuan result.
     * @member {IFightResultMsg|null|undefined} result
     * @memberof S2C_JiYuan
     * @instance
     */
    S2C_JiYuan.prototype.result = null;

    /**
     * Creates a new S2C_JiYuan instance using the specified properties.
     * @function create
     * @memberof S2C_JiYuan
     * @static
     * @param {IS2C_JiYuan=} [properties] Properties to set
     * @returns {S2C_JiYuan} S2C_JiYuan instance
     */
    S2C_JiYuan.create = function create(properties) {
        return new S2C_JiYuan(properties);
    };

    /**
     * Encodes the specified S2C_JiYuan message. Does not implicitly {@link S2C_JiYuan.verify|verify} messages.
     * @function encode
     * @memberof S2C_JiYuan
     * @static
     * @param {IS2C_JiYuan} message S2C_JiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_JiYuan.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.cost != null && message.cost.length)
            for (var i = 0; i < message.cost.length; ++i)
                $root.ResourceMsg.encode(message.cost[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.resource != null && message.resource.length)
            for (var i = 0; i < message.resource.length; ++i)
                $root.ResourceMsg.encode(message.resource[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.intimacy != null && message.hasOwnProperty("intimacy"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.intimacy);
        if (message.info != null && message.hasOwnProperty("info"))
            $root.JiYuanInfoPB.encode(message.info, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.index != null && message.hasOwnProperty("index"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.index);
        if (message.result != null && message.hasOwnProperty("result"))
            $root.FightResultMsg.encode(message.result, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_JiYuan message, length delimited. Does not implicitly {@link S2C_JiYuan.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_JiYuan
     * @static
     * @param {IS2C_JiYuan} message S2C_JiYuan message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_JiYuan.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_JiYuan message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_JiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_JiYuan} S2C_JiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_JiYuan.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_JiYuan();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.cost && message.cost.length))
                    message.cost = [];
                message.cost.push($root.ResourceMsg.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.resource && message.resource.length))
                    message.resource = [];
                message.resource.push($root.ResourceMsg.decode(reader, reader.uint32()));
                break;
            case 3:
                message.intimacy = reader.int32();
                break;
            case 4:
                message.info = $root.JiYuanInfoPB.decode(reader, reader.uint32());
                break;
            case 5:
                message.index = reader.int32();
                break;
            case 6:
                message.result = $root.FightResultMsg.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_JiYuan message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_JiYuan
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_JiYuan} S2C_JiYuan
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_JiYuan.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_JiYuan message.
     * @function verify
     * @memberof S2C_JiYuan
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_JiYuan.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.cost != null && message.hasOwnProperty("cost")) {
            if (!Array.isArray(message.cost))
                return "cost: array expected";
            for (var i = 0; i < message.cost.length; ++i) {
                var error = $root.ResourceMsg.verify(message.cost[i]);
                if (error)
                    return "cost." + error;
            }
        }
        if (message.resource != null && message.hasOwnProperty("resource")) {
            if (!Array.isArray(message.resource))
                return "resource: array expected";
            for (var i = 0; i < message.resource.length; ++i) {
                var error = $root.ResourceMsg.verify(message.resource[i]);
                if (error)
                    return "resource." + error;
            }
        }
        if (message.intimacy != null && message.hasOwnProperty("intimacy"))
            if (!$util.isInteger(message.intimacy))
                return "intimacy: integer expected";
        if (message.info != null && message.hasOwnProperty("info")) {
            var error = $root.JiYuanInfoPB.verify(message.info);
            if (error)
                return "info." + error;
        }
        if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index))
                return "index: integer expected";
        if (message.result != null && message.hasOwnProperty("result")) {
            var error = $root.FightResultMsg.verify(message.result);
            if (error)
                return "result." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_JiYuan message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_JiYuan
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_JiYuan} S2C_JiYuan
     */
    S2C_JiYuan.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_JiYuan)
            return object;
        var message = new $root.S2C_JiYuan();
        if (object.cost) {
            if (!Array.isArray(object.cost))
                throw TypeError(".S2C_JiYuan.cost: array expected");
            message.cost = [];
            for (var i = 0; i < object.cost.length; ++i) {
                if (typeof object.cost[i] !== "object")
                    throw TypeError(".S2C_JiYuan.cost: object expected");
                message.cost[i] = $root.ResourceMsg.fromObject(object.cost[i]);
            }
        }
        if (object.resource) {
            if (!Array.isArray(object.resource))
                throw TypeError(".S2C_JiYuan.resource: array expected");
            message.resource = [];
            for (var i = 0; i < object.resource.length; ++i) {
                if (typeof object.resource[i] !== "object")
                    throw TypeError(".S2C_JiYuan.resource: object expected");
                message.resource[i] = $root.ResourceMsg.fromObject(object.resource[i]);
            }
        }
        if (object.intimacy != null)
            message.intimacy = object.intimacy | 0;
        if (object.info != null) {
            if (typeof object.info !== "object")
                throw TypeError(".S2C_JiYuan.info: object expected");
            message.info = $root.JiYuanInfoPB.fromObject(object.info);
        }
        if (object.index != null)
            message.index = object.index | 0;
        if (object.result != null) {
            if (typeof object.result !== "object")
                throw TypeError(".S2C_JiYuan.result: object expected");
            message.result = $root.FightResultMsg.fromObject(object.result);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_JiYuan message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_JiYuan
     * @static
     * @param {S2C_JiYuan} message S2C_JiYuan
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_JiYuan.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.cost = [];
            object.resource = [];
        }
        if (options.defaults) {
            object.intimacy = 0;
            object.info = null;
            object.index = 0;
            object.result = null;
        }
        if (message.cost && message.cost.length) {
            object.cost = [];
            for (var j = 0; j < message.cost.length; ++j)
                object.cost[j] = $root.ResourceMsg.toObject(message.cost[j], options);
        }
        if (message.resource && message.resource.length) {
            object.resource = [];
            for (var j = 0; j < message.resource.length; ++j)
                object.resource[j] = $root.ResourceMsg.toObject(message.resource[j], options);
        }
        if (message.intimacy != null && message.hasOwnProperty("intimacy"))
            object.intimacy = message.intimacy;
        if (message.info != null && message.hasOwnProperty("info"))
            object.info = $root.JiYuanInfoPB.toObject(message.info, options);
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = $root.FightResultMsg.toObject(message.result, options);
        return object;
    };

    /**
     * Converts this S2C_JiYuan to JSON.
     * @function toJSON
     * @memberof S2C_JiYuan
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_JiYuan.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_JiYuan;
})();

/**
 * QiYuRewardType enum.
 * @exports QiYuRewardType
 * @enum {string}
 * @property {number} GetResource=1 GetResource value
 * @property {number} GetProp=2 GetProp value
 * @property {number} LossProp=3 LossProp value
 * @property {number} None=4 None value
 * @property {number} Fight=5 Fight value
 */
$root.QiYuRewardType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "GetResource"] = 1;
    values[valuesById[2] = "GetProp"] = 2;
    values[valuesById[3] = "LossProp"] = 3;
    values[valuesById[4] = "None"] = 4;
    values[valuesById[5] = "Fight"] = 5;
    return values;
})();

$root.JiYuanInfoPB = (function() {

    /**
     * Properties of a JiYuanInfoPB.
     * @exports IJiYuanInfoPB
     * @interface IJiYuanInfoPB
     * @property {number} type JiYuanInfoPB type
     * @property {number} id JiYuanInfoPB id
     * @property {number|null} [npcID] JiYuanInfoPB npcID
     */

    /**
     * Constructs a new JiYuanInfoPB.
     * @exports JiYuanInfoPB
     * @classdesc Represents a JiYuanInfoPB.
     * @implements IJiYuanInfoPB
     * @constructor
     * @param {IJiYuanInfoPB=} [properties] Properties to set
     */
    function JiYuanInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * JiYuanInfoPB type.
     * @member {number} type
     * @memberof JiYuanInfoPB
     * @instance
     */
    JiYuanInfoPB.prototype.type = 0;

    /**
     * JiYuanInfoPB id.
     * @member {number} id
     * @memberof JiYuanInfoPB
     * @instance
     */
    JiYuanInfoPB.prototype.id = 0;

    /**
     * JiYuanInfoPB npcID.
     * @member {number} npcID
     * @memberof JiYuanInfoPB
     * @instance
     */
    JiYuanInfoPB.prototype.npcID = 0;

    /**
     * Creates a new JiYuanInfoPB instance using the specified properties.
     * @function create
     * @memberof JiYuanInfoPB
     * @static
     * @param {IJiYuanInfoPB=} [properties] Properties to set
     * @returns {JiYuanInfoPB} JiYuanInfoPB instance
     */
    JiYuanInfoPB.create = function create(properties) {
        return new JiYuanInfoPB(properties);
    };

    /**
     * Encodes the specified JiYuanInfoPB message. Does not implicitly {@link JiYuanInfoPB.verify|verify} messages.
     * @function encode
     * @memberof JiYuanInfoPB
     * @static
     * @param {IJiYuanInfoPB} message JiYuanInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JiYuanInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
        if (message.npcID != null && message.hasOwnProperty("npcID"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.npcID);
        return writer;
    };

    /**
     * Encodes the specified JiYuanInfoPB message, length delimited. Does not implicitly {@link JiYuanInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof JiYuanInfoPB
     * @static
     * @param {IJiYuanInfoPB} message JiYuanInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JiYuanInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a JiYuanInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof JiYuanInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {JiYuanInfoPB} JiYuanInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JiYuanInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.JiYuanInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.id = reader.int32();
                break;
            case 3:
                message.npcID = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("type"))
            throw $util.ProtocolError("missing required 'type'", { instance: message });
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a JiYuanInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof JiYuanInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {JiYuanInfoPB} JiYuanInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JiYuanInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a JiYuanInfoPB message.
     * @function verify
     * @memberof JiYuanInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    JiYuanInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.type))
            return "type: integer expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        if (message.npcID != null && message.hasOwnProperty("npcID"))
            if (!$util.isInteger(message.npcID))
                return "npcID: integer expected";
        return null;
    };

    /**
     * Creates a JiYuanInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof JiYuanInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {JiYuanInfoPB} JiYuanInfoPB
     */
    JiYuanInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.JiYuanInfoPB)
            return object;
        var message = new $root.JiYuanInfoPB();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.id != null)
            message.id = object.id | 0;
        if (object.npcID != null)
            message.npcID = object.npcID | 0;
        return message;
    };

    /**
     * Creates a plain object from a JiYuanInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof JiYuanInfoPB
     * @static
     * @param {JiYuanInfoPB} message JiYuanInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    JiYuanInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            object.id = 0;
            object.npcID = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.npcID != null && message.hasOwnProperty("npcID"))
            object.npcID = message.npcID;
        return object;
    };

    /**
     * Converts this JiYuanInfoPB to JSON.
     * @function toJSON
     * @memberof JiYuanInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    JiYuanInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return JiYuanInfoPB;
})();

$root.MapInfo = (function() {

    /**
     * Properties of a MapInfo.
     * @exports IMapInfo
     * @interface IMapInfo
     * @property {number|null} [posX] MapInfo posX
     * @property {number|null} [posY] MapInfo posY
     */

    /**
     * Constructs a new MapInfo.
     * @exports MapInfo
     * @classdesc Represents a MapInfo.
     * @implements IMapInfo
     * @constructor
     * @param {IMapInfo=} [properties] Properties to set
     */
    function MapInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MapInfo posX.
     * @member {number} posX
     * @memberof MapInfo
     * @instance
     */
    MapInfo.prototype.posX = 0;

    /**
     * MapInfo posY.
     * @member {number} posY
     * @memberof MapInfo
     * @instance
     */
    MapInfo.prototype.posY = 0;

    /**
     * Creates a new MapInfo instance using the specified properties.
     * @function create
     * @memberof MapInfo
     * @static
     * @param {IMapInfo=} [properties] Properties to set
     * @returns {MapInfo} MapInfo instance
     */
    MapInfo.create = function create(properties) {
        return new MapInfo(properties);
    };

    /**
     * Encodes the specified MapInfo message. Does not implicitly {@link MapInfo.verify|verify} messages.
     * @function encode
     * @memberof MapInfo
     * @static
     * @param {IMapInfo} message MapInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MapInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.posX != null && message.hasOwnProperty("posX"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
        if (message.posY != null && message.hasOwnProperty("posY"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
        return writer;
    };

    /**
     * Encodes the specified MapInfo message, length delimited. Does not implicitly {@link MapInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MapInfo
     * @static
     * @param {IMapInfo} message MapInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MapInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MapInfo message from the specified reader or buffer.
     * @function decode
     * @memberof MapInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MapInfo} MapInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MapInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MapInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.posX = reader.int32();
                break;
            case 2:
                message.posY = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MapInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MapInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MapInfo} MapInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MapInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MapInfo message.
     * @function verify
     * @memberof MapInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MapInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.posX != null && message.hasOwnProperty("posX"))
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
        if (message.posY != null && message.hasOwnProperty("posY"))
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
        return null;
    };

    /**
     * Creates a MapInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MapInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MapInfo} MapInfo
     */
    MapInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.MapInfo)
            return object;
        var message = new $root.MapInfo();
        if (object.posX != null)
            message.posX = object.posX | 0;
        if (object.posY != null)
            message.posY = object.posY | 0;
        return message;
    };

    /**
     * Creates a plain object from a MapInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MapInfo
     * @static
     * @param {MapInfo} message MapInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MapInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.posX = 0;
            object.posY = 0;
        }
        if (message.posX != null && message.hasOwnProperty("posX"))
            object.posX = message.posX;
        if (message.posY != null && message.hasOwnProperty("posY"))
            object.posY = message.posY;
        return object;
    };

    /**
     * Converts this MapInfo to JSON.
     * @function toJSON
     * @memberof MapInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MapInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MapInfo;
})();

$root.C2S_LilianMap = (function() {

    /**
     * Properties of a C2S_LilianMap.
     * @exports IC2S_LilianMap
     * @interface IC2S_LilianMap
     */

    /**
     * Constructs a new C2S_LilianMap.
     * @exports C2S_LilianMap
     * @classdesc Represents a C2S_LilianMap.
     * @implements IC2S_LilianMap
     * @constructor
     * @param {IC2S_LilianMap=} [properties] Properties to set
     */
    function C2S_LilianMap(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_LilianMap instance using the specified properties.
     * @function create
     * @memberof C2S_LilianMap
     * @static
     * @param {IC2S_LilianMap=} [properties] Properties to set
     * @returns {C2S_LilianMap} C2S_LilianMap instance
     */
    C2S_LilianMap.create = function create(properties) {
        return new C2S_LilianMap(properties);
    };

    /**
     * Encodes the specified C2S_LilianMap message. Does not implicitly {@link C2S_LilianMap.verify|verify} messages.
     * @function encode
     * @memberof C2S_LilianMap
     * @static
     * @param {IC2S_LilianMap} message C2S_LilianMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_LilianMap.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_LilianMap message, length delimited. Does not implicitly {@link C2S_LilianMap.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_LilianMap
     * @static
     * @param {IC2S_LilianMap} message C2S_LilianMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_LilianMap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_LilianMap message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_LilianMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_LilianMap} C2S_LilianMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_LilianMap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_LilianMap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_LilianMap message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_LilianMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_LilianMap} C2S_LilianMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_LilianMap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_LilianMap message.
     * @function verify
     * @memberof C2S_LilianMap
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_LilianMap.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_LilianMap message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_LilianMap
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_LilianMap} C2S_LilianMap
     */
    C2S_LilianMap.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_LilianMap)
            return object;
        return new $root.C2S_LilianMap();
    };

    /**
     * Creates a plain object from a C2S_LilianMap message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_LilianMap
     * @static
     * @param {C2S_LilianMap} message C2S_LilianMap
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_LilianMap.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_LilianMap to JSON.
     * @function toJSON
     * @memberof C2S_LilianMap
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_LilianMap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_LilianMap;
})();

$root.S2C_LilianMap = (function() {

    /**
     * Properties of a S2C_LilianMap.
     * @exports IS2C_LilianMap
     * @interface IS2C_LilianMap
     * @property {number|null} [currentMapId] S2C_LilianMap currentMapId
     * @property {number|null} [topMapId] S2C_LilianMap topMapId
     */

    /**
     * Constructs a new S2C_LilianMap.
     * @exports S2C_LilianMap
     * @classdesc Represents a S2C_LilianMap.
     * @implements IS2C_LilianMap
     * @constructor
     * @param {IS2C_LilianMap=} [properties] Properties to set
     */
    function S2C_LilianMap(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_LilianMap currentMapId.
     * @member {number} currentMapId
     * @memberof S2C_LilianMap
     * @instance
     */
    S2C_LilianMap.prototype.currentMapId = 0;

    /**
     * S2C_LilianMap topMapId.
     * @member {number} topMapId
     * @memberof S2C_LilianMap
     * @instance
     */
    S2C_LilianMap.prototype.topMapId = 0;

    /**
     * Creates a new S2C_LilianMap instance using the specified properties.
     * @function create
     * @memberof S2C_LilianMap
     * @static
     * @param {IS2C_LilianMap=} [properties] Properties to set
     * @returns {S2C_LilianMap} S2C_LilianMap instance
     */
    S2C_LilianMap.create = function create(properties) {
        return new S2C_LilianMap(properties);
    };

    /**
     * Encodes the specified S2C_LilianMap message. Does not implicitly {@link S2C_LilianMap.verify|verify} messages.
     * @function encode
     * @memberof S2C_LilianMap
     * @static
     * @param {IS2C_LilianMap} message S2C_LilianMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_LilianMap.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.currentMapId != null && message.hasOwnProperty("currentMapId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentMapId);
        if (message.topMapId != null && message.hasOwnProperty("topMapId"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.topMapId);
        return writer;
    };

    /**
     * Encodes the specified S2C_LilianMap message, length delimited. Does not implicitly {@link S2C_LilianMap.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_LilianMap
     * @static
     * @param {IS2C_LilianMap} message S2C_LilianMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_LilianMap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_LilianMap message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_LilianMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_LilianMap} S2C_LilianMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_LilianMap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_LilianMap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.currentMapId = reader.int32();
                break;
            case 2:
                message.topMapId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_LilianMap message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_LilianMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_LilianMap} S2C_LilianMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_LilianMap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_LilianMap message.
     * @function verify
     * @memberof S2C_LilianMap
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_LilianMap.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.currentMapId != null && message.hasOwnProperty("currentMapId"))
            if (!$util.isInteger(message.currentMapId))
                return "currentMapId: integer expected";
        if (message.topMapId != null && message.hasOwnProperty("topMapId"))
            if (!$util.isInteger(message.topMapId))
                return "topMapId: integer expected";
        return null;
    };

    /**
     * Creates a S2C_LilianMap message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_LilianMap
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_LilianMap} S2C_LilianMap
     */
    S2C_LilianMap.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_LilianMap)
            return object;
        var message = new $root.S2C_LilianMap();
        if (object.currentMapId != null)
            message.currentMapId = object.currentMapId | 0;
        if (object.topMapId != null)
            message.topMapId = object.topMapId | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_LilianMap message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_LilianMap
     * @static
     * @param {S2C_LilianMap} message S2C_LilianMap
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_LilianMap.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.currentMapId = 0;
            object.topMapId = 0;
        }
        if (message.currentMapId != null && message.hasOwnProperty("currentMapId"))
            object.currentMapId = message.currentMapId;
        if (message.topMapId != null && message.hasOwnProperty("topMapId"))
            object.topMapId = message.topMapId;
        return object;
    };

    /**
     * Converts this S2C_LilianMap to JSON.
     * @function toJSON
     * @memberof S2C_LilianMap
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_LilianMap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_LilianMap;
})();

$root.C2S_EnterMap = (function() {

    /**
     * Properties of a C2S_EnterMap.
     * @exports IC2S_EnterMap
     * @interface IC2S_EnterMap
     * @property {number|null} [mapId] C2S_EnterMap mapId
     */

    /**
     * Constructs a new C2S_EnterMap.
     * @exports C2S_EnterMap
     * @classdesc Represents a C2S_EnterMap.
     * @implements IC2S_EnterMap
     * @constructor
     * @param {IC2S_EnterMap=} [properties] Properties to set
     */
    function C2S_EnterMap(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_EnterMap mapId.
     * @member {number} mapId
     * @memberof C2S_EnterMap
     * @instance
     */
    C2S_EnterMap.prototype.mapId = 0;

    /**
     * Creates a new C2S_EnterMap instance using the specified properties.
     * @function create
     * @memberof C2S_EnterMap
     * @static
     * @param {IC2S_EnterMap=} [properties] Properties to set
     * @returns {C2S_EnterMap} C2S_EnterMap instance
     */
    C2S_EnterMap.create = function create(properties) {
        return new C2S_EnterMap(properties);
    };

    /**
     * Encodes the specified C2S_EnterMap message. Does not implicitly {@link C2S_EnterMap.verify|verify} messages.
     * @function encode
     * @memberof C2S_EnterMap
     * @static
     * @param {IC2S_EnterMap} message C2S_EnterMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_EnterMap.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mapId);
        return writer;
    };

    /**
     * Encodes the specified C2S_EnterMap message, length delimited. Does not implicitly {@link C2S_EnterMap.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_EnterMap
     * @static
     * @param {IC2S_EnterMap} message C2S_EnterMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_EnterMap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_EnterMap message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_EnterMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_EnterMap} C2S_EnterMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_EnterMap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_EnterMap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.mapId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_EnterMap message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_EnterMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_EnterMap} C2S_EnterMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_EnterMap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_EnterMap message.
     * @function verify
     * @memberof C2S_EnterMap
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_EnterMap.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            if (!$util.isInteger(message.mapId))
                return "mapId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_EnterMap message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_EnterMap
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_EnterMap} C2S_EnterMap
     */
    C2S_EnterMap.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_EnterMap)
            return object;
        var message = new $root.C2S_EnterMap();
        if (object.mapId != null)
            message.mapId = object.mapId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_EnterMap message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_EnterMap
     * @static
     * @param {C2S_EnterMap} message C2S_EnterMap
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_EnterMap.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.mapId = 0;
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            object.mapId = message.mapId;
        return object;
    };

    /**
     * Converts this C2S_EnterMap to JSON.
     * @function toJSON
     * @memberof C2S_EnterMap
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_EnterMap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_EnterMap;
})();

$root.S2C_EnterMap = (function() {

    /**
     * Properties of a S2C_EnterMap.
     * @exports IS2C_EnterMap
     * @interface IS2C_EnterMap
     * @property {number|null} [posX] S2C_EnterMap posX
     * @property {number|null} [posY] S2C_EnterMap posY
     * @property {Array.<IMapInfo>|null} [mapInfo] S2C_EnterMap mapInfo
     * @property {number|null} [backX] S2C_EnterMap backX
     * @property {number|null} [backY] S2C_EnterMap backY
     * @property {number|null} [mapId] S2C_EnterMap mapId
     * @property {Array.<number>|null} [qiyu] S2C_EnterMap qiyu
     */

    /**
     * Constructs a new S2C_EnterMap.
     * @exports S2C_EnterMap
     * @classdesc Represents a S2C_EnterMap.
     * @implements IS2C_EnterMap
     * @constructor
     * @param {IS2C_EnterMap=} [properties] Properties to set
     */
    function S2C_EnterMap(properties) {
        this.mapInfo = [];
        this.qiyu = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_EnterMap posX.
     * @member {number} posX
     * @memberof S2C_EnterMap
     * @instance
     */
    S2C_EnterMap.prototype.posX = 0;

    /**
     * S2C_EnterMap posY.
     * @member {number} posY
     * @memberof S2C_EnterMap
     * @instance
     */
    S2C_EnterMap.prototype.posY = 0;

    /**
     * S2C_EnterMap mapInfo.
     * @member {Array.<IMapInfo>} mapInfo
     * @memberof S2C_EnterMap
     * @instance
     */
    S2C_EnterMap.prototype.mapInfo = $util.emptyArray;

    /**
     * S2C_EnterMap backX.
     * @member {number} backX
     * @memberof S2C_EnterMap
     * @instance
     */
    S2C_EnterMap.prototype.backX = 0;

    /**
     * S2C_EnterMap backY.
     * @member {number} backY
     * @memberof S2C_EnterMap
     * @instance
     */
    S2C_EnterMap.prototype.backY = 0;

    /**
     * S2C_EnterMap mapId.
     * @member {number} mapId
     * @memberof S2C_EnterMap
     * @instance
     */
    S2C_EnterMap.prototype.mapId = 0;

    /**
     * S2C_EnterMap qiyu.
     * @member {Array.<number>} qiyu
     * @memberof S2C_EnterMap
     * @instance
     */
    S2C_EnterMap.prototype.qiyu = $util.emptyArray;

    /**
     * Creates a new S2C_EnterMap instance using the specified properties.
     * @function create
     * @memberof S2C_EnterMap
     * @static
     * @param {IS2C_EnterMap=} [properties] Properties to set
     * @returns {S2C_EnterMap} S2C_EnterMap instance
     */
    S2C_EnterMap.create = function create(properties) {
        return new S2C_EnterMap(properties);
    };

    /**
     * Encodes the specified S2C_EnterMap message. Does not implicitly {@link S2C_EnterMap.verify|verify} messages.
     * @function encode
     * @memberof S2C_EnterMap
     * @static
     * @param {IS2C_EnterMap} message S2C_EnterMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_EnterMap.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.posX != null && message.hasOwnProperty("posX"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
        if (message.posY != null && message.hasOwnProperty("posY"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
        if (message.mapInfo != null && message.mapInfo.length)
            for (var i = 0; i < message.mapInfo.length; ++i)
                $root.MapInfo.encode(message.mapInfo[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.backX != null && message.hasOwnProperty("backX"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.backX);
        if (message.backY != null && message.hasOwnProperty("backY"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.backY);
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.mapId);
        if (message.qiyu != null && message.qiyu.length)
            for (var i = 0; i < message.qiyu.length; ++i)
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.qiyu[i]);
        return writer;
    };

    /**
     * Encodes the specified S2C_EnterMap message, length delimited. Does not implicitly {@link S2C_EnterMap.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_EnterMap
     * @static
     * @param {IS2C_EnterMap} message S2C_EnterMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_EnterMap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_EnterMap message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_EnterMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_EnterMap} S2C_EnterMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_EnterMap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_EnterMap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.posX = reader.int32();
                break;
            case 2:
                message.posY = reader.int32();
                break;
            case 3:
                if (!(message.mapInfo && message.mapInfo.length))
                    message.mapInfo = [];
                message.mapInfo.push($root.MapInfo.decode(reader, reader.uint32()));
                break;
            case 4:
                message.backX = reader.int32();
                break;
            case 5:
                message.backY = reader.int32();
                break;
            case 6:
                message.mapId = reader.int32();
                break;
            case 7:
                if (!(message.qiyu && message.qiyu.length))
                    message.qiyu = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.qiyu.push(reader.int32());
                } else
                    message.qiyu.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_EnterMap message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_EnterMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_EnterMap} S2C_EnterMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_EnterMap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_EnterMap message.
     * @function verify
     * @memberof S2C_EnterMap
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_EnterMap.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.posX != null && message.hasOwnProperty("posX"))
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
        if (message.posY != null && message.hasOwnProperty("posY"))
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
        if (message.mapInfo != null && message.hasOwnProperty("mapInfo")) {
            if (!Array.isArray(message.mapInfo))
                return "mapInfo: array expected";
            for (var i = 0; i < message.mapInfo.length; ++i) {
                var error = $root.MapInfo.verify(message.mapInfo[i]);
                if (error)
                    return "mapInfo." + error;
            }
        }
        if (message.backX != null && message.hasOwnProperty("backX"))
            if (!$util.isInteger(message.backX))
                return "backX: integer expected";
        if (message.backY != null && message.hasOwnProperty("backY"))
            if (!$util.isInteger(message.backY))
                return "backY: integer expected";
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            if (!$util.isInteger(message.mapId))
                return "mapId: integer expected";
        if (message.qiyu != null && message.hasOwnProperty("qiyu")) {
            if (!Array.isArray(message.qiyu))
                return "qiyu: array expected";
            for (var i = 0; i < message.qiyu.length; ++i)
                if (!$util.isInteger(message.qiyu[i]))
                    return "qiyu: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a S2C_EnterMap message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_EnterMap
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_EnterMap} S2C_EnterMap
     */
    S2C_EnterMap.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_EnterMap)
            return object;
        var message = new $root.S2C_EnterMap();
        if (object.posX != null)
            message.posX = object.posX | 0;
        if (object.posY != null)
            message.posY = object.posY | 0;
        if (object.mapInfo) {
            if (!Array.isArray(object.mapInfo))
                throw TypeError(".S2C_EnterMap.mapInfo: array expected");
            message.mapInfo = [];
            for (var i = 0; i < object.mapInfo.length; ++i) {
                if (typeof object.mapInfo[i] !== "object")
                    throw TypeError(".S2C_EnterMap.mapInfo: object expected");
                message.mapInfo[i] = $root.MapInfo.fromObject(object.mapInfo[i]);
            }
        }
        if (object.backX != null)
            message.backX = object.backX | 0;
        if (object.backY != null)
            message.backY = object.backY | 0;
        if (object.mapId != null)
            message.mapId = object.mapId | 0;
        if (object.qiyu) {
            if (!Array.isArray(object.qiyu))
                throw TypeError(".S2C_EnterMap.qiyu: array expected");
            message.qiyu = [];
            for (var i = 0; i < object.qiyu.length; ++i)
                message.qiyu[i] = object.qiyu[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_EnterMap message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_EnterMap
     * @static
     * @param {S2C_EnterMap} message S2C_EnterMap
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_EnterMap.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.mapInfo = [];
            object.qiyu = [];
        }
        if (options.defaults) {
            object.posX = 0;
            object.posY = 0;
            object.backX = 0;
            object.backY = 0;
            object.mapId = 0;
        }
        if (message.posX != null && message.hasOwnProperty("posX"))
            object.posX = message.posX;
        if (message.posY != null && message.hasOwnProperty("posY"))
            object.posY = message.posY;
        if (message.mapInfo && message.mapInfo.length) {
            object.mapInfo = [];
            for (var j = 0; j < message.mapInfo.length; ++j)
                object.mapInfo[j] = $root.MapInfo.toObject(message.mapInfo[j], options);
        }
        if (message.backX != null && message.hasOwnProperty("backX"))
            object.backX = message.backX;
        if (message.backY != null && message.hasOwnProperty("backY"))
            object.backY = message.backY;
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            object.mapId = message.mapId;
        if (message.qiyu && message.qiyu.length) {
            object.qiyu = [];
            for (var j = 0; j < message.qiyu.length; ++j)
                object.qiyu[j] = message.qiyu[j];
        }
        return object;
    };

    /**
     * Converts this S2C_EnterMap to JSON.
     * @function toJSON
     * @memberof S2C_EnterMap
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_EnterMap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_EnterMap;
})();

$root.C2S_StepInMap = (function() {

    /**
     * Properties of a C2S_StepInMap.
     * @exports IC2S_StepInMap
     * @interface IC2S_StepInMap
     * @property {number|null} [posX] C2S_StepInMap posX
     * @property {number|null} [posY] C2S_StepInMap posY
     */

    /**
     * Constructs a new C2S_StepInMap.
     * @exports C2S_StepInMap
     * @classdesc Represents a C2S_StepInMap.
     * @implements IC2S_StepInMap
     * @constructor
     * @param {IC2S_StepInMap=} [properties] Properties to set
     */
    function C2S_StepInMap(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_StepInMap posX.
     * @member {number} posX
     * @memberof C2S_StepInMap
     * @instance
     */
    C2S_StepInMap.prototype.posX = 0;

    /**
     * C2S_StepInMap posY.
     * @member {number} posY
     * @memberof C2S_StepInMap
     * @instance
     */
    C2S_StepInMap.prototype.posY = 0;

    /**
     * Creates a new C2S_StepInMap instance using the specified properties.
     * @function create
     * @memberof C2S_StepInMap
     * @static
     * @param {IC2S_StepInMap=} [properties] Properties to set
     * @returns {C2S_StepInMap} C2S_StepInMap instance
     */
    C2S_StepInMap.create = function create(properties) {
        return new C2S_StepInMap(properties);
    };

    /**
     * Encodes the specified C2S_StepInMap message. Does not implicitly {@link C2S_StepInMap.verify|verify} messages.
     * @function encode
     * @memberof C2S_StepInMap
     * @static
     * @param {IC2S_StepInMap} message C2S_StepInMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_StepInMap.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.posX != null && message.hasOwnProperty("posX"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
        if (message.posY != null && message.hasOwnProperty("posY"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
        return writer;
    };

    /**
     * Encodes the specified C2S_StepInMap message, length delimited. Does not implicitly {@link C2S_StepInMap.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_StepInMap
     * @static
     * @param {IC2S_StepInMap} message C2S_StepInMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_StepInMap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_StepInMap message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_StepInMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_StepInMap} C2S_StepInMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_StepInMap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_StepInMap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.posX = reader.int32();
                break;
            case 2:
                message.posY = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_StepInMap message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_StepInMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_StepInMap} C2S_StepInMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_StepInMap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_StepInMap message.
     * @function verify
     * @memberof C2S_StepInMap
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_StepInMap.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.posX != null && message.hasOwnProperty("posX"))
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
        if (message.posY != null && message.hasOwnProperty("posY"))
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
        return null;
    };

    /**
     * Creates a C2S_StepInMap message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_StepInMap
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_StepInMap} C2S_StepInMap
     */
    C2S_StepInMap.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_StepInMap)
            return object;
        var message = new $root.C2S_StepInMap();
        if (object.posX != null)
            message.posX = object.posX | 0;
        if (object.posY != null)
            message.posY = object.posY | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_StepInMap message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_StepInMap
     * @static
     * @param {C2S_StepInMap} message C2S_StepInMap
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_StepInMap.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.posX = 0;
            object.posY = 0;
        }
        if (message.posX != null && message.hasOwnProperty("posX"))
            object.posX = message.posX;
        if (message.posY != null && message.hasOwnProperty("posY"))
            object.posY = message.posY;
        return object;
    };

    /**
     * Converts this C2S_StepInMap to JSON.
     * @function toJSON
     * @memberof C2S_StepInMap
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_StepInMap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_StepInMap;
})();

$root.S2C_StepInMap = (function() {

    /**
     * Properties of a S2C_StepInMap.
     * @exports IS2C_StepInMap
     * @interface IS2C_StepInMap
     * @property {number|null} [posX] S2C_StepInMap posX
     * @property {number|null} [posY] S2C_StepInMap posY
     * @property {number|null} [ResType] S2C_StepInMap ResType
     * @property {number|null} [ResValue] S2C_StepInMap ResValue
     * @property {Array.<IItemMsg>|null} [drop] S2C_StepInMap drop
     */

    /**
     * Constructs a new S2C_StepInMap.
     * @exports S2C_StepInMap
     * @classdesc Represents a S2C_StepInMap.
     * @implements IS2C_StepInMap
     * @constructor
     * @param {IS2C_StepInMap=} [properties] Properties to set
     */
    function S2C_StepInMap(properties) {
        this.drop = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_StepInMap posX.
     * @member {number} posX
     * @memberof S2C_StepInMap
     * @instance
     */
    S2C_StepInMap.prototype.posX = 0;

    /**
     * S2C_StepInMap posY.
     * @member {number} posY
     * @memberof S2C_StepInMap
     * @instance
     */
    S2C_StepInMap.prototype.posY = 0;

    /**
     * S2C_StepInMap ResType.
     * @member {number} ResType
     * @memberof S2C_StepInMap
     * @instance
     */
    S2C_StepInMap.prototype.ResType = 0;

    /**
     * S2C_StepInMap ResValue.
     * @member {number} ResValue
     * @memberof S2C_StepInMap
     * @instance
     */
    S2C_StepInMap.prototype.ResValue = 0;

    /**
     * S2C_StepInMap drop.
     * @member {Array.<IItemMsg>} drop
     * @memberof S2C_StepInMap
     * @instance
     */
    S2C_StepInMap.prototype.drop = $util.emptyArray;

    /**
     * Creates a new S2C_StepInMap instance using the specified properties.
     * @function create
     * @memberof S2C_StepInMap
     * @static
     * @param {IS2C_StepInMap=} [properties] Properties to set
     * @returns {S2C_StepInMap} S2C_StepInMap instance
     */
    S2C_StepInMap.create = function create(properties) {
        return new S2C_StepInMap(properties);
    };

    /**
     * Encodes the specified S2C_StepInMap message. Does not implicitly {@link S2C_StepInMap.verify|verify} messages.
     * @function encode
     * @memberof S2C_StepInMap
     * @static
     * @param {IS2C_StepInMap} message S2C_StepInMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_StepInMap.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.posX != null && message.hasOwnProperty("posX"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
        if (message.posY != null && message.hasOwnProperty("posY"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
        if (message.ResType != null && message.hasOwnProperty("ResType"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ResType);
        if (message.ResValue != null && message.hasOwnProperty("ResValue"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ResValue);
        if (message.drop != null && message.drop.length)
            for (var i = 0; i < message.drop.length; ++i)
                $root.ItemMsg.encode(message.drop[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_StepInMap message, length delimited. Does not implicitly {@link S2C_StepInMap.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_StepInMap
     * @static
     * @param {IS2C_StepInMap} message S2C_StepInMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_StepInMap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_StepInMap message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_StepInMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_StepInMap} S2C_StepInMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_StepInMap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_StepInMap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.posX = reader.int32();
                break;
            case 2:
                message.posY = reader.int32();
                break;
            case 3:
                message.ResType = reader.int32();
                break;
            case 4:
                message.ResValue = reader.int32();
                break;
            case 5:
                if (!(message.drop && message.drop.length))
                    message.drop = [];
                message.drop.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_StepInMap message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_StepInMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_StepInMap} S2C_StepInMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_StepInMap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_StepInMap message.
     * @function verify
     * @memberof S2C_StepInMap
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_StepInMap.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.posX != null && message.hasOwnProperty("posX"))
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
        if (message.posY != null && message.hasOwnProperty("posY"))
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
        if (message.ResType != null && message.hasOwnProperty("ResType"))
            if (!$util.isInteger(message.ResType))
                return "ResType: integer expected";
        if (message.ResValue != null && message.hasOwnProperty("ResValue"))
            if (!$util.isInteger(message.ResValue))
                return "ResValue: integer expected";
        if (message.drop != null && message.hasOwnProperty("drop")) {
            if (!Array.isArray(message.drop))
                return "drop: array expected";
            for (var i = 0; i < message.drop.length; ++i) {
                var error = $root.ItemMsg.verify(message.drop[i]);
                if (error)
                    return "drop." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_StepInMap message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_StepInMap
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_StepInMap} S2C_StepInMap
     */
    S2C_StepInMap.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_StepInMap)
            return object;
        var message = new $root.S2C_StepInMap();
        if (object.posX != null)
            message.posX = object.posX | 0;
        if (object.posY != null)
            message.posY = object.posY | 0;
        if (object.ResType != null)
            message.ResType = object.ResType | 0;
        if (object.ResValue != null)
            message.ResValue = object.ResValue | 0;
        if (object.drop) {
            if (!Array.isArray(object.drop))
                throw TypeError(".S2C_StepInMap.drop: array expected");
            message.drop = [];
            for (var i = 0; i < object.drop.length; ++i) {
                if (typeof object.drop[i] !== "object")
                    throw TypeError(".S2C_StepInMap.drop: object expected");
                message.drop[i] = $root.ItemMsg.fromObject(object.drop[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_StepInMap message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_StepInMap
     * @static
     * @param {S2C_StepInMap} message S2C_StepInMap
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_StepInMap.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.drop = [];
        if (options.defaults) {
            object.posX = 0;
            object.posY = 0;
            object.ResType = 0;
            object.ResValue = 0;
        }
        if (message.posX != null && message.hasOwnProperty("posX"))
            object.posX = message.posX;
        if (message.posY != null && message.hasOwnProperty("posY"))
            object.posY = message.posY;
        if (message.ResType != null && message.hasOwnProperty("ResType"))
            object.ResType = message.ResType;
        if (message.ResValue != null && message.hasOwnProperty("ResValue"))
            object.ResValue = message.ResValue;
        if (message.drop && message.drop.length) {
            object.drop = [];
            for (var j = 0; j < message.drop.length; ++j)
                object.drop[j] = $root.ItemMsg.toObject(message.drop[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_StepInMap to JSON.
     * @function toJSON
     * @memberof S2C_StepInMap
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_StepInMap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_StepInMap;
})();

$root.C2S_FightMonster = (function() {

    /**
     * Properties of a C2S_FightMonster.
     * @exports IC2S_FightMonster
     * @interface IC2S_FightMonster
     */

    /**
     * Constructs a new C2S_FightMonster.
     * @exports C2S_FightMonster
     * @classdesc Represents a C2S_FightMonster.
     * @implements IC2S_FightMonster
     * @constructor
     * @param {IC2S_FightMonster=} [properties] Properties to set
     */
    function C2S_FightMonster(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_FightMonster instance using the specified properties.
     * @function create
     * @memberof C2S_FightMonster
     * @static
     * @param {IC2S_FightMonster=} [properties] Properties to set
     * @returns {C2S_FightMonster} C2S_FightMonster instance
     */
    C2S_FightMonster.create = function create(properties) {
        return new C2S_FightMonster(properties);
    };

    /**
     * Encodes the specified C2S_FightMonster message. Does not implicitly {@link C2S_FightMonster.verify|verify} messages.
     * @function encode
     * @memberof C2S_FightMonster
     * @static
     * @param {IC2S_FightMonster} message C2S_FightMonster message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_FightMonster.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_FightMonster message, length delimited. Does not implicitly {@link C2S_FightMonster.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_FightMonster
     * @static
     * @param {IC2S_FightMonster} message C2S_FightMonster message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_FightMonster.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_FightMonster message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_FightMonster
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_FightMonster} C2S_FightMonster
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_FightMonster.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_FightMonster();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_FightMonster message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_FightMonster
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_FightMonster} C2S_FightMonster
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_FightMonster.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_FightMonster message.
     * @function verify
     * @memberof C2S_FightMonster
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_FightMonster.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_FightMonster message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_FightMonster
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_FightMonster} C2S_FightMonster
     */
    C2S_FightMonster.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_FightMonster)
            return object;
        return new $root.C2S_FightMonster();
    };

    /**
     * Creates a plain object from a C2S_FightMonster message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_FightMonster
     * @static
     * @param {C2S_FightMonster} message C2S_FightMonster
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_FightMonster.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_FightMonster to JSON.
     * @function toJSON
     * @memberof C2S_FightMonster
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_FightMonster.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_FightMonster;
})();

$root.S2C_FightMonster = (function() {

    /**
     * Properties of a S2C_FightMonster.
     * @exports IS2C_FightMonster
     * @interface IS2C_FightMonster
     * @property {IFightResultMsg|null} [result] S2C_FightMonster result
     */

    /**
     * Constructs a new S2C_FightMonster.
     * @exports S2C_FightMonster
     * @classdesc Represents a S2C_FightMonster.
     * @implements IS2C_FightMonster
     * @constructor
     * @param {IS2C_FightMonster=} [properties] Properties to set
     */
    function S2C_FightMonster(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_FightMonster result.
     * @member {IFightResultMsg|null|undefined} result
     * @memberof S2C_FightMonster
     * @instance
     */
    S2C_FightMonster.prototype.result = null;

    /**
     * Creates a new S2C_FightMonster instance using the specified properties.
     * @function create
     * @memberof S2C_FightMonster
     * @static
     * @param {IS2C_FightMonster=} [properties] Properties to set
     * @returns {S2C_FightMonster} S2C_FightMonster instance
     */
    S2C_FightMonster.create = function create(properties) {
        return new S2C_FightMonster(properties);
    };

    /**
     * Encodes the specified S2C_FightMonster message. Does not implicitly {@link S2C_FightMonster.verify|verify} messages.
     * @function encode
     * @memberof S2C_FightMonster
     * @static
     * @param {IS2C_FightMonster} message S2C_FightMonster message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_FightMonster.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && message.hasOwnProperty("result"))
            $root.FightResultMsg.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_FightMonster message, length delimited. Does not implicitly {@link S2C_FightMonster.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_FightMonster
     * @static
     * @param {IS2C_FightMonster} message S2C_FightMonster message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_FightMonster.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_FightMonster message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_FightMonster
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_FightMonster} S2C_FightMonster
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_FightMonster.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_FightMonster();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = $root.FightResultMsg.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_FightMonster message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_FightMonster
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_FightMonster} S2C_FightMonster
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_FightMonster.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_FightMonster message.
     * @function verify
     * @memberof S2C_FightMonster
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_FightMonster.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result")) {
            var error = $root.FightResultMsg.verify(message.result);
            if (error)
                return "result." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_FightMonster message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_FightMonster
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_FightMonster} S2C_FightMonster
     */
    S2C_FightMonster.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_FightMonster)
            return object;
        var message = new $root.S2C_FightMonster();
        if (object.result != null) {
            if (typeof object.result !== "object")
                throw TypeError(".S2C_FightMonster.result: object expected");
            message.result = $root.FightResultMsg.fromObject(object.result);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_FightMonster message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_FightMonster
     * @static
     * @param {S2C_FightMonster} message S2C_FightMonster
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_FightMonster.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.result = null;
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = $root.FightResultMsg.toObject(message.result, options);
        return object;
    };

    /**
     * Converts this S2C_FightMonster to JSON.
     * @function toJSON
     * @memberof S2C_FightMonster
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_FightMonster.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_FightMonster;
})();

$root.C2S_BuyShenyouItem = (function() {

    /**
     * Properties of a C2S_BuyShenyouItem.
     * @exports IC2S_BuyShenyouItem
     * @interface IC2S_BuyShenyouItem
     * @property {number|null} [systemId] C2S_BuyShenyouItem systemId
     */

    /**
     * Constructs a new C2S_BuyShenyouItem.
     * @exports C2S_BuyShenyouItem
     * @classdesc Represents a C2S_BuyShenyouItem.
     * @implements IC2S_BuyShenyouItem
     * @constructor
     * @param {IC2S_BuyShenyouItem=} [properties] Properties to set
     */
    function C2S_BuyShenyouItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_BuyShenyouItem systemId.
     * @member {number} systemId
     * @memberof C2S_BuyShenyouItem
     * @instance
     */
    C2S_BuyShenyouItem.prototype.systemId = 0;

    /**
     * Creates a new C2S_BuyShenyouItem instance using the specified properties.
     * @function create
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {IC2S_BuyShenyouItem=} [properties] Properties to set
     * @returns {C2S_BuyShenyouItem} C2S_BuyShenyouItem instance
     */
    C2S_BuyShenyouItem.create = function create(properties) {
        return new C2S_BuyShenyouItem(properties);
    };

    /**
     * Encodes the specified C2S_BuyShenyouItem message. Does not implicitly {@link C2S_BuyShenyouItem.verify|verify} messages.
     * @function encode
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {IC2S_BuyShenyouItem} message C2S_BuyShenyouItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_BuyShenyouItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.systemId != null && message.hasOwnProperty("systemId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.systemId);
        return writer;
    };

    /**
     * Encodes the specified C2S_BuyShenyouItem message, length delimited. Does not implicitly {@link C2S_BuyShenyouItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {IC2S_BuyShenyouItem} message C2S_BuyShenyouItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_BuyShenyouItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_BuyShenyouItem message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_BuyShenyouItem} C2S_BuyShenyouItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_BuyShenyouItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_BuyShenyouItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.systemId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_BuyShenyouItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_BuyShenyouItem} C2S_BuyShenyouItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_BuyShenyouItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_BuyShenyouItem message.
     * @function verify
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_BuyShenyouItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.systemId != null && message.hasOwnProperty("systemId"))
            if (!$util.isInteger(message.systemId))
                return "systemId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_BuyShenyouItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_BuyShenyouItem} C2S_BuyShenyouItem
     */
    C2S_BuyShenyouItem.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_BuyShenyouItem)
            return object;
        var message = new $root.C2S_BuyShenyouItem();
        if (object.systemId != null)
            message.systemId = object.systemId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_BuyShenyouItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_BuyShenyouItem
     * @static
     * @param {C2S_BuyShenyouItem} message C2S_BuyShenyouItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_BuyShenyouItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.systemId = 0;
        if (message.systemId != null && message.hasOwnProperty("systemId"))
            object.systemId = message.systemId;
        return object;
    };

    /**
     * Converts this C2S_BuyShenyouItem to JSON.
     * @function toJSON
     * @memberof C2S_BuyShenyouItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_BuyShenyouItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_BuyShenyouItem;
})();

$root.S2C_BuyShenyouItem = (function() {

    /**
     * Properties of a S2C_BuyShenyouItem.
     * @exports IS2C_BuyShenyouItem
     * @interface IS2C_BuyShenyouItem
     * @property {number|null} [systemId] S2C_BuyShenyouItem systemId
     */

    /**
     * Constructs a new S2C_BuyShenyouItem.
     * @exports S2C_BuyShenyouItem
     * @classdesc Represents a S2C_BuyShenyouItem.
     * @implements IS2C_BuyShenyouItem
     * @constructor
     * @param {IS2C_BuyShenyouItem=} [properties] Properties to set
     */
    function S2C_BuyShenyouItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_BuyShenyouItem systemId.
     * @member {number} systemId
     * @memberof S2C_BuyShenyouItem
     * @instance
     */
    S2C_BuyShenyouItem.prototype.systemId = 0;

    /**
     * Creates a new S2C_BuyShenyouItem instance using the specified properties.
     * @function create
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {IS2C_BuyShenyouItem=} [properties] Properties to set
     * @returns {S2C_BuyShenyouItem} S2C_BuyShenyouItem instance
     */
    S2C_BuyShenyouItem.create = function create(properties) {
        return new S2C_BuyShenyouItem(properties);
    };

    /**
     * Encodes the specified S2C_BuyShenyouItem message. Does not implicitly {@link S2C_BuyShenyouItem.verify|verify} messages.
     * @function encode
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {IS2C_BuyShenyouItem} message S2C_BuyShenyouItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_BuyShenyouItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.systemId != null && message.hasOwnProperty("systemId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.systemId);
        return writer;
    };

    /**
     * Encodes the specified S2C_BuyShenyouItem message, length delimited. Does not implicitly {@link S2C_BuyShenyouItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {IS2C_BuyShenyouItem} message S2C_BuyShenyouItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_BuyShenyouItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_BuyShenyouItem message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_BuyShenyouItem} S2C_BuyShenyouItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_BuyShenyouItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_BuyShenyouItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.systemId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_BuyShenyouItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_BuyShenyouItem} S2C_BuyShenyouItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_BuyShenyouItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_BuyShenyouItem message.
     * @function verify
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_BuyShenyouItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.systemId != null && message.hasOwnProperty("systemId"))
            if (!$util.isInteger(message.systemId))
                return "systemId: integer expected";
        return null;
    };

    /**
     * Creates a S2C_BuyShenyouItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_BuyShenyouItem} S2C_BuyShenyouItem
     */
    S2C_BuyShenyouItem.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_BuyShenyouItem)
            return object;
        var message = new $root.S2C_BuyShenyouItem();
        if (object.systemId != null)
            message.systemId = object.systemId | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_BuyShenyouItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_BuyShenyouItem
     * @static
     * @param {S2C_BuyShenyouItem} message S2C_BuyShenyouItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_BuyShenyouItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.systemId = 0;
        if (message.systemId != null && message.hasOwnProperty("systemId"))
            object.systemId = message.systemId;
        return object;
    };

    /**
     * Converts this S2C_BuyShenyouItem to JSON.
     * @function toJSON
     * @memberof S2C_BuyShenyouItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_BuyShenyouItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_BuyShenyouItem;
})();

$root.C2S_SetAutoSell = (function() {

    /**
     * Properties of a C2S_SetAutoSell.
     * @exports IC2S_SetAutoSell
     * @interface IC2S_SetAutoSell
     * @property {Array.<number>|null} [pinzhi] C2S_SetAutoSell pinzhi
     */

    /**
     * Constructs a new C2S_SetAutoSell.
     * @exports C2S_SetAutoSell
     * @classdesc Represents a C2S_SetAutoSell.
     * @implements IC2S_SetAutoSell
     * @constructor
     * @param {IC2S_SetAutoSell=} [properties] Properties to set
     */
    function C2S_SetAutoSell(properties) {
        this.pinzhi = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_SetAutoSell pinzhi.
     * @member {Array.<number>} pinzhi
     * @memberof C2S_SetAutoSell
     * @instance
     */
    C2S_SetAutoSell.prototype.pinzhi = $util.emptyArray;

    /**
     * Creates a new C2S_SetAutoSell instance using the specified properties.
     * @function create
     * @memberof C2S_SetAutoSell
     * @static
     * @param {IC2S_SetAutoSell=} [properties] Properties to set
     * @returns {C2S_SetAutoSell} C2S_SetAutoSell instance
     */
    C2S_SetAutoSell.create = function create(properties) {
        return new C2S_SetAutoSell(properties);
    };

    /**
     * Encodes the specified C2S_SetAutoSell message. Does not implicitly {@link C2S_SetAutoSell.verify|verify} messages.
     * @function encode
     * @memberof C2S_SetAutoSell
     * @static
     * @param {IC2S_SetAutoSell} message C2S_SetAutoSell message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_SetAutoSell.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pinzhi != null && message.pinzhi.length)
            for (var i = 0; i < message.pinzhi.length; ++i)
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pinzhi[i]);
        return writer;
    };

    /**
     * Encodes the specified C2S_SetAutoSell message, length delimited. Does not implicitly {@link C2S_SetAutoSell.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_SetAutoSell
     * @static
     * @param {IC2S_SetAutoSell} message C2S_SetAutoSell message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_SetAutoSell.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_SetAutoSell message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_SetAutoSell
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_SetAutoSell} C2S_SetAutoSell
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_SetAutoSell.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_SetAutoSell();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.pinzhi && message.pinzhi.length))
                    message.pinzhi = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.pinzhi.push(reader.int32());
                } else
                    message.pinzhi.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_SetAutoSell message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_SetAutoSell
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_SetAutoSell} C2S_SetAutoSell
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_SetAutoSell.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_SetAutoSell message.
     * @function verify
     * @memberof C2S_SetAutoSell
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_SetAutoSell.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pinzhi != null && message.hasOwnProperty("pinzhi")) {
            if (!Array.isArray(message.pinzhi))
                return "pinzhi: array expected";
            for (var i = 0; i < message.pinzhi.length; ++i)
                if (!$util.isInteger(message.pinzhi[i]))
                    return "pinzhi: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a C2S_SetAutoSell message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_SetAutoSell
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_SetAutoSell} C2S_SetAutoSell
     */
    C2S_SetAutoSell.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_SetAutoSell)
            return object;
        var message = new $root.C2S_SetAutoSell();
        if (object.pinzhi) {
            if (!Array.isArray(object.pinzhi))
                throw TypeError(".C2S_SetAutoSell.pinzhi: array expected");
            message.pinzhi = [];
            for (var i = 0; i < object.pinzhi.length; ++i)
                message.pinzhi[i] = object.pinzhi[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_SetAutoSell message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_SetAutoSell
     * @static
     * @param {C2S_SetAutoSell} message C2S_SetAutoSell
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_SetAutoSell.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.pinzhi = [];
        if (message.pinzhi && message.pinzhi.length) {
            object.pinzhi = [];
            for (var j = 0; j < message.pinzhi.length; ++j)
                object.pinzhi[j] = message.pinzhi[j];
        }
        return object;
    };

    /**
     * Converts this C2S_SetAutoSell to JSON.
     * @function toJSON
     * @memberof C2S_SetAutoSell
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_SetAutoSell.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_SetAutoSell;
})();

$root.S2C_SetAutoSell = (function() {

    /**
     * Properties of a S2C_SetAutoSell.
     * @exports IS2C_SetAutoSell
     * @interface IS2C_SetAutoSell
     * @property {Array.<number>|null} [pinzhi] S2C_SetAutoSell pinzhi
     */

    /**
     * Constructs a new S2C_SetAutoSell.
     * @exports S2C_SetAutoSell
     * @classdesc Represents a S2C_SetAutoSell.
     * @implements IS2C_SetAutoSell
     * @constructor
     * @param {IS2C_SetAutoSell=} [properties] Properties to set
     */
    function S2C_SetAutoSell(properties) {
        this.pinzhi = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_SetAutoSell pinzhi.
     * @member {Array.<number>} pinzhi
     * @memberof S2C_SetAutoSell
     * @instance
     */
    S2C_SetAutoSell.prototype.pinzhi = $util.emptyArray;

    /**
     * Creates a new S2C_SetAutoSell instance using the specified properties.
     * @function create
     * @memberof S2C_SetAutoSell
     * @static
     * @param {IS2C_SetAutoSell=} [properties] Properties to set
     * @returns {S2C_SetAutoSell} S2C_SetAutoSell instance
     */
    S2C_SetAutoSell.create = function create(properties) {
        return new S2C_SetAutoSell(properties);
    };

    /**
     * Encodes the specified S2C_SetAutoSell message. Does not implicitly {@link S2C_SetAutoSell.verify|verify} messages.
     * @function encode
     * @memberof S2C_SetAutoSell
     * @static
     * @param {IS2C_SetAutoSell} message S2C_SetAutoSell message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_SetAutoSell.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pinzhi != null && message.pinzhi.length)
            for (var i = 0; i < message.pinzhi.length; ++i)
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pinzhi[i]);
        return writer;
    };

    /**
     * Encodes the specified S2C_SetAutoSell message, length delimited. Does not implicitly {@link S2C_SetAutoSell.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_SetAutoSell
     * @static
     * @param {IS2C_SetAutoSell} message S2C_SetAutoSell message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_SetAutoSell.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_SetAutoSell message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_SetAutoSell
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_SetAutoSell} S2C_SetAutoSell
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_SetAutoSell.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_SetAutoSell();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.pinzhi && message.pinzhi.length))
                    message.pinzhi = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.pinzhi.push(reader.int32());
                } else
                    message.pinzhi.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_SetAutoSell message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_SetAutoSell
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_SetAutoSell} S2C_SetAutoSell
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_SetAutoSell.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_SetAutoSell message.
     * @function verify
     * @memberof S2C_SetAutoSell
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_SetAutoSell.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pinzhi != null && message.hasOwnProperty("pinzhi")) {
            if (!Array.isArray(message.pinzhi))
                return "pinzhi: array expected";
            for (var i = 0; i < message.pinzhi.length; ++i)
                if (!$util.isInteger(message.pinzhi[i]))
                    return "pinzhi: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a S2C_SetAutoSell message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_SetAutoSell
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_SetAutoSell} S2C_SetAutoSell
     */
    S2C_SetAutoSell.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_SetAutoSell)
            return object;
        var message = new $root.S2C_SetAutoSell();
        if (object.pinzhi) {
            if (!Array.isArray(object.pinzhi))
                throw TypeError(".S2C_SetAutoSell.pinzhi: array expected");
            message.pinzhi = [];
            for (var i = 0; i < object.pinzhi.length; ++i)
                message.pinzhi[i] = object.pinzhi[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_SetAutoSell message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_SetAutoSell
     * @static
     * @param {S2C_SetAutoSell} message S2C_SetAutoSell
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_SetAutoSell.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.pinzhi = [];
        if (message.pinzhi && message.pinzhi.length) {
            object.pinzhi = [];
            for (var j = 0; j < message.pinzhi.length; ++j)
                object.pinzhi[j] = message.pinzhi[j];
        }
        return object;
    };

    /**
     * Converts this S2C_SetAutoSell to JSON.
     * @function toJSON
     * @memberof S2C_SetAutoSell
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_SetAutoSell.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_SetAutoSell;
})();

$root.C2S_Shenyou = (function() {

    /**
     * Properties of a C2S_Shenyou.
     * @exports IC2S_Shenyou
     * @interface IC2S_Shenyou
     * @property {number|null} [count] C2S_Shenyou count
     * @property {number|null} [mapId] C2S_Shenyou mapId
     */

    /**
     * Constructs a new C2S_Shenyou.
     * @exports C2S_Shenyou
     * @classdesc Represents a C2S_Shenyou.
     * @implements IC2S_Shenyou
     * @constructor
     * @param {IC2S_Shenyou=} [properties] Properties to set
     */
    function C2S_Shenyou(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_Shenyou count.
     * @member {number} count
     * @memberof C2S_Shenyou
     * @instance
     */
    C2S_Shenyou.prototype.count = 0;

    /**
     * C2S_Shenyou mapId.
     * @member {number} mapId
     * @memberof C2S_Shenyou
     * @instance
     */
    C2S_Shenyou.prototype.mapId = 0;

    /**
     * Creates a new C2S_Shenyou instance using the specified properties.
     * @function create
     * @memberof C2S_Shenyou
     * @static
     * @param {IC2S_Shenyou=} [properties] Properties to set
     * @returns {C2S_Shenyou} C2S_Shenyou instance
     */
    C2S_Shenyou.create = function create(properties) {
        return new C2S_Shenyou(properties);
    };

    /**
     * Encodes the specified C2S_Shenyou message. Does not implicitly {@link C2S_Shenyou.verify|verify} messages.
     * @function encode
     * @memberof C2S_Shenyou
     * @static
     * @param {IC2S_Shenyou} message C2S_Shenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Shenyou.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapId);
        return writer;
    };

    /**
     * Encodes the specified C2S_Shenyou message, length delimited. Does not implicitly {@link C2S_Shenyou.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Shenyou
     * @static
     * @param {IC2S_Shenyou} message C2S_Shenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Shenyou.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Shenyou message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Shenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Shenyou} C2S_Shenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Shenyou.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Shenyou();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.count = reader.int32();
                break;
            case 2:
                message.mapId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Shenyou message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Shenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Shenyou} C2S_Shenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Shenyou.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Shenyou message.
     * @function verify
     * @memberof C2S_Shenyou
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Shenyou.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            if (!$util.isInteger(message.mapId))
                return "mapId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_Shenyou message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Shenyou
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Shenyou} C2S_Shenyou
     */
    C2S_Shenyou.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Shenyou)
            return object;
        var message = new $root.C2S_Shenyou();
        if (object.count != null)
            message.count = object.count | 0;
        if (object.mapId != null)
            message.mapId = object.mapId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_Shenyou message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Shenyou
     * @static
     * @param {C2S_Shenyou} message C2S_Shenyou
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Shenyou.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.count = 0;
            object.mapId = 0;
        }
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            object.mapId = message.mapId;
        return object;
    };

    /**
     * Converts this C2S_Shenyou to JSON.
     * @function toJSON
     * @memberof C2S_Shenyou
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Shenyou.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Shenyou;
})();

$root.S2C_Shenyou = (function() {

    /**
     * Properties of a S2C_Shenyou.
     * @exports IS2C_Shenyou
     * @interface IS2C_Shenyou
     * @property {number|null} [count] S2C_Shenyou count
     * @property {number|null} [mapId] S2C_Shenyou mapId
     */

    /**
     * Constructs a new S2C_Shenyou.
     * @exports S2C_Shenyou
     * @classdesc Represents a S2C_Shenyou.
     * @implements IS2C_Shenyou
     * @constructor
     * @param {IS2C_Shenyou=} [properties] Properties to set
     */
    function S2C_Shenyou(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Shenyou count.
     * @member {number} count
     * @memberof S2C_Shenyou
     * @instance
     */
    S2C_Shenyou.prototype.count = 0;

    /**
     * S2C_Shenyou mapId.
     * @member {number} mapId
     * @memberof S2C_Shenyou
     * @instance
     */
    S2C_Shenyou.prototype.mapId = 0;

    /**
     * Creates a new S2C_Shenyou instance using the specified properties.
     * @function create
     * @memberof S2C_Shenyou
     * @static
     * @param {IS2C_Shenyou=} [properties] Properties to set
     * @returns {S2C_Shenyou} S2C_Shenyou instance
     */
    S2C_Shenyou.create = function create(properties) {
        return new S2C_Shenyou(properties);
    };

    /**
     * Encodes the specified S2C_Shenyou message. Does not implicitly {@link S2C_Shenyou.verify|verify} messages.
     * @function encode
     * @memberof S2C_Shenyou
     * @static
     * @param {IS2C_Shenyou} message S2C_Shenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Shenyou.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapId);
        return writer;
    };

    /**
     * Encodes the specified S2C_Shenyou message, length delimited. Does not implicitly {@link S2C_Shenyou.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Shenyou
     * @static
     * @param {IS2C_Shenyou} message S2C_Shenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Shenyou.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Shenyou message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Shenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Shenyou} S2C_Shenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Shenyou.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Shenyou();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.count = reader.int32();
                break;
            case 2:
                message.mapId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Shenyou message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Shenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Shenyou} S2C_Shenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Shenyou.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Shenyou message.
     * @function verify
     * @memberof S2C_Shenyou
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Shenyou.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            if (!$util.isInteger(message.mapId))
                return "mapId: integer expected";
        return null;
    };

    /**
     * Creates a S2C_Shenyou message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Shenyou
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Shenyou} S2C_Shenyou
     */
    S2C_Shenyou.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Shenyou)
            return object;
        var message = new $root.S2C_Shenyou();
        if (object.count != null)
            message.count = object.count | 0;
        if (object.mapId != null)
            message.mapId = object.mapId | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_Shenyou message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Shenyou
     * @static
     * @param {S2C_Shenyou} message S2C_Shenyou
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Shenyou.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.count = 0;
            object.mapId = 0;
        }
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            object.mapId = message.mapId;
        return object;
    };

    /**
     * Converts this S2C_Shenyou to JSON.
     * @function toJSON
     * @memberof S2C_Shenyou
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Shenyou.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Shenyou;
})();

$root.C2S_StopShenyou = (function() {

    /**
     * Properties of a C2S_StopShenyou.
     * @exports IC2S_StopShenyou
     * @interface IC2S_StopShenyou
     */

    /**
     * Constructs a new C2S_StopShenyou.
     * @exports C2S_StopShenyou
     * @classdesc Represents a C2S_StopShenyou.
     * @implements IC2S_StopShenyou
     * @constructor
     * @param {IC2S_StopShenyou=} [properties] Properties to set
     */
    function C2S_StopShenyou(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_StopShenyou instance using the specified properties.
     * @function create
     * @memberof C2S_StopShenyou
     * @static
     * @param {IC2S_StopShenyou=} [properties] Properties to set
     * @returns {C2S_StopShenyou} C2S_StopShenyou instance
     */
    C2S_StopShenyou.create = function create(properties) {
        return new C2S_StopShenyou(properties);
    };

    /**
     * Encodes the specified C2S_StopShenyou message. Does not implicitly {@link C2S_StopShenyou.verify|verify} messages.
     * @function encode
     * @memberof C2S_StopShenyou
     * @static
     * @param {IC2S_StopShenyou} message C2S_StopShenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_StopShenyou.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_StopShenyou message, length delimited. Does not implicitly {@link C2S_StopShenyou.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_StopShenyou
     * @static
     * @param {IC2S_StopShenyou} message C2S_StopShenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_StopShenyou.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_StopShenyou message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_StopShenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_StopShenyou} C2S_StopShenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_StopShenyou.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_StopShenyou();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_StopShenyou message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_StopShenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_StopShenyou} C2S_StopShenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_StopShenyou.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_StopShenyou message.
     * @function verify
     * @memberof C2S_StopShenyou
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_StopShenyou.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_StopShenyou message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_StopShenyou
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_StopShenyou} C2S_StopShenyou
     */
    C2S_StopShenyou.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_StopShenyou)
            return object;
        return new $root.C2S_StopShenyou();
    };

    /**
     * Creates a plain object from a C2S_StopShenyou message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_StopShenyou
     * @static
     * @param {C2S_StopShenyou} message C2S_StopShenyou
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_StopShenyou.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_StopShenyou to JSON.
     * @function toJSON
     * @memberof C2S_StopShenyou
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_StopShenyou.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_StopShenyou;
})();

$root.S2C_StopShenyou = (function() {

    /**
     * Properties of a S2C_StopShenyou.
     * @exports IS2C_StopShenyou
     * @interface IS2C_StopShenyou
     */

    /**
     * Constructs a new S2C_StopShenyou.
     * @exports S2C_StopShenyou
     * @classdesc Represents a S2C_StopShenyou.
     * @implements IS2C_StopShenyou
     * @constructor
     * @param {IS2C_StopShenyou=} [properties] Properties to set
     */
    function S2C_StopShenyou(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_StopShenyou instance using the specified properties.
     * @function create
     * @memberof S2C_StopShenyou
     * @static
     * @param {IS2C_StopShenyou=} [properties] Properties to set
     * @returns {S2C_StopShenyou} S2C_StopShenyou instance
     */
    S2C_StopShenyou.create = function create(properties) {
        return new S2C_StopShenyou(properties);
    };

    /**
     * Encodes the specified S2C_StopShenyou message. Does not implicitly {@link S2C_StopShenyou.verify|verify} messages.
     * @function encode
     * @memberof S2C_StopShenyou
     * @static
     * @param {IS2C_StopShenyou} message S2C_StopShenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_StopShenyou.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_StopShenyou message, length delimited. Does not implicitly {@link S2C_StopShenyou.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_StopShenyou
     * @static
     * @param {IS2C_StopShenyou} message S2C_StopShenyou message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_StopShenyou.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_StopShenyou message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_StopShenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_StopShenyou} S2C_StopShenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_StopShenyou.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_StopShenyou();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_StopShenyou message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_StopShenyou
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_StopShenyou} S2C_StopShenyou
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_StopShenyou.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_StopShenyou message.
     * @function verify
     * @memberof S2C_StopShenyou
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_StopShenyou.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_StopShenyou message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_StopShenyou
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_StopShenyou} S2C_StopShenyou
     */
    S2C_StopShenyou.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_StopShenyou)
            return object;
        return new $root.S2C_StopShenyou();
    };

    /**
     * Creates a plain object from a S2C_StopShenyou message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_StopShenyou
     * @static
     * @param {S2C_StopShenyou} message S2C_StopShenyou
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_StopShenyou.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_StopShenyou to JSON.
     * @function toJSON
     * @memberof S2C_StopShenyou
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_StopShenyou.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_StopShenyou;
})();

$root.S2C_ShenyouLog = (function() {

    /**
     * Properties of a S2C_ShenyouLog.
     * @exports IS2C_ShenyouLog
     * @interface IS2C_ShenyouLog
     * @property {number|null} [mapId] S2C_ShenyouLog mapId
     * @property {string|null} [npcName] S2C_ShenyouLog npcName
     * @property {Array.<IResourceMsg>|null} [drop] S2C_ShenyouLog drop
     */

    /**
     * Constructs a new S2C_ShenyouLog.
     * @exports S2C_ShenyouLog
     * @classdesc Represents a S2C_ShenyouLog.
     * @implements IS2C_ShenyouLog
     * @constructor
     * @param {IS2C_ShenyouLog=} [properties] Properties to set
     */
    function S2C_ShenyouLog(properties) {
        this.drop = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ShenyouLog mapId.
     * @member {number} mapId
     * @memberof S2C_ShenyouLog
     * @instance
     */
    S2C_ShenyouLog.prototype.mapId = 0;

    /**
     * S2C_ShenyouLog npcName.
     * @member {string} npcName
     * @memberof S2C_ShenyouLog
     * @instance
     */
    S2C_ShenyouLog.prototype.npcName = "";

    /**
     * S2C_ShenyouLog drop.
     * @member {Array.<IResourceMsg>} drop
     * @memberof S2C_ShenyouLog
     * @instance
     */
    S2C_ShenyouLog.prototype.drop = $util.emptyArray;

    /**
     * Creates a new S2C_ShenyouLog instance using the specified properties.
     * @function create
     * @memberof S2C_ShenyouLog
     * @static
     * @param {IS2C_ShenyouLog=} [properties] Properties to set
     * @returns {S2C_ShenyouLog} S2C_ShenyouLog instance
     */
    S2C_ShenyouLog.create = function create(properties) {
        return new S2C_ShenyouLog(properties);
    };

    /**
     * Encodes the specified S2C_ShenyouLog message. Does not implicitly {@link S2C_ShenyouLog.verify|verify} messages.
     * @function encode
     * @memberof S2C_ShenyouLog
     * @static
     * @param {IS2C_ShenyouLog} message S2C_ShenyouLog message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ShenyouLog.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mapId);
        if (message.npcName != null && message.hasOwnProperty("npcName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.npcName);
        if (message.drop != null && message.drop.length)
            for (var i = 0; i < message.drop.length; ++i)
                $root.ResourceMsg.encode(message.drop[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_ShenyouLog message, length delimited. Does not implicitly {@link S2C_ShenyouLog.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ShenyouLog
     * @static
     * @param {IS2C_ShenyouLog} message S2C_ShenyouLog message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ShenyouLog.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ShenyouLog message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ShenyouLog
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ShenyouLog} S2C_ShenyouLog
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ShenyouLog.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ShenyouLog();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.mapId = reader.int32();
                break;
            case 2:
                message.npcName = reader.string();
                break;
            case 5:
                if (!(message.drop && message.drop.length))
                    message.drop = [];
                message.drop.push($root.ResourceMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ShenyouLog message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ShenyouLog
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ShenyouLog} S2C_ShenyouLog
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ShenyouLog.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ShenyouLog message.
     * @function verify
     * @memberof S2C_ShenyouLog
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ShenyouLog.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            if (!$util.isInteger(message.mapId))
                return "mapId: integer expected";
        if (message.npcName != null && message.hasOwnProperty("npcName"))
            if (!$util.isString(message.npcName))
                return "npcName: string expected";
        if (message.drop != null && message.hasOwnProperty("drop")) {
            if (!Array.isArray(message.drop))
                return "drop: array expected";
            for (var i = 0; i < message.drop.length; ++i) {
                var error = $root.ResourceMsg.verify(message.drop[i]);
                if (error)
                    return "drop." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_ShenyouLog message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ShenyouLog
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ShenyouLog} S2C_ShenyouLog
     */
    S2C_ShenyouLog.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ShenyouLog)
            return object;
        var message = new $root.S2C_ShenyouLog();
        if (object.mapId != null)
            message.mapId = object.mapId | 0;
        if (object.npcName != null)
            message.npcName = String(object.npcName);
        if (object.drop) {
            if (!Array.isArray(object.drop))
                throw TypeError(".S2C_ShenyouLog.drop: array expected");
            message.drop = [];
            for (var i = 0; i < object.drop.length; ++i) {
                if (typeof object.drop[i] !== "object")
                    throw TypeError(".S2C_ShenyouLog.drop: object expected");
                message.drop[i] = $root.ResourceMsg.fromObject(object.drop[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_ShenyouLog message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ShenyouLog
     * @static
     * @param {S2C_ShenyouLog} message S2C_ShenyouLog
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ShenyouLog.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.drop = [];
        if (options.defaults) {
            object.mapId = 0;
            object.npcName = "";
        }
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            object.mapId = message.mapId;
        if (message.npcName != null && message.hasOwnProperty("npcName"))
            object.npcName = message.npcName;
        if (message.drop && message.drop.length) {
            object.drop = [];
            for (var j = 0; j < message.drop.length; ++j)
                object.drop[j] = $root.ResourceMsg.toObject(message.drop[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_ShenyouLog to JSON.
     * @function toJSON
     * @memberof S2C_ShenyouLog
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ShenyouLog.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ShenyouLog;
})();

$root.C2S_ShenyouInfo = (function() {

    /**
     * Properties of a C2S_ShenyouInfo.
     * @exports IC2S_ShenyouInfo
     * @interface IC2S_ShenyouInfo
     */

    /**
     * Constructs a new C2S_ShenyouInfo.
     * @exports C2S_ShenyouInfo
     * @classdesc Represents a C2S_ShenyouInfo.
     * @implements IC2S_ShenyouInfo
     * @constructor
     * @param {IC2S_ShenyouInfo=} [properties] Properties to set
     */
    function C2S_ShenyouInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_ShenyouInfo instance using the specified properties.
     * @function create
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {IC2S_ShenyouInfo=} [properties] Properties to set
     * @returns {C2S_ShenyouInfo} C2S_ShenyouInfo instance
     */
    C2S_ShenyouInfo.create = function create(properties) {
        return new C2S_ShenyouInfo(properties);
    };

    /**
     * Encodes the specified C2S_ShenyouInfo message. Does not implicitly {@link C2S_ShenyouInfo.verify|verify} messages.
     * @function encode
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {IC2S_ShenyouInfo} message C2S_ShenyouInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ShenyouInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_ShenyouInfo message, length delimited. Does not implicitly {@link C2S_ShenyouInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {IC2S_ShenyouInfo} message C2S_ShenyouInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ShenyouInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_ShenyouInfo message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_ShenyouInfo} C2S_ShenyouInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ShenyouInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_ShenyouInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_ShenyouInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_ShenyouInfo} C2S_ShenyouInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ShenyouInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_ShenyouInfo message.
     * @function verify
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_ShenyouInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_ShenyouInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_ShenyouInfo} C2S_ShenyouInfo
     */
    C2S_ShenyouInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_ShenyouInfo)
            return object;
        return new $root.C2S_ShenyouInfo();
    };

    /**
     * Creates a plain object from a C2S_ShenyouInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_ShenyouInfo
     * @static
     * @param {C2S_ShenyouInfo} message C2S_ShenyouInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_ShenyouInfo.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_ShenyouInfo to JSON.
     * @function toJSON
     * @memberof C2S_ShenyouInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_ShenyouInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_ShenyouInfo;
})();

$root.S2C_ShenyouInfo = (function() {

    /**
     * Properties of a S2C_ShenyouInfo.
     * @exports IS2C_ShenyouInfo
     * @interface IS2C_ShenyouInfo
     * @property {number|null} [mapId] S2C_ShenyouInfo mapId
     * @property {boolean|null} [autoSell] S2C_ShenyouInfo autoSell
     * @property {Array.<number>|null} [autoSellItem] S2C_ShenyouInfo autoSellItem
     * @property {boolean|null} [quick] S2C_ShenyouInfo quick
     * @property {boolean|null} [autoFight] S2C_ShenyouInfo autoFight
     * @property {number|null} [count] S2C_ShenyouInfo count
     * @property {number|null} [currentCount] S2C_ShenyouInfo currentCount
     * @property {number|null} [stepIndex] S2C_ShenyouInfo stepIndex
     * @property {number|Long|null} [startTime] S2C_ShenyouInfo startTime
     * @property {number|Long|null} [endTime] S2C_ShenyouInfo endTime
     * @property {number|null} [fightMapCount] S2C_ShenyouInfo fightMapCount
     */

    /**
     * Constructs a new S2C_ShenyouInfo.
     * @exports S2C_ShenyouInfo
     * @classdesc Represents a S2C_ShenyouInfo.
     * @implements IS2C_ShenyouInfo
     * @constructor
     * @param {IS2C_ShenyouInfo=} [properties] Properties to set
     */
    function S2C_ShenyouInfo(properties) {
        this.autoSellItem = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ShenyouInfo mapId.
     * @member {number} mapId
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.mapId = 0;

    /**
     * S2C_ShenyouInfo autoSell.
     * @member {boolean} autoSell
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.autoSell = false;

    /**
     * S2C_ShenyouInfo autoSellItem.
     * @member {Array.<number>} autoSellItem
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.autoSellItem = $util.emptyArray;

    /**
     * S2C_ShenyouInfo quick.
     * @member {boolean} quick
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.quick = false;

    /**
     * S2C_ShenyouInfo autoFight.
     * @member {boolean} autoFight
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.autoFight = false;

    /**
     * S2C_ShenyouInfo count.
     * @member {number} count
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.count = 0;

    /**
     * S2C_ShenyouInfo currentCount.
     * @member {number} currentCount
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.currentCount = 0;

    /**
     * S2C_ShenyouInfo stepIndex.
     * @member {number} stepIndex
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.stepIndex = 0;

    /**
     * S2C_ShenyouInfo startTime.
     * @member {number|Long} startTime
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_ShenyouInfo endTime.
     * @member {number|Long} endTime
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_ShenyouInfo fightMapCount.
     * @member {number} fightMapCount
     * @memberof S2C_ShenyouInfo
     * @instance
     */
    S2C_ShenyouInfo.prototype.fightMapCount = 0;

    /**
     * Creates a new S2C_ShenyouInfo instance using the specified properties.
     * @function create
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {IS2C_ShenyouInfo=} [properties] Properties to set
     * @returns {S2C_ShenyouInfo} S2C_ShenyouInfo instance
     */
    S2C_ShenyouInfo.create = function create(properties) {
        return new S2C_ShenyouInfo(properties);
    };

    /**
     * Encodes the specified S2C_ShenyouInfo message. Does not implicitly {@link S2C_ShenyouInfo.verify|verify} messages.
     * @function encode
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {IS2C_ShenyouInfo} message S2C_ShenyouInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ShenyouInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mapId);
        if (message.autoSell != null && message.hasOwnProperty("autoSell"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.autoSell);
        if (message.autoSellItem != null && message.autoSellItem.length)
            for (var i = 0; i < message.autoSellItem.length; ++i)
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.autoSellItem[i]);
        if (message.quick != null && message.hasOwnProperty("quick"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.quick);
        if (message.autoFight != null && message.hasOwnProperty("autoFight"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoFight);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.count);
        if (message.currentCount != null && message.hasOwnProperty("currentCount"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.currentCount);
        if (message.stepIndex != null && message.hasOwnProperty("stepIndex"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.stepIndex);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.startTime);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            writer.uint32(/* id 10, wireType 0 =*/80).int64(message.endTime);
        if (message.fightMapCount != null && message.hasOwnProperty("fightMapCount"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.fightMapCount);
        return writer;
    };

    /**
     * Encodes the specified S2C_ShenyouInfo message, length delimited. Does not implicitly {@link S2C_ShenyouInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {IS2C_ShenyouInfo} message S2C_ShenyouInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ShenyouInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ShenyouInfo message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ShenyouInfo} S2C_ShenyouInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ShenyouInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ShenyouInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.mapId = reader.int32();
                break;
            case 2:
                message.autoSell = reader.bool();
                break;
            case 3:
                if (!(message.autoSellItem && message.autoSellItem.length))
                    message.autoSellItem = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.autoSellItem.push(reader.int32());
                } else
                    message.autoSellItem.push(reader.int32());
                break;
            case 4:
                message.quick = reader.bool();
                break;
            case 5:
                message.autoFight = reader.bool();
                break;
            case 6:
                message.count = reader.int32();
                break;
            case 7:
                message.currentCount = reader.int32();
                break;
            case 8:
                message.stepIndex = reader.int32();
                break;
            case 9:
                message.startTime = reader.int64();
                break;
            case 10:
                message.endTime = reader.int64();
                break;
            case 11:
                message.fightMapCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ShenyouInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ShenyouInfo} S2C_ShenyouInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ShenyouInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ShenyouInfo message.
     * @function verify
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ShenyouInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            if (!$util.isInteger(message.mapId))
                return "mapId: integer expected";
        if (message.autoSell != null && message.hasOwnProperty("autoSell"))
            if (typeof message.autoSell !== "boolean")
                return "autoSell: boolean expected";
        if (message.autoSellItem != null && message.hasOwnProperty("autoSellItem")) {
            if (!Array.isArray(message.autoSellItem))
                return "autoSellItem: array expected";
            for (var i = 0; i < message.autoSellItem.length; ++i)
                if (!$util.isInteger(message.autoSellItem[i]))
                    return "autoSellItem: integer[] expected";
        }
        if (message.quick != null && message.hasOwnProperty("quick"))
            if (typeof message.quick !== "boolean")
                return "quick: boolean expected";
        if (message.autoFight != null && message.hasOwnProperty("autoFight"))
            if (typeof message.autoFight !== "boolean")
                return "autoFight: boolean expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        if (message.currentCount != null && message.hasOwnProperty("currentCount"))
            if (!$util.isInteger(message.currentCount))
                return "currentCount: integer expected";
        if (message.stepIndex != null && message.hasOwnProperty("stepIndex"))
            if (!$util.isInteger(message.stepIndex))
                return "stepIndex: integer expected";
        if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                return "startTime: integer|Long expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                return "endTime: integer|Long expected";
        if (message.fightMapCount != null && message.hasOwnProperty("fightMapCount"))
            if (!$util.isInteger(message.fightMapCount))
                return "fightMapCount: integer expected";
        return null;
    };

    /**
     * Creates a S2C_ShenyouInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ShenyouInfo} S2C_ShenyouInfo
     */
    S2C_ShenyouInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ShenyouInfo)
            return object;
        var message = new $root.S2C_ShenyouInfo();
        if (object.mapId != null)
            message.mapId = object.mapId | 0;
        if (object.autoSell != null)
            message.autoSell = Boolean(object.autoSell);
        if (object.autoSellItem) {
            if (!Array.isArray(object.autoSellItem))
                throw TypeError(".S2C_ShenyouInfo.autoSellItem: array expected");
            message.autoSellItem = [];
            for (var i = 0; i < object.autoSellItem.length; ++i)
                message.autoSellItem[i] = object.autoSellItem[i] | 0;
        }
        if (object.quick != null)
            message.quick = Boolean(object.quick);
        if (object.autoFight != null)
            message.autoFight = Boolean(object.autoFight);
        if (object.count != null)
            message.count = object.count | 0;
        if (object.currentCount != null)
            message.currentCount = object.currentCount | 0;
        if (object.stepIndex != null)
            message.stepIndex = object.stepIndex | 0;
        if (object.startTime != null)
            if ($util.Long)
                (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
            else if (typeof object.startTime === "string")
                message.startTime = parseInt(object.startTime, 10);
            else if (typeof object.startTime === "number")
                message.startTime = object.startTime;
            else if (typeof object.startTime === "object")
                message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
        if (object.endTime != null)
            if ($util.Long)
                (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
            else if (typeof object.endTime === "string")
                message.endTime = parseInt(object.endTime, 10);
            else if (typeof object.endTime === "number")
                message.endTime = object.endTime;
            else if (typeof object.endTime === "object")
                message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
        if (object.fightMapCount != null)
            message.fightMapCount = object.fightMapCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_ShenyouInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ShenyouInfo
     * @static
     * @param {S2C_ShenyouInfo} message S2C_ShenyouInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ShenyouInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.autoSellItem = [];
        if (options.defaults) {
            object.mapId = 0;
            object.autoSell = false;
            object.quick = false;
            object.autoFight = false;
            object.count = 0;
            object.currentCount = 0;
            object.stepIndex = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.startTime = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.endTime = options.longs === String ? "0" : 0;
            object.fightMapCount = 0;
        }
        if (message.mapId != null && message.hasOwnProperty("mapId"))
            object.mapId = message.mapId;
        if (message.autoSell != null && message.hasOwnProperty("autoSell"))
            object.autoSell = message.autoSell;
        if (message.autoSellItem && message.autoSellItem.length) {
            object.autoSellItem = [];
            for (var j = 0; j < message.autoSellItem.length; ++j)
                object.autoSellItem[j] = message.autoSellItem[j];
        }
        if (message.quick != null && message.hasOwnProperty("quick"))
            object.quick = message.quick;
        if (message.autoFight != null && message.hasOwnProperty("autoFight"))
            object.autoFight = message.autoFight;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        if (message.currentCount != null && message.hasOwnProperty("currentCount"))
            object.currentCount = message.currentCount;
        if (message.stepIndex != null && message.hasOwnProperty("stepIndex"))
            object.stepIndex = message.stepIndex;
        if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
                object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
                object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
                object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
                object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
        if (message.fightMapCount != null && message.hasOwnProperty("fightMapCount"))
            object.fightMapCount = message.fightMapCount;
        return object;
    };

    /**
     * Converts this S2C_ShenyouInfo to JSON.
     * @function toJSON
     * @memberof S2C_ShenyouInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ShenyouInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ShenyouInfo;
})();

$root.MailMsg = (function() {

    /**
     * Properties of a MailMsg.
     * @exports IMailMsg
     * @interface IMailMsg
     * @property {number|Long|null} [id] MailMsg id
     * @property {string|null} [title] MailMsg title
     * @property {string|null} [content] MailMsg content
     * @property {string|null} [reward] MailMsg reward
     * @property {boolean|null} [received] MailMsg received
     * @property {boolean|null} [read] MailMsg read
     */

    /**
     * Constructs a new MailMsg.
     * @exports MailMsg
     * @classdesc Represents a MailMsg.
     * @implements IMailMsg
     * @constructor
     * @param {IMailMsg=} [properties] Properties to set
     */
    function MailMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MailMsg id.
     * @member {number|Long} id
     * @memberof MailMsg
     * @instance
     */
    MailMsg.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * MailMsg title.
     * @member {string} title
     * @memberof MailMsg
     * @instance
     */
    MailMsg.prototype.title = "";

    /**
     * MailMsg content.
     * @member {string} content
     * @memberof MailMsg
     * @instance
     */
    MailMsg.prototype.content = "";

    /**
     * MailMsg reward.
     * @member {string} reward
     * @memberof MailMsg
     * @instance
     */
    MailMsg.prototype.reward = "";

    /**
     * MailMsg received.
     * @member {boolean} received
     * @memberof MailMsg
     * @instance
     */
    MailMsg.prototype.received = false;

    /**
     * MailMsg read.
     * @member {boolean} read
     * @memberof MailMsg
     * @instance
     */
    MailMsg.prototype.read = false;

    /**
     * Creates a new MailMsg instance using the specified properties.
     * @function create
     * @memberof MailMsg
     * @static
     * @param {IMailMsg=} [properties] Properties to set
     * @returns {MailMsg} MailMsg instance
     */
    MailMsg.create = function create(properties) {
        return new MailMsg(properties);
    };

    /**
     * Encodes the specified MailMsg message. Does not implicitly {@link MailMsg.verify|verify} messages.
     * @function encode
     * @memberof MailMsg
     * @static
     * @param {IMailMsg} message MailMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MailMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
        if (message.title != null && message.hasOwnProperty("title"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
        if (message.content != null && message.hasOwnProperty("content"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
        if (message.reward != null && message.hasOwnProperty("reward"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.reward);
        if (message.received != null && message.hasOwnProperty("received"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.received);
        if (message.read != null && message.hasOwnProperty("read"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.read);
        return writer;
    };

    /**
     * Encodes the specified MailMsg message, length delimited. Does not implicitly {@link MailMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MailMsg
     * @static
     * @param {IMailMsg} message MailMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MailMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MailMsg message from the specified reader or buffer.
     * @function decode
     * @memberof MailMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MailMsg} MailMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MailMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MailMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int64();
                break;
            case 2:
                message.title = reader.string();
                break;
            case 3:
                message.content = reader.string();
                break;
            case 4:
                message.reward = reader.string();
                break;
            case 5:
                message.received = reader.bool();
                break;
            case 6:
                message.read = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MailMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MailMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MailMsg} MailMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MailMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MailMsg message.
     * @function verify
     * @memberof MailMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MailMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.content != null && message.hasOwnProperty("content"))
            if (!$util.isString(message.content))
                return "content: string expected";
        if (message.reward != null && message.hasOwnProperty("reward"))
            if (!$util.isString(message.reward))
                return "reward: string expected";
        if (message.received != null && message.hasOwnProperty("received"))
            if (typeof message.received !== "boolean")
                return "received: boolean expected";
        if (message.read != null && message.hasOwnProperty("read"))
            if (typeof message.read !== "boolean")
                return "read: boolean expected";
        return null;
    };

    /**
     * Creates a MailMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MailMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MailMsg} MailMsg
     */
    MailMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.MailMsg)
            return object;
        var message = new $root.MailMsg();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.title != null)
            message.title = String(object.title);
        if (object.content != null)
            message.content = String(object.content);
        if (object.reward != null)
            message.reward = String(object.reward);
        if (object.received != null)
            message.received = Boolean(object.received);
        if (object.read != null)
            message.read = Boolean(object.read);
        return message;
    };

    /**
     * Creates a plain object from a MailMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MailMsg
     * @static
     * @param {MailMsg} message MailMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MailMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.title = "";
            object.content = "";
            object.reward = "";
            object.received = false;
            object.read = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.content != null && message.hasOwnProperty("content"))
            object.content = message.content;
        if (message.reward != null && message.hasOwnProperty("reward"))
            object.reward = message.reward;
        if (message.received != null && message.hasOwnProperty("received"))
            object.received = message.received;
        if (message.read != null && message.hasOwnProperty("read"))
            object.read = message.read;
        return object;
    };

    /**
     * Converts this MailMsg to JSON.
     * @function toJSON
     * @memberof MailMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MailMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MailMsg;
})();

/**
 * MailOptType enum.
 * @exports MailOptType
 * @enum {string}
 * @property {number} READ=1 READ value
 * @property {number} RECEIVE=2 RECEIVE value
 * @property {number} DELETE=3 DELETE value
 */
$root.MailOptType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "READ"] = 1;
    values[valuesById[2] = "RECEIVE"] = 2;
    values[valuesById[3] = "DELETE"] = 3;
    return values;
})();

$root.C2S_MailList = (function() {

    /**
     * Properties of a C2S_MailList.
     * @exports IC2S_MailList
     * @interface IC2S_MailList
     */

    /**
     * Constructs a new C2S_MailList.
     * @exports C2S_MailList
     * @classdesc Represents a C2S_MailList.
     * @implements IC2S_MailList
     * @constructor
     * @param {IC2S_MailList=} [properties] Properties to set
     */
    function C2S_MailList(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_MailList instance using the specified properties.
     * @function create
     * @memberof C2S_MailList
     * @static
     * @param {IC2S_MailList=} [properties] Properties to set
     * @returns {C2S_MailList} C2S_MailList instance
     */
    C2S_MailList.create = function create(properties) {
        return new C2S_MailList(properties);
    };

    /**
     * Encodes the specified C2S_MailList message. Does not implicitly {@link C2S_MailList.verify|verify} messages.
     * @function encode
     * @memberof C2S_MailList
     * @static
     * @param {IC2S_MailList} message C2S_MailList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MailList.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_MailList message, length delimited. Does not implicitly {@link C2S_MailList.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MailList
     * @static
     * @param {IC2S_MailList} message C2S_MailList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MailList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MailList message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MailList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MailList} C2S_MailList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MailList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MailList();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MailList message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MailList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MailList} C2S_MailList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MailList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MailList message.
     * @function verify
     * @memberof C2S_MailList
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MailList.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_MailList message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MailList
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MailList} C2S_MailList
     */
    C2S_MailList.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MailList)
            return object;
        return new $root.C2S_MailList();
    };

    /**
     * Creates a plain object from a C2S_MailList message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MailList
     * @static
     * @param {C2S_MailList} message C2S_MailList
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MailList.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_MailList to JSON.
     * @function toJSON
     * @memberof C2S_MailList
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MailList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MailList;
})();

$root.S2C_MailList = (function() {

    /**
     * Properties of a S2C_MailList.
     * @exports IS2C_MailList
     * @interface IS2C_MailList
     * @property {Array.<IMailMsg>|null} [mails] S2C_MailList mails
     */

    /**
     * Constructs a new S2C_MailList.
     * @exports S2C_MailList
     * @classdesc Represents a S2C_MailList.
     * @implements IS2C_MailList
     * @constructor
     * @param {IS2C_MailList=} [properties] Properties to set
     */
    function S2C_MailList(properties) {
        this.mails = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MailList mails.
     * @member {Array.<IMailMsg>} mails
     * @memberof S2C_MailList
     * @instance
     */
    S2C_MailList.prototype.mails = $util.emptyArray;

    /**
     * Creates a new S2C_MailList instance using the specified properties.
     * @function create
     * @memberof S2C_MailList
     * @static
     * @param {IS2C_MailList=} [properties] Properties to set
     * @returns {S2C_MailList} S2C_MailList instance
     */
    S2C_MailList.create = function create(properties) {
        return new S2C_MailList(properties);
    };

    /**
     * Encodes the specified S2C_MailList message. Does not implicitly {@link S2C_MailList.verify|verify} messages.
     * @function encode
     * @memberof S2C_MailList
     * @static
     * @param {IS2C_MailList} message S2C_MailList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MailList.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mails != null && message.mails.length)
            for (var i = 0; i < message.mails.length; ++i)
                $root.MailMsg.encode(message.mails[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_MailList message, length delimited. Does not implicitly {@link S2C_MailList.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MailList
     * @static
     * @param {IS2C_MailList} message S2C_MailList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MailList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MailList message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MailList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MailList} S2C_MailList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MailList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MailList();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.mails && message.mails.length))
                    message.mails = [];
                message.mails.push($root.MailMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MailList message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MailList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MailList} S2C_MailList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MailList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MailList message.
     * @function verify
     * @memberof S2C_MailList
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MailList.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mails != null && message.hasOwnProperty("mails")) {
            if (!Array.isArray(message.mails))
                return "mails: array expected";
            for (var i = 0; i < message.mails.length; ++i) {
                var error = $root.MailMsg.verify(message.mails[i]);
                if (error)
                    return "mails." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_MailList message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MailList
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MailList} S2C_MailList
     */
    S2C_MailList.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MailList)
            return object;
        var message = new $root.S2C_MailList();
        if (object.mails) {
            if (!Array.isArray(object.mails))
                throw TypeError(".S2C_MailList.mails: array expected");
            message.mails = [];
            for (var i = 0; i < object.mails.length; ++i) {
                if (typeof object.mails[i] !== "object")
                    throw TypeError(".S2C_MailList.mails: object expected");
                message.mails[i] = $root.MailMsg.fromObject(object.mails[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_MailList message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MailList
     * @static
     * @param {S2C_MailList} message S2C_MailList
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MailList.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.mails = [];
        if (message.mails && message.mails.length) {
            object.mails = [];
            for (var j = 0; j < message.mails.length; ++j)
                object.mails[j] = $root.MailMsg.toObject(message.mails[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_MailList to JSON.
     * @function toJSON
     * @memberof S2C_MailList
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MailList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MailList;
})();

$root.C2S_MailOperate = (function() {

    /**
     * Properties of a C2S_MailOperate.
     * @exports IC2S_MailOperate
     * @interface IC2S_MailOperate
     * @property {MailOptType|null} [type] C2S_MailOperate type
     * @property {number|Long|null} [id] C2S_MailOperate id
     */

    /**
     * Constructs a new C2S_MailOperate.
     * @exports C2S_MailOperate
     * @classdesc Represents a C2S_MailOperate.
     * @implements IC2S_MailOperate
     * @constructor
     * @param {IC2S_MailOperate=} [properties] Properties to set
     */
    function C2S_MailOperate(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MailOperate type.
     * @member {MailOptType} type
     * @memberof C2S_MailOperate
     * @instance
     */
    C2S_MailOperate.prototype.type = 1;

    /**
     * C2S_MailOperate id.
     * @member {number|Long} id
     * @memberof C2S_MailOperate
     * @instance
     */
    C2S_MailOperate.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new C2S_MailOperate instance using the specified properties.
     * @function create
     * @memberof C2S_MailOperate
     * @static
     * @param {IC2S_MailOperate=} [properties] Properties to set
     * @returns {C2S_MailOperate} C2S_MailOperate instance
     */
    C2S_MailOperate.create = function create(properties) {
        return new C2S_MailOperate(properties);
    };

    /**
     * Encodes the specified C2S_MailOperate message. Does not implicitly {@link C2S_MailOperate.verify|verify} messages.
     * @function encode
     * @memberof C2S_MailOperate
     * @static
     * @param {IC2S_MailOperate} message C2S_MailOperate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MailOperate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_MailOperate message, length delimited. Does not implicitly {@link C2S_MailOperate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MailOperate
     * @static
     * @param {IC2S_MailOperate} message C2S_MailOperate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MailOperate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MailOperate message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MailOperate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MailOperate} C2S_MailOperate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MailOperate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MailOperate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.id = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MailOperate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MailOperate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MailOperate} C2S_MailOperate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MailOperate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MailOperate message.
     * @function verify
     * @memberof C2S_MailOperate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MailOperate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
                break;
            }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a C2S_MailOperate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MailOperate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MailOperate} C2S_MailOperate
     */
    C2S_MailOperate.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MailOperate)
            return object;
        var message = new $root.C2S_MailOperate();
        switch (object.type) {
        case "READ":
        case 1:
            message.type = 1;
            break;
        case "RECEIVE":
        case 2:
            message.type = 2;
            break;
        case "DELETE":
        case 3:
            message.type = 3;
            break;
        }
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a C2S_MailOperate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MailOperate
     * @static
     * @param {C2S_MailOperate} message C2S_MailOperate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MailOperate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "READ" : 1;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.MailOptType[message.type] : message.type;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        return object;
    };

    /**
     * Converts this C2S_MailOperate to JSON.
     * @function toJSON
     * @memberof C2S_MailOperate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MailOperate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MailOperate;
})();

$root.S2C_MailOperate = (function() {

    /**
     * Properties of a S2C_MailOperate.
     * @exports IS2C_MailOperate
     * @interface IS2C_MailOperate
     * @property {Array.<IMailMsg>|null} [mails] S2C_MailOperate mails
     * @property {MailOptType|null} [type] S2C_MailOperate type
     */

    /**
     * Constructs a new S2C_MailOperate.
     * @exports S2C_MailOperate
     * @classdesc Represents a S2C_MailOperate.
     * @implements IS2C_MailOperate
     * @constructor
     * @param {IS2C_MailOperate=} [properties] Properties to set
     */
    function S2C_MailOperate(properties) {
        this.mails = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MailOperate mails.
     * @member {Array.<IMailMsg>} mails
     * @memberof S2C_MailOperate
     * @instance
     */
    S2C_MailOperate.prototype.mails = $util.emptyArray;

    /**
     * S2C_MailOperate type.
     * @member {MailOptType} type
     * @memberof S2C_MailOperate
     * @instance
     */
    S2C_MailOperate.prototype.type = 1;

    /**
     * Creates a new S2C_MailOperate instance using the specified properties.
     * @function create
     * @memberof S2C_MailOperate
     * @static
     * @param {IS2C_MailOperate=} [properties] Properties to set
     * @returns {S2C_MailOperate} S2C_MailOperate instance
     */
    S2C_MailOperate.create = function create(properties) {
        return new S2C_MailOperate(properties);
    };

    /**
     * Encodes the specified S2C_MailOperate message. Does not implicitly {@link S2C_MailOperate.verify|verify} messages.
     * @function encode
     * @memberof S2C_MailOperate
     * @static
     * @param {IS2C_MailOperate} message S2C_MailOperate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MailOperate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mails != null && message.mails.length)
            for (var i = 0; i < message.mails.length; ++i)
                $root.MailMsg.encode(message.mails[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified S2C_MailOperate message, length delimited. Does not implicitly {@link S2C_MailOperate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MailOperate
     * @static
     * @param {IS2C_MailOperate} message S2C_MailOperate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MailOperate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MailOperate message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MailOperate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MailOperate} S2C_MailOperate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MailOperate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MailOperate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.mails && message.mails.length))
                    message.mails = [];
                message.mails.push($root.MailMsg.decode(reader, reader.uint32()));
                break;
            case 2:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MailOperate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MailOperate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MailOperate} S2C_MailOperate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MailOperate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MailOperate message.
     * @function verify
     * @memberof S2C_MailOperate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MailOperate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mails != null && message.hasOwnProperty("mails")) {
            if (!Array.isArray(message.mails))
                return "mails: array expected";
            for (var i = 0; i < message.mails.length; ++i) {
                var error = $root.MailMsg.verify(message.mails[i]);
                if (error)
                    return "mails." + error;
            }
        }
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
            case 3:
                break;
            }
        return null;
    };

    /**
     * Creates a S2C_MailOperate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MailOperate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MailOperate} S2C_MailOperate
     */
    S2C_MailOperate.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MailOperate)
            return object;
        var message = new $root.S2C_MailOperate();
        if (object.mails) {
            if (!Array.isArray(object.mails))
                throw TypeError(".S2C_MailOperate.mails: array expected");
            message.mails = [];
            for (var i = 0; i < object.mails.length; ++i) {
                if (typeof object.mails[i] !== "object")
                    throw TypeError(".S2C_MailOperate.mails: object expected");
                message.mails[i] = $root.MailMsg.fromObject(object.mails[i]);
            }
        }
        switch (object.type) {
        case "READ":
        case 1:
            message.type = 1;
            break;
        case "RECEIVE":
        case 2:
            message.type = 2;
            break;
        case "DELETE":
        case 3:
            message.type = 3;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_MailOperate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MailOperate
     * @static
     * @param {S2C_MailOperate} message S2C_MailOperate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MailOperate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.mails = [];
        if (options.defaults)
            object.type = options.enums === String ? "READ" : 1;
        if (message.mails && message.mails.length) {
            object.mails = [];
            for (var j = 0; j < message.mails.length; ++j)
                object.mails[j] = $root.MailMsg.toObject(message.mails[j], options);
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.MailOptType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this S2C_MailOperate to JSON.
     * @function toJSON
     * @memberof S2C_MailOperate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MailOperate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MailOperate;
})();

$root.S2C_NewMail = (function() {

    /**
     * Properties of a S2C_NewMail.
     * @exports IS2C_NewMail
     * @interface IS2C_NewMail
     * @property {number|null} [nCount] S2C_NewMail nCount
     */

    /**
     * Constructs a new S2C_NewMail.
     * @exports S2C_NewMail
     * @classdesc Represents a S2C_NewMail.
     * @implements IS2C_NewMail
     * @constructor
     * @param {IS2C_NewMail=} [properties] Properties to set
     */
    function S2C_NewMail(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_NewMail nCount.
     * @member {number} nCount
     * @memberof S2C_NewMail
     * @instance
     */
    S2C_NewMail.prototype.nCount = 0;

    /**
     * Creates a new S2C_NewMail instance using the specified properties.
     * @function create
     * @memberof S2C_NewMail
     * @static
     * @param {IS2C_NewMail=} [properties] Properties to set
     * @returns {S2C_NewMail} S2C_NewMail instance
     */
    S2C_NewMail.create = function create(properties) {
        return new S2C_NewMail(properties);
    };

    /**
     * Encodes the specified S2C_NewMail message. Does not implicitly {@link S2C_NewMail.verify|verify} messages.
     * @function encode
     * @memberof S2C_NewMail
     * @static
     * @param {IS2C_NewMail} message S2C_NewMail message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_NewMail.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.nCount != null && message.hasOwnProperty("nCount"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nCount);
        return writer;
    };

    /**
     * Encodes the specified S2C_NewMail message, length delimited. Does not implicitly {@link S2C_NewMail.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_NewMail
     * @static
     * @param {IS2C_NewMail} message S2C_NewMail message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_NewMail.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_NewMail message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_NewMail
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_NewMail} S2C_NewMail
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_NewMail.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_NewMail();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.nCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_NewMail message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_NewMail
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_NewMail} S2C_NewMail
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_NewMail.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_NewMail message.
     * @function verify
     * @memberof S2C_NewMail
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_NewMail.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.nCount != null && message.hasOwnProperty("nCount"))
            if (!$util.isInteger(message.nCount))
                return "nCount: integer expected";
        return null;
    };

    /**
     * Creates a S2C_NewMail message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_NewMail
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_NewMail} S2C_NewMail
     */
    S2C_NewMail.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_NewMail)
            return object;
        var message = new $root.S2C_NewMail();
        if (object.nCount != null)
            message.nCount = object.nCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_NewMail message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_NewMail
     * @static
     * @param {S2C_NewMail} message S2C_NewMail
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_NewMail.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.nCount = 0;
        if (message.nCount != null && message.hasOwnProperty("nCount"))
            object.nCount = message.nCount;
        return object;
    };

    /**
     * Converts this S2C_NewMail to JSON.
     * @function toJSON
     * @memberof S2C_NewMail
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_NewMail.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_NewMail;
})();

$root.C2S_JoinMenpai = (function() {

    /**
     * Properties of a C2S_JoinMenpai.
     * @exports IC2S_JoinMenpai
     * @interface IC2S_JoinMenpai
     * @property {number|null} [star] C2S_JoinMenpai star
     */

    /**
     * Constructs a new C2S_JoinMenpai.
     * @exports C2S_JoinMenpai
     * @classdesc Represents a C2S_JoinMenpai.
     * @implements IC2S_JoinMenpai
     * @constructor
     * @param {IC2S_JoinMenpai=} [properties] Properties to set
     */
    function C2S_JoinMenpai(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_JoinMenpai star.
     * @member {number} star
     * @memberof C2S_JoinMenpai
     * @instance
     */
    C2S_JoinMenpai.prototype.star = 0;

    /**
     * Creates a new C2S_JoinMenpai instance using the specified properties.
     * @function create
     * @memberof C2S_JoinMenpai
     * @static
     * @param {IC2S_JoinMenpai=} [properties] Properties to set
     * @returns {C2S_JoinMenpai} C2S_JoinMenpai instance
     */
    C2S_JoinMenpai.create = function create(properties) {
        return new C2S_JoinMenpai(properties);
    };

    /**
     * Encodes the specified C2S_JoinMenpai message. Does not implicitly {@link C2S_JoinMenpai.verify|verify} messages.
     * @function encode
     * @memberof C2S_JoinMenpai
     * @static
     * @param {IC2S_JoinMenpai} message C2S_JoinMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_JoinMenpai.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.star != null && message.hasOwnProperty("star"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.star);
        return writer;
    };

    /**
     * Encodes the specified C2S_JoinMenpai message, length delimited. Does not implicitly {@link C2S_JoinMenpai.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_JoinMenpai
     * @static
     * @param {IC2S_JoinMenpai} message C2S_JoinMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_JoinMenpai.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_JoinMenpai message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_JoinMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_JoinMenpai} C2S_JoinMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_JoinMenpai.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_JoinMenpai();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.star = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_JoinMenpai message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_JoinMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_JoinMenpai} C2S_JoinMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_JoinMenpai.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_JoinMenpai message.
     * @function verify
     * @memberof C2S_JoinMenpai
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_JoinMenpai.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.star != null && message.hasOwnProperty("star"))
            if (!$util.isInteger(message.star))
                return "star: integer expected";
        return null;
    };

    /**
     * Creates a C2S_JoinMenpai message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_JoinMenpai
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_JoinMenpai} C2S_JoinMenpai
     */
    C2S_JoinMenpai.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_JoinMenpai)
            return object;
        var message = new $root.C2S_JoinMenpai();
        if (object.star != null)
            message.star = object.star | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_JoinMenpai message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_JoinMenpai
     * @static
     * @param {C2S_JoinMenpai} message C2S_JoinMenpai
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_JoinMenpai.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.star = 0;
        if (message.star != null && message.hasOwnProperty("star"))
            object.star = message.star;
        return object;
    };

    /**
     * Converts this C2S_JoinMenpai to JSON.
     * @function toJSON
     * @memberof C2S_JoinMenpai
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_JoinMenpai.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_JoinMenpai;
})();

$root.S2C_JoinMenpai = (function() {

    /**
     * Properties of a S2C_JoinMenpai.
     * @exports IS2C_JoinMenpai
     * @interface IS2C_JoinMenpai
     */

    /**
     * Constructs a new S2C_JoinMenpai.
     * @exports S2C_JoinMenpai
     * @classdesc Represents a S2C_JoinMenpai.
     * @implements IS2C_JoinMenpai
     * @constructor
     * @param {IS2C_JoinMenpai=} [properties] Properties to set
     */
    function S2C_JoinMenpai(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_JoinMenpai instance using the specified properties.
     * @function create
     * @memberof S2C_JoinMenpai
     * @static
     * @param {IS2C_JoinMenpai=} [properties] Properties to set
     * @returns {S2C_JoinMenpai} S2C_JoinMenpai instance
     */
    S2C_JoinMenpai.create = function create(properties) {
        return new S2C_JoinMenpai(properties);
    };

    /**
     * Encodes the specified S2C_JoinMenpai message. Does not implicitly {@link S2C_JoinMenpai.verify|verify} messages.
     * @function encode
     * @memberof S2C_JoinMenpai
     * @static
     * @param {IS2C_JoinMenpai} message S2C_JoinMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_JoinMenpai.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_JoinMenpai message, length delimited. Does not implicitly {@link S2C_JoinMenpai.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_JoinMenpai
     * @static
     * @param {IS2C_JoinMenpai} message S2C_JoinMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_JoinMenpai.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_JoinMenpai message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_JoinMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_JoinMenpai} S2C_JoinMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_JoinMenpai.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_JoinMenpai();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_JoinMenpai message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_JoinMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_JoinMenpai} S2C_JoinMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_JoinMenpai.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_JoinMenpai message.
     * @function verify
     * @memberof S2C_JoinMenpai
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_JoinMenpai.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_JoinMenpai message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_JoinMenpai
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_JoinMenpai} S2C_JoinMenpai
     */
    S2C_JoinMenpai.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_JoinMenpai)
            return object;
        return new $root.S2C_JoinMenpai();
    };

    /**
     * Creates a plain object from a S2C_JoinMenpai message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_JoinMenpai
     * @static
     * @param {S2C_JoinMenpai} message S2C_JoinMenpai
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_JoinMenpai.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_JoinMenpai to JSON.
     * @function toJSON
     * @memberof S2C_JoinMenpai
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_JoinMenpai.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_JoinMenpai;
})();

$root.C2S_QuitMenpai = (function() {

    /**
     * Properties of a C2S_QuitMenpai.
     * @exports IC2S_QuitMenpai
     * @interface IC2S_QuitMenpai
     */

    /**
     * Constructs a new C2S_QuitMenpai.
     * @exports C2S_QuitMenpai
     * @classdesc Represents a C2S_QuitMenpai.
     * @implements IC2S_QuitMenpai
     * @constructor
     * @param {IC2S_QuitMenpai=} [properties] Properties to set
     */
    function C2S_QuitMenpai(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_QuitMenpai instance using the specified properties.
     * @function create
     * @memberof C2S_QuitMenpai
     * @static
     * @param {IC2S_QuitMenpai=} [properties] Properties to set
     * @returns {C2S_QuitMenpai} C2S_QuitMenpai instance
     */
    C2S_QuitMenpai.create = function create(properties) {
        return new C2S_QuitMenpai(properties);
    };

    /**
     * Encodes the specified C2S_QuitMenpai message. Does not implicitly {@link C2S_QuitMenpai.verify|verify} messages.
     * @function encode
     * @memberof C2S_QuitMenpai
     * @static
     * @param {IC2S_QuitMenpai} message C2S_QuitMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_QuitMenpai.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_QuitMenpai message, length delimited. Does not implicitly {@link C2S_QuitMenpai.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_QuitMenpai
     * @static
     * @param {IC2S_QuitMenpai} message C2S_QuitMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_QuitMenpai.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_QuitMenpai message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_QuitMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_QuitMenpai} C2S_QuitMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_QuitMenpai.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_QuitMenpai();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_QuitMenpai message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_QuitMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_QuitMenpai} C2S_QuitMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_QuitMenpai.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_QuitMenpai message.
     * @function verify
     * @memberof C2S_QuitMenpai
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_QuitMenpai.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_QuitMenpai message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_QuitMenpai
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_QuitMenpai} C2S_QuitMenpai
     */
    C2S_QuitMenpai.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_QuitMenpai)
            return object;
        return new $root.C2S_QuitMenpai();
    };

    /**
     * Creates a plain object from a C2S_QuitMenpai message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_QuitMenpai
     * @static
     * @param {C2S_QuitMenpai} message C2S_QuitMenpai
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_QuitMenpai.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_QuitMenpai to JSON.
     * @function toJSON
     * @memberof C2S_QuitMenpai
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_QuitMenpai.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_QuitMenpai;
})();

$root.S2C_QuitMenpai = (function() {

    /**
     * Properties of a S2C_QuitMenpai.
     * @exports IS2C_QuitMenpai
     * @interface IS2C_QuitMenpai
     */

    /**
     * Constructs a new S2C_QuitMenpai.
     * @exports S2C_QuitMenpai
     * @classdesc Represents a S2C_QuitMenpai.
     * @implements IS2C_QuitMenpai
     * @constructor
     * @param {IS2C_QuitMenpai=} [properties] Properties to set
     */
    function S2C_QuitMenpai(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_QuitMenpai instance using the specified properties.
     * @function create
     * @memberof S2C_QuitMenpai
     * @static
     * @param {IS2C_QuitMenpai=} [properties] Properties to set
     * @returns {S2C_QuitMenpai} S2C_QuitMenpai instance
     */
    S2C_QuitMenpai.create = function create(properties) {
        return new S2C_QuitMenpai(properties);
    };

    /**
     * Encodes the specified S2C_QuitMenpai message. Does not implicitly {@link S2C_QuitMenpai.verify|verify} messages.
     * @function encode
     * @memberof S2C_QuitMenpai
     * @static
     * @param {IS2C_QuitMenpai} message S2C_QuitMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_QuitMenpai.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_QuitMenpai message, length delimited. Does not implicitly {@link S2C_QuitMenpai.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_QuitMenpai
     * @static
     * @param {IS2C_QuitMenpai} message S2C_QuitMenpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_QuitMenpai.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_QuitMenpai message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_QuitMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_QuitMenpai} S2C_QuitMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_QuitMenpai.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_QuitMenpai();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_QuitMenpai message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_QuitMenpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_QuitMenpai} S2C_QuitMenpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_QuitMenpai.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_QuitMenpai message.
     * @function verify
     * @memberof S2C_QuitMenpai
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_QuitMenpai.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_QuitMenpai message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_QuitMenpai
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_QuitMenpai} S2C_QuitMenpai
     */
    S2C_QuitMenpai.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_QuitMenpai)
            return object;
        return new $root.S2C_QuitMenpai();
    };

    /**
     * Creates a plain object from a S2C_QuitMenpai message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_QuitMenpai
     * @static
     * @param {S2C_QuitMenpai} message S2C_QuitMenpai
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_QuitMenpai.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_QuitMenpai to JSON.
     * @function toJSON
     * @memberof S2C_QuitMenpai
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_QuitMenpai.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_QuitMenpai;
})();

$root.LianGongMsg = (function() {

    /**
     * Properties of a LianGongMsg.
     * @exports ILianGongMsg
     * @interface ILianGongMsg
     * @property {number|null} [id] LianGongMsg id
     * @property {number|Long|null} [start] LianGongMsg start
     * @property {number|Long|null} [end] LianGongMsg end
     */

    /**
     * Constructs a new LianGongMsg.
     * @exports LianGongMsg
     * @classdesc Represents a LianGongMsg.
     * @implements ILianGongMsg
     * @constructor
     * @param {ILianGongMsg=} [properties] Properties to set
     */
    function LianGongMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LianGongMsg id.
     * @member {number} id
     * @memberof LianGongMsg
     * @instance
     */
    LianGongMsg.prototype.id = 0;

    /**
     * LianGongMsg start.
     * @member {number|Long} start
     * @memberof LianGongMsg
     * @instance
     */
    LianGongMsg.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * LianGongMsg end.
     * @member {number|Long} end
     * @memberof LianGongMsg
     * @instance
     */
    LianGongMsg.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new LianGongMsg instance using the specified properties.
     * @function create
     * @memberof LianGongMsg
     * @static
     * @param {ILianGongMsg=} [properties] Properties to set
     * @returns {LianGongMsg} LianGongMsg instance
     */
    LianGongMsg.create = function create(properties) {
        return new LianGongMsg(properties);
    };

    /**
     * Encodes the specified LianGongMsg message. Does not implicitly {@link LianGongMsg.verify|verify} messages.
     * @function encode
     * @memberof LianGongMsg
     * @static
     * @param {ILianGongMsg} message LianGongMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LianGongMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        if (message.start != null && message.hasOwnProperty("start"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.start);
        if (message.end != null && message.hasOwnProperty("end"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.end);
        return writer;
    };

    /**
     * Encodes the specified LianGongMsg message, length delimited. Does not implicitly {@link LianGongMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LianGongMsg
     * @static
     * @param {ILianGongMsg} message LianGongMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LianGongMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LianGongMsg message from the specified reader or buffer.
     * @function decode
     * @memberof LianGongMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LianGongMsg} LianGongMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LianGongMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LianGongMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            case 2:
                message.start = reader.int64();
                break;
            case 3:
                message.end = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LianGongMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LianGongMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LianGongMsg} LianGongMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LianGongMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LianGongMsg message.
     * @function verify
     * @memberof LianGongMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LianGongMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.start != null && message.hasOwnProperty("start"))
            if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                return "start: integer|Long expected";
        if (message.end != null && message.hasOwnProperty("end"))
            if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                return "end: integer|Long expected";
        return null;
    };

    /**
     * Creates a LianGongMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LianGongMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LianGongMsg} LianGongMsg
     */
    LianGongMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.LianGongMsg)
            return object;
        var message = new $root.LianGongMsg();
        if (object.id != null)
            message.id = object.id | 0;
        if (object.start != null)
            if ($util.Long)
                (message.start = $util.Long.fromValue(object.start)).unsigned = false;
            else if (typeof object.start === "string")
                message.start = parseInt(object.start, 10);
            else if (typeof object.start === "number")
                message.start = object.start;
            else if (typeof object.start === "object")
                message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber();
        if (object.end != null)
            if ($util.Long)
                (message.end = $util.Long.fromValue(object.end)).unsigned = false;
            else if (typeof object.end === "string")
                message.end = parseInt(object.end, 10);
            else if (typeof object.end === "number")
                message.end = object.end;
            else if (typeof object.end === "object")
                message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a LianGongMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LianGongMsg
     * @static
     * @param {LianGongMsg} message LianGongMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LianGongMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.start = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.end = options.longs === String ? "0" : 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.start != null && message.hasOwnProperty("start"))
            if (typeof message.start === "number")
                object.start = options.longs === String ? String(message.start) : message.start;
            else
                object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber() : message.start;
        if (message.end != null && message.hasOwnProperty("end"))
            if (typeof message.end === "number")
                object.end = options.longs === String ? String(message.end) : message.end;
            else
                object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
        return object;
    };

    /**
     * Converts this LianGongMsg to JSON.
     * @function toJSON
     * @memberof LianGongMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LianGongMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LianGongMsg;
})();

$root.C2S_Menpai = (function() {

    /**
     * Properties of a C2S_Menpai.
     * @exports IC2S_Menpai
     * @interface IC2S_Menpai
     */

    /**
     * Constructs a new C2S_Menpai.
     * @exports C2S_Menpai
     * @classdesc Represents a C2S_Menpai.
     * @implements IC2S_Menpai
     * @constructor
     * @param {IC2S_Menpai=} [properties] Properties to set
     */
    function C2S_Menpai(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_Menpai instance using the specified properties.
     * @function create
     * @memberof C2S_Menpai
     * @static
     * @param {IC2S_Menpai=} [properties] Properties to set
     * @returns {C2S_Menpai} C2S_Menpai instance
     */
    C2S_Menpai.create = function create(properties) {
        return new C2S_Menpai(properties);
    };

    /**
     * Encodes the specified C2S_Menpai message. Does not implicitly {@link C2S_Menpai.verify|verify} messages.
     * @function encode
     * @memberof C2S_Menpai
     * @static
     * @param {IC2S_Menpai} message C2S_Menpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Menpai.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_Menpai message, length delimited. Does not implicitly {@link C2S_Menpai.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Menpai
     * @static
     * @param {IC2S_Menpai} message C2S_Menpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Menpai.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Menpai message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Menpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Menpai} C2S_Menpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Menpai.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Menpai();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Menpai message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Menpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Menpai} C2S_Menpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Menpai.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Menpai message.
     * @function verify
     * @memberof C2S_Menpai
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Menpai.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_Menpai message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Menpai
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Menpai} C2S_Menpai
     */
    C2S_Menpai.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Menpai)
            return object;
        return new $root.C2S_Menpai();
    };

    /**
     * Creates a plain object from a C2S_Menpai message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Menpai
     * @static
     * @param {C2S_Menpai} message C2S_Menpai
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Menpai.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_Menpai to JSON.
     * @function toJSON
     * @memberof C2S_Menpai
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Menpai.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Menpai;
})();

$root.S2C_Menpai = (function() {

    /**
     * Properties of a S2C_Menpai.
     * @exports IS2C_Menpai
     * @interface IS2C_Menpai
     * @property {number|null} [menpaiId] S2C_Menpai menpaiId
     * @property {number|Long|null} [zhangmenId] S2C_Menpai zhangmenId
     * @property {string|null} [zhangmenName] S2C_Menpai zhangmenName
     * @property {Array.<ILianGongMsg>|null} [liangong] S2C_Menpai liangong
     * @property {number|null} [taskId] S2C_Menpai taskId
     * @property {number|Long|null} [taskStartTime] S2C_Menpai taskStartTime
     * @property {number|Long|null} [lastPayTime] S2C_Menpai lastPayTime
     * @property {number|Long|null} [lastSayHiTime] S2C_Menpai lastSayHiTime
     * @property {number|null} [zhiwei] S2C_Menpai zhiwei
     * @property {number|null} [zhangmenIcon] S2C_Menpai zhangmenIcon
     * @property {number|Long|null} [challengeEndTime] S2C_Menpai challengeEndTime
     * @property {number|Long|null} [ticketEndTime] S2C_Menpai ticketEndTime
     */

    /**
     * Constructs a new S2C_Menpai.
     * @exports S2C_Menpai
     * @classdesc Represents a S2C_Menpai.
     * @implements IS2C_Menpai
     * @constructor
     * @param {IS2C_Menpai=} [properties] Properties to set
     */
    function S2C_Menpai(properties) {
        this.liangong = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Menpai menpaiId.
     * @member {number} menpaiId
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.menpaiId = 0;

    /**
     * S2C_Menpai zhangmenId.
     * @member {number|Long} zhangmenId
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.zhangmenId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_Menpai zhangmenName.
     * @member {string} zhangmenName
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.zhangmenName = "";

    /**
     * S2C_Menpai liangong.
     * @member {Array.<ILianGongMsg>} liangong
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.liangong = $util.emptyArray;

    /**
     * S2C_Menpai taskId.
     * @member {number} taskId
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.taskId = 0;

    /**
     * S2C_Menpai taskStartTime.
     * @member {number|Long} taskStartTime
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.taskStartTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_Menpai lastPayTime.
     * @member {number|Long} lastPayTime
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.lastPayTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_Menpai lastSayHiTime.
     * @member {number|Long} lastSayHiTime
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.lastSayHiTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_Menpai zhiwei.
     * @member {number} zhiwei
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.zhiwei = 0;

    /**
     * S2C_Menpai zhangmenIcon.
     * @member {number} zhangmenIcon
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.zhangmenIcon = 0;

    /**
     * S2C_Menpai challengeEndTime.
     * @member {number|Long} challengeEndTime
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.challengeEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_Menpai ticketEndTime.
     * @member {number|Long} ticketEndTime
     * @memberof S2C_Menpai
     * @instance
     */
    S2C_Menpai.prototype.ticketEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new S2C_Menpai instance using the specified properties.
     * @function create
     * @memberof S2C_Menpai
     * @static
     * @param {IS2C_Menpai=} [properties] Properties to set
     * @returns {S2C_Menpai} S2C_Menpai instance
     */
    S2C_Menpai.create = function create(properties) {
        return new S2C_Menpai(properties);
    };

    /**
     * Encodes the specified S2C_Menpai message. Does not implicitly {@link S2C_Menpai.verify|verify} messages.
     * @function encode
     * @memberof S2C_Menpai
     * @static
     * @param {IS2C_Menpai} message S2C_Menpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Menpai.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.menpaiId != null && message.hasOwnProperty("menpaiId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.menpaiId);
        if (message.zhangmenId != null && message.hasOwnProperty("zhangmenId"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.zhangmenId);
        if (message.zhangmenName != null && message.hasOwnProperty("zhangmenName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.zhangmenName);
        if (message.liangong != null && message.liangong.length)
            for (var i = 0; i < message.liangong.length; ++i)
                $root.LianGongMsg.encode(message.liangong[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.taskId);
        if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.taskStartTime);
        if (message.lastPayTime != null && message.hasOwnProperty("lastPayTime"))
            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.lastPayTime);
        if (message.lastSayHiTime != null && message.hasOwnProperty("lastSayHiTime"))
            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.lastSayHiTime);
        if (message.zhiwei != null && message.hasOwnProperty("zhiwei"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.zhiwei);
        if (message.zhangmenIcon != null && message.hasOwnProperty("zhangmenIcon"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.zhangmenIcon);
        if (message.challengeEndTime != null && message.hasOwnProperty("challengeEndTime"))
            writer.uint32(/* id 11, wireType 0 =*/88).int64(message.challengeEndTime);
        if (message.ticketEndTime != null && message.hasOwnProperty("ticketEndTime"))
            writer.uint32(/* id 12, wireType 0 =*/96).int64(message.ticketEndTime);
        return writer;
    };

    /**
     * Encodes the specified S2C_Menpai message, length delimited. Does not implicitly {@link S2C_Menpai.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Menpai
     * @static
     * @param {IS2C_Menpai} message S2C_Menpai message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Menpai.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Menpai message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Menpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Menpai} S2C_Menpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Menpai.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Menpai();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.menpaiId = reader.int32();
                break;
            case 2:
                message.zhangmenId = reader.int64();
                break;
            case 3:
                message.zhangmenName = reader.string();
                break;
            case 4:
                if (!(message.liangong && message.liangong.length))
                    message.liangong = [];
                message.liangong.push($root.LianGongMsg.decode(reader, reader.uint32()));
                break;
            case 5:
                message.taskId = reader.int32();
                break;
            case 6:
                message.taskStartTime = reader.int64();
                break;
            case 7:
                message.lastPayTime = reader.int64();
                break;
            case 8:
                message.lastSayHiTime = reader.int64();
                break;
            case 9:
                message.zhiwei = reader.int32();
                break;
            case 10:
                message.zhangmenIcon = reader.int32();
                break;
            case 11:
                message.challengeEndTime = reader.int64();
                break;
            case 12:
                message.ticketEndTime = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Menpai message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Menpai
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Menpai} S2C_Menpai
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Menpai.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Menpai message.
     * @function verify
     * @memberof S2C_Menpai
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Menpai.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.menpaiId != null && message.hasOwnProperty("menpaiId"))
            if (!$util.isInteger(message.menpaiId))
                return "menpaiId: integer expected";
        if (message.zhangmenId != null && message.hasOwnProperty("zhangmenId"))
            if (!$util.isInteger(message.zhangmenId) && !(message.zhangmenId && $util.isInteger(message.zhangmenId.low) && $util.isInteger(message.zhangmenId.high)))
                return "zhangmenId: integer|Long expected";
        if (message.zhangmenName != null && message.hasOwnProperty("zhangmenName"))
            if (!$util.isString(message.zhangmenName))
                return "zhangmenName: string expected";
        if (message.liangong != null && message.hasOwnProperty("liangong")) {
            if (!Array.isArray(message.liangong))
                return "liangong: array expected";
            for (var i = 0; i < message.liangong.length; ++i) {
                var error = $root.LianGongMsg.verify(message.liangong[i]);
                if (error)
                    return "liangong." + error;
            }
        }
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            if (!$util.isInteger(message.taskId))
                return "taskId: integer expected";
        if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
            if (!$util.isInteger(message.taskStartTime) && !(message.taskStartTime && $util.isInteger(message.taskStartTime.low) && $util.isInteger(message.taskStartTime.high)))
                return "taskStartTime: integer|Long expected";
        if (message.lastPayTime != null && message.hasOwnProperty("lastPayTime"))
            if (!$util.isInteger(message.lastPayTime) && !(message.lastPayTime && $util.isInteger(message.lastPayTime.low) && $util.isInteger(message.lastPayTime.high)))
                return "lastPayTime: integer|Long expected";
        if (message.lastSayHiTime != null && message.hasOwnProperty("lastSayHiTime"))
            if (!$util.isInteger(message.lastSayHiTime) && !(message.lastSayHiTime && $util.isInteger(message.lastSayHiTime.low) && $util.isInteger(message.lastSayHiTime.high)))
                return "lastSayHiTime: integer|Long expected";
        if (message.zhiwei != null && message.hasOwnProperty("zhiwei"))
            if (!$util.isInteger(message.zhiwei))
                return "zhiwei: integer expected";
        if (message.zhangmenIcon != null && message.hasOwnProperty("zhangmenIcon"))
            if (!$util.isInteger(message.zhangmenIcon))
                return "zhangmenIcon: integer expected";
        if (message.challengeEndTime != null && message.hasOwnProperty("challengeEndTime"))
            if (!$util.isInteger(message.challengeEndTime) && !(message.challengeEndTime && $util.isInteger(message.challengeEndTime.low) && $util.isInteger(message.challengeEndTime.high)))
                return "challengeEndTime: integer|Long expected";
        if (message.ticketEndTime != null && message.hasOwnProperty("ticketEndTime"))
            if (!$util.isInteger(message.ticketEndTime) && !(message.ticketEndTime && $util.isInteger(message.ticketEndTime.low) && $util.isInteger(message.ticketEndTime.high)))
                return "ticketEndTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a S2C_Menpai message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Menpai
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Menpai} S2C_Menpai
     */
    S2C_Menpai.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Menpai)
            return object;
        var message = new $root.S2C_Menpai();
        if (object.menpaiId != null)
            message.menpaiId = object.menpaiId | 0;
        if (object.zhangmenId != null)
            if ($util.Long)
                (message.zhangmenId = $util.Long.fromValue(object.zhangmenId)).unsigned = false;
            else if (typeof object.zhangmenId === "string")
                message.zhangmenId = parseInt(object.zhangmenId, 10);
            else if (typeof object.zhangmenId === "number")
                message.zhangmenId = object.zhangmenId;
            else if (typeof object.zhangmenId === "object")
                message.zhangmenId = new $util.LongBits(object.zhangmenId.low >>> 0, object.zhangmenId.high >>> 0).toNumber();
        if (object.zhangmenName != null)
            message.zhangmenName = String(object.zhangmenName);
        if (object.liangong) {
            if (!Array.isArray(object.liangong))
                throw TypeError(".S2C_Menpai.liangong: array expected");
            message.liangong = [];
            for (var i = 0; i < object.liangong.length; ++i) {
                if (typeof object.liangong[i] !== "object")
                    throw TypeError(".S2C_Menpai.liangong: object expected");
                message.liangong[i] = $root.LianGongMsg.fromObject(object.liangong[i]);
            }
        }
        if (object.taskId != null)
            message.taskId = object.taskId | 0;
        if (object.taskStartTime != null)
            if ($util.Long)
                (message.taskStartTime = $util.Long.fromValue(object.taskStartTime)).unsigned = false;
            else if (typeof object.taskStartTime === "string")
                message.taskStartTime = parseInt(object.taskStartTime, 10);
            else if (typeof object.taskStartTime === "number")
                message.taskStartTime = object.taskStartTime;
            else if (typeof object.taskStartTime === "object")
                message.taskStartTime = new $util.LongBits(object.taskStartTime.low >>> 0, object.taskStartTime.high >>> 0).toNumber();
        if (object.lastPayTime != null)
            if ($util.Long)
                (message.lastPayTime = $util.Long.fromValue(object.lastPayTime)).unsigned = false;
            else if (typeof object.lastPayTime === "string")
                message.lastPayTime = parseInt(object.lastPayTime, 10);
            else if (typeof object.lastPayTime === "number")
                message.lastPayTime = object.lastPayTime;
            else if (typeof object.lastPayTime === "object")
                message.lastPayTime = new $util.LongBits(object.lastPayTime.low >>> 0, object.lastPayTime.high >>> 0).toNumber();
        if (object.lastSayHiTime != null)
            if ($util.Long)
                (message.lastSayHiTime = $util.Long.fromValue(object.lastSayHiTime)).unsigned = false;
            else if (typeof object.lastSayHiTime === "string")
                message.lastSayHiTime = parseInt(object.lastSayHiTime, 10);
            else if (typeof object.lastSayHiTime === "number")
                message.lastSayHiTime = object.lastSayHiTime;
            else if (typeof object.lastSayHiTime === "object")
                message.lastSayHiTime = new $util.LongBits(object.lastSayHiTime.low >>> 0, object.lastSayHiTime.high >>> 0).toNumber();
        if (object.zhiwei != null)
            message.zhiwei = object.zhiwei | 0;
        if (object.zhangmenIcon != null)
            message.zhangmenIcon = object.zhangmenIcon | 0;
        if (object.challengeEndTime != null)
            if ($util.Long)
                (message.challengeEndTime = $util.Long.fromValue(object.challengeEndTime)).unsigned = false;
            else if (typeof object.challengeEndTime === "string")
                message.challengeEndTime = parseInt(object.challengeEndTime, 10);
            else if (typeof object.challengeEndTime === "number")
                message.challengeEndTime = object.challengeEndTime;
            else if (typeof object.challengeEndTime === "object")
                message.challengeEndTime = new $util.LongBits(object.challengeEndTime.low >>> 0, object.challengeEndTime.high >>> 0).toNumber();
        if (object.ticketEndTime != null)
            if ($util.Long)
                (message.ticketEndTime = $util.Long.fromValue(object.ticketEndTime)).unsigned = false;
            else if (typeof object.ticketEndTime === "string")
                message.ticketEndTime = parseInt(object.ticketEndTime, 10);
            else if (typeof object.ticketEndTime === "number")
                message.ticketEndTime = object.ticketEndTime;
            else if (typeof object.ticketEndTime === "object")
                message.ticketEndTime = new $util.LongBits(object.ticketEndTime.low >>> 0, object.ticketEndTime.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a S2C_Menpai message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Menpai
     * @static
     * @param {S2C_Menpai} message S2C_Menpai
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Menpai.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.liangong = [];
        if (options.defaults) {
            object.menpaiId = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.zhangmenId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.zhangmenId = options.longs === String ? "0" : 0;
            object.zhangmenName = "";
            object.taskId = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.taskStartTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.taskStartTime = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.lastPayTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastPayTime = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.lastSayHiTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastSayHiTime = options.longs === String ? "0" : 0;
            object.zhiwei = 0;
            object.zhangmenIcon = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.challengeEndTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.challengeEndTime = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.ticketEndTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.ticketEndTime = options.longs === String ? "0" : 0;
        }
        if (message.menpaiId != null && message.hasOwnProperty("menpaiId"))
            object.menpaiId = message.menpaiId;
        if (message.zhangmenId != null && message.hasOwnProperty("zhangmenId"))
            if (typeof message.zhangmenId === "number")
                object.zhangmenId = options.longs === String ? String(message.zhangmenId) : message.zhangmenId;
            else
                object.zhangmenId = options.longs === String ? $util.Long.prototype.toString.call(message.zhangmenId) : options.longs === Number ? new $util.LongBits(message.zhangmenId.low >>> 0, message.zhangmenId.high >>> 0).toNumber() : message.zhangmenId;
        if (message.zhangmenName != null && message.hasOwnProperty("zhangmenName"))
            object.zhangmenName = message.zhangmenName;
        if (message.liangong && message.liangong.length) {
            object.liangong = [];
            for (var j = 0; j < message.liangong.length; ++j)
                object.liangong[j] = $root.LianGongMsg.toObject(message.liangong[j], options);
        }
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            object.taskId = message.taskId;
        if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
            if (typeof message.taskStartTime === "number")
                object.taskStartTime = options.longs === String ? String(message.taskStartTime) : message.taskStartTime;
            else
                object.taskStartTime = options.longs === String ? $util.Long.prototype.toString.call(message.taskStartTime) : options.longs === Number ? new $util.LongBits(message.taskStartTime.low >>> 0, message.taskStartTime.high >>> 0).toNumber() : message.taskStartTime;
        if (message.lastPayTime != null && message.hasOwnProperty("lastPayTime"))
            if (typeof message.lastPayTime === "number")
                object.lastPayTime = options.longs === String ? String(message.lastPayTime) : message.lastPayTime;
            else
                object.lastPayTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastPayTime) : options.longs === Number ? new $util.LongBits(message.lastPayTime.low >>> 0, message.lastPayTime.high >>> 0).toNumber() : message.lastPayTime;
        if (message.lastSayHiTime != null && message.hasOwnProperty("lastSayHiTime"))
            if (typeof message.lastSayHiTime === "number")
                object.lastSayHiTime = options.longs === String ? String(message.lastSayHiTime) : message.lastSayHiTime;
            else
                object.lastSayHiTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastSayHiTime) : options.longs === Number ? new $util.LongBits(message.lastSayHiTime.low >>> 0, message.lastSayHiTime.high >>> 0).toNumber() : message.lastSayHiTime;
        if (message.zhiwei != null && message.hasOwnProperty("zhiwei"))
            object.zhiwei = message.zhiwei;
        if (message.zhangmenIcon != null && message.hasOwnProperty("zhangmenIcon"))
            object.zhangmenIcon = message.zhangmenIcon;
        if (message.challengeEndTime != null && message.hasOwnProperty("challengeEndTime"))
            if (typeof message.challengeEndTime === "number")
                object.challengeEndTime = options.longs === String ? String(message.challengeEndTime) : message.challengeEndTime;
            else
                object.challengeEndTime = options.longs === String ? $util.Long.prototype.toString.call(message.challengeEndTime) : options.longs === Number ? new $util.LongBits(message.challengeEndTime.low >>> 0, message.challengeEndTime.high >>> 0).toNumber() : message.challengeEndTime;
        if (message.ticketEndTime != null && message.hasOwnProperty("ticketEndTime"))
            if (typeof message.ticketEndTime === "number")
                object.ticketEndTime = options.longs === String ? String(message.ticketEndTime) : message.ticketEndTime;
            else
                object.ticketEndTime = options.longs === String ? $util.Long.prototype.toString.call(message.ticketEndTime) : options.longs === Number ? new $util.LongBits(message.ticketEndTime.low >>> 0, message.ticketEndTime.high >>> 0).toNumber() : message.ticketEndTime;
        return object;
    };

    /**
     * Converts this S2C_Menpai to JSON.
     * @function toJSON
     * @memberof S2C_Menpai
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Menpai.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Menpai;
})();

$root.C2S_MenpaiStartTask = (function() {

    /**
     * Properties of a C2S_MenpaiStartTask.
     * @exports IC2S_MenpaiStartTask
     * @interface IC2S_MenpaiStartTask
     * @property {number|null} [taskId] C2S_MenpaiStartTask taskId
     */

    /**
     * Constructs a new C2S_MenpaiStartTask.
     * @exports C2S_MenpaiStartTask
     * @classdesc Represents a C2S_MenpaiStartTask.
     * @implements IC2S_MenpaiStartTask
     * @constructor
     * @param {IC2S_MenpaiStartTask=} [properties] Properties to set
     */
    function C2S_MenpaiStartTask(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MenpaiStartTask taskId.
     * @member {number} taskId
     * @memberof C2S_MenpaiStartTask
     * @instance
     */
    C2S_MenpaiStartTask.prototype.taskId = 0;

    /**
     * Creates a new C2S_MenpaiStartTask instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {IC2S_MenpaiStartTask=} [properties] Properties to set
     * @returns {C2S_MenpaiStartTask} C2S_MenpaiStartTask instance
     */
    C2S_MenpaiStartTask.create = function create(properties) {
        return new C2S_MenpaiStartTask(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiStartTask message. Does not implicitly {@link C2S_MenpaiStartTask.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {IC2S_MenpaiStartTask} message C2S_MenpaiStartTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiStartTask.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiStartTask message, length delimited. Does not implicitly {@link C2S_MenpaiStartTask.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {IC2S_MenpaiStartTask} message C2S_MenpaiStartTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiStartTask.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiStartTask message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiStartTask} C2S_MenpaiStartTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiStartTask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiStartTask();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.taskId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiStartTask message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiStartTask} C2S_MenpaiStartTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiStartTask.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiStartTask message.
     * @function verify
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiStartTask.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            if (!$util.isInteger(message.taskId))
                return "taskId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiStartTask message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiStartTask} C2S_MenpaiStartTask
     */
    C2S_MenpaiStartTask.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiStartTask)
            return object;
        var message = new $root.C2S_MenpaiStartTask();
        if (object.taskId != null)
            message.taskId = object.taskId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MenpaiStartTask message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiStartTask
     * @static
     * @param {C2S_MenpaiStartTask} message C2S_MenpaiStartTask
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiStartTask.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.taskId = 0;
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            object.taskId = message.taskId;
        return object;
    };

    /**
     * Converts this C2S_MenpaiStartTask to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiStartTask
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiStartTask.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiStartTask;
})();

$root.S2C_MenpaiStartTask = (function() {

    /**
     * Properties of a S2C_MenpaiStartTask.
     * @exports IS2C_MenpaiStartTask
     * @interface IS2C_MenpaiStartTask
     * @property {number|null} [taskId] S2C_MenpaiStartTask taskId
     * @property {number|Long|null} [taskStartTime] S2C_MenpaiStartTask taskStartTime
     */

    /**
     * Constructs a new S2C_MenpaiStartTask.
     * @exports S2C_MenpaiStartTask
     * @classdesc Represents a S2C_MenpaiStartTask.
     * @implements IS2C_MenpaiStartTask
     * @constructor
     * @param {IS2C_MenpaiStartTask=} [properties] Properties to set
     */
    function S2C_MenpaiStartTask(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MenpaiStartTask taskId.
     * @member {number} taskId
     * @memberof S2C_MenpaiStartTask
     * @instance
     */
    S2C_MenpaiStartTask.prototype.taskId = 0;

    /**
     * S2C_MenpaiStartTask taskStartTime.
     * @member {number|Long} taskStartTime
     * @memberof S2C_MenpaiStartTask
     * @instance
     */
    S2C_MenpaiStartTask.prototype.taskStartTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new S2C_MenpaiStartTask instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {IS2C_MenpaiStartTask=} [properties] Properties to set
     * @returns {S2C_MenpaiStartTask} S2C_MenpaiStartTask instance
     */
    S2C_MenpaiStartTask.create = function create(properties) {
        return new S2C_MenpaiStartTask(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiStartTask message. Does not implicitly {@link S2C_MenpaiStartTask.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {IS2C_MenpaiStartTask} message S2C_MenpaiStartTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiStartTask.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
        if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.taskStartTime);
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiStartTask message, length delimited. Does not implicitly {@link S2C_MenpaiStartTask.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {IS2C_MenpaiStartTask} message S2C_MenpaiStartTask message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiStartTask.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiStartTask message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiStartTask} S2C_MenpaiStartTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiStartTask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiStartTask();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.taskId = reader.int32();
                break;
            case 2:
                message.taskStartTime = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiStartTask message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiStartTask} S2C_MenpaiStartTask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiStartTask.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiStartTask message.
     * @function verify
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiStartTask.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            if (!$util.isInteger(message.taskId))
                return "taskId: integer expected";
        if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
            if (!$util.isInteger(message.taskStartTime) && !(message.taskStartTime && $util.isInteger(message.taskStartTime.low) && $util.isInteger(message.taskStartTime.high)))
                return "taskStartTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a S2C_MenpaiStartTask message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiStartTask} S2C_MenpaiStartTask
     */
    S2C_MenpaiStartTask.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiStartTask)
            return object;
        var message = new $root.S2C_MenpaiStartTask();
        if (object.taskId != null)
            message.taskId = object.taskId | 0;
        if (object.taskStartTime != null)
            if ($util.Long)
                (message.taskStartTime = $util.Long.fromValue(object.taskStartTime)).unsigned = false;
            else if (typeof object.taskStartTime === "string")
                message.taskStartTime = parseInt(object.taskStartTime, 10);
            else if (typeof object.taskStartTime === "number")
                message.taskStartTime = object.taskStartTime;
            else if (typeof object.taskStartTime === "object")
                message.taskStartTime = new $util.LongBits(object.taskStartTime.low >>> 0, object.taskStartTime.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a S2C_MenpaiStartTask message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiStartTask
     * @static
     * @param {S2C_MenpaiStartTask} message S2C_MenpaiStartTask
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiStartTask.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.taskId = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.taskStartTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.taskStartTime = options.longs === String ? "0" : 0;
        }
        if (message.taskId != null && message.hasOwnProperty("taskId"))
            object.taskId = message.taskId;
        if (message.taskStartTime != null && message.hasOwnProperty("taskStartTime"))
            if (typeof message.taskStartTime === "number")
                object.taskStartTime = options.longs === String ? String(message.taskStartTime) : message.taskStartTime;
            else
                object.taskStartTime = options.longs === String ? $util.Long.prototype.toString.call(message.taskStartTime) : options.longs === Number ? new $util.LongBits(message.taskStartTime.low >>> 0, message.taskStartTime.high >>> 0).toNumber() : message.taskStartTime;
        return object;
    };

    /**
     * Converts this S2C_MenpaiStartTask to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiStartTask
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiStartTask.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiStartTask;
})();

$root.C2S_MenpaiPay = (function() {

    /**
     * Properties of a C2S_MenpaiPay.
     * @exports IC2S_MenpaiPay
     * @interface IC2S_MenpaiPay
     */

    /**
     * Constructs a new C2S_MenpaiPay.
     * @exports C2S_MenpaiPay
     * @classdesc Represents a C2S_MenpaiPay.
     * @implements IC2S_MenpaiPay
     * @constructor
     * @param {IC2S_MenpaiPay=} [properties] Properties to set
     */
    function C2S_MenpaiPay(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_MenpaiPay instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiPay
     * @static
     * @param {IC2S_MenpaiPay=} [properties] Properties to set
     * @returns {C2S_MenpaiPay} C2S_MenpaiPay instance
     */
    C2S_MenpaiPay.create = function create(properties) {
        return new C2S_MenpaiPay(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiPay message. Does not implicitly {@link C2S_MenpaiPay.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiPay
     * @static
     * @param {IC2S_MenpaiPay} message C2S_MenpaiPay message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiPay.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiPay message, length delimited. Does not implicitly {@link C2S_MenpaiPay.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiPay
     * @static
     * @param {IC2S_MenpaiPay} message C2S_MenpaiPay message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiPay.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiPay message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiPay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiPay} C2S_MenpaiPay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiPay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiPay();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiPay message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiPay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiPay} C2S_MenpaiPay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiPay.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiPay message.
     * @function verify
     * @memberof C2S_MenpaiPay
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiPay.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiPay message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiPay
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiPay} C2S_MenpaiPay
     */
    C2S_MenpaiPay.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiPay)
            return object;
        return new $root.C2S_MenpaiPay();
    };

    /**
     * Creates a plain object from a C2S_MenpaiPay message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiPay
     * @static
     * @param {C2S_MenpaiPay} message C2S_MenpaiPay
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiPay.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_MenpaiPay to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiPay
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiPay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiPay;
})();

$root.S2C_MenpaiPay = (function() {

    /**
     * Properties of a S2C_MenpaiPay.
     * @exports IS2C_MenpaiPay
     * @interface IS2C_MenpaiPay
     * @property {number|Long|null} [payTime] S2C_MenpaiPay payTime
     */

    /**
     * Constructs a new S2C_MenpaiPay.
     * @exports S2C_MenpaiPay
     * @classdesc Represents a S2C_MenpaiPay.
     * @implements IS2C_MenpaiPay
     * @constructor
     * @param {IS2C_MenpaiPay=} [properties] Properties to set
     */
    function S2C_MenpaiPay(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MenpaiPay payTime.
     * @member {number|Long} payTime
     * @memberof S2C_MenpaiPay
     * @instance
     */
    S2C_MenpaiPay.prototype.payTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new S2C_MenpaiPay instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiPay
     * @static
     * @param {IS2C_MenpaiPay=} [properties] Properties to set
     * @returns {S2C_MenpaiPay} S2C_MenpaiPay instance
     */
    S2C_MenpaiPay.create = function create(properties) {
        return new S2C_MenpaiPay(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiPay message. Does not implicitly {@link S2C_MenpaiPay.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiPay
     * @static
     * @param {IS2C_MenpaiPay} message S2C_MenpaiPay message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiPay.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.payTime != null && message.hasOwnProperty("payTime"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.payTime);
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiPay message, length delimited. Does not implicitly {@link S2C_MenpaiPay.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiPay
     * @static
     * @param {IS2C_MenpaiPay} message S2C_MenpaiPay message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiPay.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiPay message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiPay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiPay} S2C_MenpaiPay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiPay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiPay();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.payTime = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiPay message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiPay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiPay} S2C_MenpaiPay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiPay.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiPay message.
     * @function verify
     * @memberof S2C_MenpaiPay
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiPay.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.payTime != null && message.hasOwnProperty("payTime"))
            if (!$util.isInteger(message.payTime) && !(message.payTime && $util.isInteger(message.payTime.low) && $util.isInteger(message.payTime.high)))
                return "payTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a S2C_MenpaiPay message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiPay
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiPay} S2C_MenpaiPay
     */
    S2C_MenpaiPay.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiPay)
            return object;
        var message = new $root.S2C_MenpaiPay();
        if (object.payTime != null)
            if ($util.Long)
                (message.payTime = $util.Long.fromValue(object.payTime)).unsigned = false;
            else if (typeof object.payTime === "string")
                message.payTime = parseInt(object.payTime, 10);
            else if (typeof object.payTime === "number")
                message.payTime = object.payTime;
            else if (typeof object.payTime === "object")
                message.payTime = new $util.LongBits(object.payTime.low >>> 0, object.payTime.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a S2C_MenpaiPay message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiPay
     * @static
     * @param {S2C_MenpaiPay} message S2C_MenpaiPay
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiPay.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.payTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.payTime = options.longs === String ? "0" : 0;
        if (message.payTime != null && message.hasOwnProperty("payTime"))
            if (typeof message.payTime === "number")
                object.payTime = options.longs === String ? String(message.payTime) : message.payTime;
            else
                object.payTime = options.longs === String ? $util.Long.prototype.toString.call(message.payTime) : options.longs === Number ? new $util.LongBits(message.payTime.low >>> 0, message.payTime.high >>> 0).toNumber() : message.payTime;
        return object;
    };

    /**
     * Converts this S2C_MenpaiPay to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiPay
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiPay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiPay;
})();

$root.C2S_Liangong = (function() {

    /**
     * Properties of a C2S_Liangong.
     * @exports IC2S_Liangong
     * @interface IC2S_Liangong
     * @property {number|null} [configId] C2S_Liangong configId
     */

    /**
     * Constructs a new C2S_Liangong.
     * @exports C2S_Liangong
     * @classdesc Represents a C2S_Liangong.
     * @implements IC2S_Liangong
     * @constructor
     * @param {IC2S_Liangong=} [properties] Properties to set
     */
    function C2S_Liangong(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_Liangong configId.
     * @member {number} configId
     * @memberof C2S_Liangong
     * @instance
     */
    C2S_Liangong.prototype.configId = 0;

    /**
     * Creates a new C2S_Liangong instance using the specified properties.
     * @function create
     * @memberof C2S_Liangong
     * @static
     * @param {IC2S_Liangong=} [properties] Properties to set
     * @returns {C2S_Liangong} C2S_Liangong instance
     */
    C2S_Liangong.create = function create(properties) {
        return new C2S_Liangong(properties);
    };

    /**
     * Encodes the specified C2S_Liangong message. Does not implicitly {@link C2S_Liangong.verify|verify} messages.
     * @function encode
     * @memberof C2S_Liangong
     * @static
     * @param {IC2S_Liangong} message C2S_Liangong message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Liangong.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.configId != null && message.hasOwnProperty("configId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.configId);
        return writer;
    };

    /**
     * Encodes the specified C2S_Liangong message, length delimited. Does not implicitly {@link C2S_Liangong.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Liangong
     * @static
     * @param {IC2S_Liangong} message C2S_Liangong message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Liangong.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Liangong message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Liangong
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Liangong} C2S_Liangong
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Liangong.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Liangong();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.configId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Liangong message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Liangong
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Liangong} C2S_Liangong
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Liangong.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Liangong message.
     * @function verify
     * @memberof C2S_Liangong
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Liangong.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.configId != null && message.hasOwnProperty("configId"))
            if (!$util.isInteger(message.configId))
                return "configId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_Liangong message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Liangong
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Liangong} C2S_Liangong
     */
    C2S_Liangong.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Liangong)
            return object;
        var message = new $root.C2S_Liangong();
        if (object.configId != null)
            message.configId = object.configId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_Liangong message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Liangong
     * @static
     * @param {C2S_Liangong} message C2S_Liangong
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Liangong.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.configId = 0;
        if (message.configId != null && message.hasOwnProperty("configId"))
            object.configId = message.configId;
        return object;
    };

    /**
     * Converts this C2S_Liangong to JSON.
     * @function toJSON
     * @memberof C2S_Liangong
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Liangong.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Liangong;
})();

$root.S2C_Liangong = (function() {

    /**
     * Properties of a S2C_Liangong.
     * @exports IS2C_Liangong
     * @interface IS2C_Liangong
     * @property {ILianGongMsg|null} [liangong] S2C_Liangong liangong
     */

    /**
     * Constructs a new S2C_Liangong.
     * @exports S2C_Liangong
     * @classdesc Represents a S2C_Liangong.
     * @implements IS2C_Liangong
     * @constructor
     * @param {IS2C_Liangong=} [properties] Properties to set
     */
    function S2C_Liangong(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Liangong liangong.
     * @member {ILianGongMsg|null|undefined} liangong
     * @memberof S2C_Liangong
     * @instance
     */
    S2C_Liangong.prototype.liangong = null;

    /**
     * Creates a new S2C_Liangong instance using the specified properties.
     * @function create
     * @memberof S2C_Liangong
     * @static
     * @param {IS2C_Liangong=} [properties] Properties to set
     * @returns {S2C_Liangong} S2C_Liangong instance
     */
    S2C_Liangong.create = function create(properties) {
        return new S2C_Liangong(properties);
    };

    /**
     * Encodes the specified S2C_Liangong message. Does not implicitly {@link S2C_Liangong.verify|verify} messages.
     * @function encode
     * @memberof S2C_Liangong
     * @static
     * @param {IS2C_Liangong} message S2C_Liangong message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Liangong.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.liangong != null && message.hasOwnProperty("liangong"))
            $root.LianGongMsg.encode(message.liangong, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_Liangong message, length delimited. Does not implicitly {@link S2C_Liangong.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Liangong
     * @static
     * @param {IS2C_Liangong} message S2C_Liangong message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Liangong.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Liangong message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Liangong
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Liangong} S2C_Liangong
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Liangong.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Liangong();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.liangong = $root.LianGongMsg.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Liangong message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Liangong
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Liangong} S2C_Liangong
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Liangong.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Liangong message.
     * @function verify
     * @memberof S2C_Liangong
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Liangong.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.liangong != null && message.hasOwnProperty("liangong")) {
            var error = $root.LianGongMsg.verify(message.liangong);
            if (error)
                return "liangong." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_Liangong message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Liangong
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Liangong} S2C_Liangong
     */
    S2C_Liangong.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Liangong)
            return object;
        var message = new $root.S2C_Liangong();
        if (object.liangong != null) {
            if (typeof object.liangong !== "object")
                throw TypeError(".S2C_Liangong.liangong: object expected");
            message.liangong = $root.LianGongMsg.fromObject(object.liangong);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_Liangong message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Liangong
     * @static
     * @param {S2C_Liangong} message S2C_Liangong
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Liangong.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.liangong = null;
        if (message.liangong != null && message.hasOwnProperty("liangong"))
            object.liangong = $root.LianGongMsg.toObject(message.liangong, options);
        return object;
    };

    /**
     * Converts this S2C_Liangong to JSON.
     * @function toJSON
     * @memberof S2C_Liangong
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Liangong.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Liangong;
})();

$root.C2S_MenpaiGift = (function() {

    /**
     * Properties of a C2S_MenpaiGift.
     * @exports IC2S_MenpaiGift
     * @interface IC2S_MenpaiGift
     * @property {number|null} [npcId] C2S_MenpaiGift npcId
     */

    /**
     * Constructs a new C2S_MenpaiGift.
     * @exports C2S_MenpaiGift
     * @classdesc Represents a C2S_MenpaiGift.
     * @implements IC2S_MenpaiGift
     * @constructor
     * @param {IC2S_MenpaiGift=} [properties] Properties to set
     */
    function C2S_MenpaiGift(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MenpaiGift npcId.
     * @member {number} npcId
     * @memberof C2S_MenpaiGift
     * @instance
     */
    C2S_MenpaiGift.prototype.npcId = 0;

    /**
     * Creates a new C2S_MenpaiGift instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiGift
     * @static
     * @param {IC2S_MenpaiGift=} [properties] Properties to set
     * @returns {C2S_MenpaiGift} C2S_MenpaiGift instance
     */
    C2S_MenpaiGift.create = function create(properties) {
        return new C2S_MenpaiGift(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiGift message. Does not implicitly {@link C2S_MenpaiGift.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiGift
     * @static
     * @param {IC2S_MenpaiGift} message C2S_MenpaiGift message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiGift.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.npcId != null && message.hasOwnProperty("npcId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.npcId);
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiGift message, length delimited. Does not implicitly {@link C2S_MenpaiGift.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiGift
     * @static
     * @param {IC2S_MenpaiGift} message C2S_MenpaiGift message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiGift.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiGift message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiGift
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiGift} C2S_MenpaiGift
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiGift.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiGift();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.npcId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiGift message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiGift
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiGift} C2S_MenpaiGift
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiGift.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiGift message.
     * @function verify
     * @memberof C2S_MenpaiGift
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiGift.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.npcId != null && message.hasOwnProperty("npcId"))
            if (!$util.isInteger(message.npcId))
                return "npcId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiGift message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiGift
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiGift} C2S_MenpaiGift
     */
    C2S_MenpaiGift.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiGift)
            return object;
        var message = new $root.C2S_MenpaiGift();
        if (object.npcId != null)
            message.npcId = object.npcId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MenpaiGift message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiGift
     * @static
     * @param {C2S_MenpaiGift} message C2S_MenpaiGift
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiGift.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.npcId = 0;
        if (message.npcId != null && message.hasOwnProperty("npcId"))
            object.npcId = message.npcId;
        return object;
    };

    /**
     * Converts this C2S_MenpaiGift to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiGift
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiGift.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiGift;
})();

$root.S2C_MenpaiGift = (function() {

    /**
     * Properties of a S2C_MenpaiGift.
     * @exports IS2C_MenpaiGift
     * @interface IS2C_MenpaiGift
     */

    /**
     * Constructs a new S2C_MenpaiGift.
     * @exports S2C_MenpaiGift
     * @classdesc Represents a S2C_MenpaiGift.
     * @implements IS2C_MenpaiGift
     * @constructor
     * @param {IS2C_MenpaiGift=} [properties] Properties to set
     */
    function S2C_MenpaiGift(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_MenpaiGift instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiGift
     * @static
     * @param {IS2C_MenpaiGift=} [properties] Properties to set
     * @returns {S2C_MenpaiGift} S2C_MenpaiGift instance
     */
    S2C_MenpaiGift.create = function create(properties) {
        return new S2C_MenpaiGift(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiGift message. Does not implicitly {@link S2C_MenpaiGift.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiGift
     * @static
     * @param {IS2C_MenpaiGift} message S2C_MenpaiGift message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiGift.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiGift message, length delimited. Does not implicitly {@link S2C_MenpaiGift.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiGift
     * @static
     * @param {IS2C_MenpaiGift} message S2C_MenpaiGift message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiGift.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiGift message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiGift
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiGift} S2C_MenpaiGift
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiGift.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiGift();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiGift message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiGift
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiGift} S2C_MenpaiGift
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiGift.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiGift message.
     * @function verify
     * @memberof S2C_MenpaiGift
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiGift.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_MenpaiGift message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiGift
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiGift} S2C_MenpaiGift
     */
    S2C_MenpaiGift.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiGift)
            return object;
        return new $root.S2C_MenpaiGift();
    };

    /**
     * Creates a plain object from a S2C_MenpaiGift message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiGift
     * @static
     * @param {S2C_MenpaiGift} message S2C_MenpaiGift
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiGift.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_MenpaiGift to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiGift
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiGift.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiGift;
})();

$root.C2S_MenpaiChallenge = (function() {

    /**
     * Properties of a C2S_MenpaiChallenge.
     * @exports IC2S_MenpaiChallenge
     * @interface IC2S_MenpaiChallenge
     * @property {boolean|null} [lingPai] C2S_MenpaiChallenge lingPai
     */

    /**
     * Constructs a new C2S_MenpaiChallenge.
     * @exports C2S_MenpaiChallenge
     * @classdesc Represents a C2S_MenpaiChallenge.
     * @implements IC2S_MenpaiChallenge
     * @constructor
     * @param {IC2S_MenpaiChallenge=} [properties] Properties to set
     */
    function C2S_MenpaiChallenge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MenpaiChallenge lingPai.
     * @member {boolean} lingPai
     * @memberof C2S_MenpaiChallenge
     * @instance
     */
    C2S_MenpaiChallenge.prototype.lingPai = false;

    /**
     * Creates a new C2S_MenpaiChallenge instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {IC2S_MenpaiChallenge=} [properties] Properties to set
     * @returns {C2S_MenpaiChallenge} C2S_MenpaiChallenge instance
     */
    C2S_MenpaiChallenge.create = function create(properties) {
        return new C2S_MenpaiChallenge(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiChallenge message. Does not implicitly {@link C2S_MenpaiChallenge.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {IC2S_MenpaiChallenge} message C2S_MenpaiChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiChallenge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.lingPai != null && message.hasOwnProperty("lingPai"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.lingPai);
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiChallenge message, length delimited. Does not implicitly {@link C2S_MenpaiChallenge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {IC2S_MenpaiChallenge} message C2S_MenpaiChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiChallenge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiChallenge message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiChallenge} C2S_MenpaiChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiChallenge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiChallenge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.lingPai = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiChallenge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiChallenge} C2S_MenpaiChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiChallenge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiChallenge message.
     * @function verify
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiChallenge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.lingPai != null && message.hasOwnProperty("lingPai"))
            if (typeof message.lingPai !== "boolean")
                return "lingPai: boolean expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiChallenge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiChallenge} C2S_MenpaiChallenge
     */
    C2S_MenpaiChallenge.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiChallenge)
            return object;
        var message = new $root.C2S_MenpaiChallenge();
        if (object.lingPai != null)
            message.lingPai = Boolean(object.lingPai);
        return message;
    };

    /**
     * Creates a plain object from a C2S_MenpaiChallenge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiChallenge
     * @static
     * @param {C2S_MenpaiChallenge} message C2S_MenpaiChallenge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiChallenge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.lingPai = false;
        if (message.lingPai != null && message.hasOwnProperty("lingPai"))
            object.lingPai = message.lingPai;
        return object;
    };

    /**
     * Converts this C2S_MenpaiChallenge to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiChallenge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiChallenge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiChallenge;
})();

$root.S2C_MenpaiChallenge = (function() {

    /**
     * Properties of a S2C_MenpaiChallenge.
     * @exports IS2C_MenpaiChallenge
     * @interface IS2C_MenpaiChallenge
     * @property {IFightResultMsg|null} [result] S2C_MenpaiChallenge result
     * @property {number|Long|null} [challengeEndTime] S2C_MenpaiChallenge challengeEndTime
     * @property {number|Long|null} [ticketEndTime] S2C_MenpaiChallenge ticketEndTime
     */

    /**
     * Constructs a new S2C_MenpaiChallenge.
     * @exports S2C_MenpaiChallenge
     * @classdesc Represents a S2C_MenpaiChallenge.
     * @implements IS2C_MenpaiChallenge
     * @constructor
     * @param {IS2C_MenpaiChallenge=} [properties] Properties to set
     */
    function S2C_MenpaiChallenge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MenpaiChallenge result.
     * @member {IFightResultMsg|null|undefined} result
     * @memberof S2C_MenpaiChallenge
     * @instance
     */
    S2C_MenpaiChallenge.prototype.result = null;

    /**
     * S2C_MenpaiChallenge challengeEndTime.
     * @member {number|Long} challengeEndTime
     * @memberof S2C_MenpaiChallenge
     * @instance
     */
    S2C_MenpaiChallenge.prototype.challengeEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_MenpaiChallenge ticketEndTime.
     * @member {number|Long} ticketEndTime
     * @memberof S2C_MenpaiChallenge
     * @instance
     */
    S2C_MenpaiChallenge.prototype.ticketEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new S2C_MenpaiChallenge instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {IS2C_MenpaiChallenge=} [properties] Properties to set
     * @returns {S2C_MenpaiChallenge} S2C_MenpaiChallenge instance
     */
    S2C_MenpaiChallenge.create = function create(properties) {
        return new S2C_MenpaiChallenge(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiChallenge message. Does not implicitly {@link S2C_MenpaiChallenge.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {IS2C_MenpaiChallenge} message S2C_MenpaiChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiChallenge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && message.hasOwnProperty("result"))
            $root.FightResultMsg.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.challengeEndTime != null && message.hasOwnProperty("challengeEndTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.challengeEndTime);
        if (message.ticketEndTime != null && message.hasOwnProperty("ticketEndTime"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ticketEndTime);
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiChallenge message, length delimited. Does not implicitly {@link S2C_MenpaiChallenge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {IS2C_MenpaiChallenge} message S2C_MenpaiChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiChallenge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiChallenge message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiChallenge} S2C_MenpaiChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiChallenge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiChallenge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = $root.FightResultMsg.decode(reader, reader.uint32());
                break;
            case 2:
                message.challengeEndTime = reader.int64();
                break;
            case 3:
                message.ticketEndTime = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiChallenge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiChallenge} S2C_MenpaiChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiChallenge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiChallenge message.
     * @function verify
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiChallenge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result")) {
            var error = $root.FightResultMsg.verify(message.result);
            if (error)
                return "result." + error;
        }
        if (message.challengeEndTime != null && message.hasOwnProperty("challengeEndTime"))
            if (!$util.isInteger(message.challengeEndTime) && !(message.challengeEndTime && $util.isInteger(message.challengeEndTime.low) && $util.isInteger(message.challengeEndTime.high)))
                return "challengeEndTime: integer|Long expected";
        if (message.ticketEndTime != null && message.hasOwnProperty("ticketEndTime"))
            if (!$util.isInteger(message.ticketEndTime) && !(message.ticketEndTime && $util.isInteger(message.ticketEndTime.low) && $util.isInteger(message.ticketEndTime.high)))
                return "ticketEndTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a S2C_MenpaiChallenge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiChallenge} S2C_MenpaiChallenge
     */
    S2C_MenpaiChallenge.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiChallenge)
            return object;
        var message = new $root.S2C_MenpaiChallenge();
        if (object.result != null) {
            if (typeof object.result !== "object")
                throw TypeError(".S2C_MenpaiChallenge.result: object expected");
            message.result = $root.FightResultMsg.fromObject(object.result);
        }
        if (object.challengeEndTime != null)
            if ($util.Long)
                (message.challengeEndTime = $util.Long.fromValue(object.challengeEndTime)).unsigned = false;
            else if (typeof object.challengeEndTime === "string")
                message.challengeEndTime = parseInt(object.challengeEndTime, 10);
            else if (typeof object.challengeEndTime === "number")
                message.challengeEndTime = object.challengeEndTime;
            else if (typeof object.challengeEndTime === "object")
                message.challengeEndTime = new $util.LongBits(object.challengeEndTime.low >>> 0, object.challengeEndTime.high >>> 0).toNumber();
        if (object.ticketEndTime != null)
            if ($util.Long)
                (message.ticketEndTime = $util.Long.fromValue(object.ticketEndTime)).unsigned = false;
            else if (typeof object.ticketEndTime === "string")
                message.ticketEndTime = parseInt(object.ticketEndTime, 10);
            else if (typeof object.ticketEndTime === "number")
                message.ticketEndTime = object.ticketEndTime;
            else if (typeof object.ticketEndTime === "object")
                message.ticketEndTime = new $util.LongBits(object.ticketEndTime.low >>> 0, object.ticketEndTime.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a S2C_MenpaiChallenge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiChallenge
     * @static
     * @param {S2C_MenpaiChallenge} message S2C_MenpaiChallenge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiChallenge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.result = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.challengeEndTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.challengeEndTime = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.ticketEndTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.ticketEndTime = options.longs === String ? "0" : 0;
        }
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = $root.FightResultMsg.toObject(message.result, options);
        if (message.challengeEndTime != null && message.hasOwnProperty("challengeEndTime"))
            if (typeof message.challengeEndTime === "number")
                object.challengeEndTime = options.longs === String ? String(message.challengeEndTime) : message.challengeEndTime;
            else
                object.challengeEndTime = options.longs === String ? $util.Long.prototype.toString.call(message.challengeEndTime) : options.longs === Number ? new $util.LongBits(message.challengeEndTime.low >>> 0, message.challengeEndTime.high >>> 0).toNumber() : message.challengeEndTime;
        if (message.ticketEndTime != null && message.hasOwnProperty("ticketEndTime"))
            if (typeof message.ticketEndTime === "number")
                object.ticketEndTime = options.longs === String ? String(message.ticketEndTime) : message.ticketEndTime;
            else
                object.ticketEndTime = options.longs === String ? $util.Long.prototype.toString.call(message.ticketEndTime) : options.longs === Number ? new $util.LongBits(message.ticketEndTime.low >>> 0, message.ticketEndTime.high >>> 0).toNumber() : message.ticketEndTime;
        return object;
    };

    /**
     * Converts this S2C_MenpaiChallenge to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiChallenge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiChallenge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiChallenge;
})();

$root.C2S_MenpaiPromotion = (function() {

    /**
     * Properties of a C2S_MenpaiPromotion.
     * @exports IC2S_MenpaiPromotion
     * @interface IC2S_MenpaiPromotion
     * @property {number|null} [zhiwu] C2S_MenpaiPromotion zhiwu
     */

    /**
     * Constructs a new C2S_MenpaiPromotion.
     * @exports C2S_MenpaiPromotion
     * @classdesc Represents a C2S_MenpaiPromotion.
     * @implements IC2S_MenpaiPromotion
     * @constructor
     * @param {IC2S_MenpaiPromotion=} [properties] Properties to set
     */
    function C2S_MenpaiPromotion(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MenpaiPromotion zhiwu.
     * @member {number} zhiwu
     * @memberof C2S_MenpaiPromotion
     * @instance
     */
    C2S_MenpaiPromotion.prototype.zhiwu = 0;

    /**
     * Creates a new C2S_MenpaiPromotion instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {IC2S_MenpaiPromotion=} [properties] Properties to set
     * @returns {C2S_MenpaiPromotion} C2S_MenpaiPromotion instance
     */
    C2S_MenpaiPromotion.create = function create(properties) {
        return new C2S_MenpaiPromotion(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiPromotion message. Does not implicitly {@link C2S_MenpaiPromotion.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {IC2S_MenpaiPromotion} message C2S_MenpaiPromotion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiPromotion.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.zhiwu != null && message.hasOwnProperty("zhiwu"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.zhiwu);
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiPromotion message, length delimited. Does not implicitly {@link C2S_MenpaiPromotion.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {IC2S_MenpaiPromotion} message C2S_MenpaiPromotion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiPromotion.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiPromotion message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiPromotion} C2S_MenpaiPromotion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiPromotion.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiPromotion();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.zhiwu = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiPromotion message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiPromotion} C2S_MenpaiPromotion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiPromotion.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiPromotion message.
     * @function verify
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiPromotion.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.zhiwu != null && message.hasOwnProperty("zhiwu"))
            if (!$util.isInteger(message.zhiwu))
                return "zhiwu: integer expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiPromotion message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiPromotion} C2S_MenpaiPromotion
     */
    C2S_MenpaiPromotion.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiPromotion)
            return object;
        var message = new $root.C2S_MenpaiPromotion();
        if (object.zhiwu != null)
            message.zhiwu = object.zhiwu | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MenpaiPromotion message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiPromotion
     * @static
     * @param {C2S_MenpaiPromotion} message C2S_MenpaiPromotion
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiPromotion.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.zhiwu = 0;
        if (message.zhiwu != null && message.hasOwnProperty("zhiwu"))
            object.zhiwu = message.zhiwu;
        return object;
    };

    /**
     * Converts this C2S_MenpaiPromotion to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiPromotion
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiPromotion.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiPromotion;
})();

$root.S2C_MenpaiPromotion = (function() {

    /**
     * Properties of a S2C_MenpaiPromotion.
     * @exports IS2C_MenpaiPromotion
     * @interface IS2C_MenpaiPromotion
     * @property {number|null} [zhiwu] S2C_MenpaiPromotion zhiwu
     */

    /**
     * Constructs a new S2C_MenpaiPromotion.
     * @exports S2C_MenpaiPromotion
     * @classdesc Represents a S2C_MenpaiPromotion.
     * @implements IS2C_MenpaiPromotion
     * @constructor
     * @param {IS2C_MenpaiPromotion=} [properties] Properties to set
     */
    function S2C_MenpaiPromotion(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MenpaiPromotion zhiwu.
     * @member {number} zhiwu
     * @memberof S2C_MenpaiPromotion
     * @instance
     */
    S2C_MenpaiPromotion.prototype.zhiwu = 0;

    /**
     * Creates a new S2C_MenpaiPromotion instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {IS2C_MenpaiPromotion=} [properties] Properties to set
     * @returns {S2C_MenpaiPromotion} S2C_MenpaiPromotion instance
     */
    S2C_MenpaiPromotion.create = function create(properties) {
        return new S2C_MenpaiPromotion(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiPromotion message. Does not implicitly {@link S2C_MenpaiPromotion.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {IS2C_MenpaiPromotion} message S2C_MenpaiPromotion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiPromotion.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.zhiwu != null && message.hasOwnProperty("zhiwu"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.zhiwu);
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiPromotion message, length delimited. Does not implicitly {@link S2C_MenpaiPromotion.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {IS2C_MenpaiPromotion} message S2C_MenpaiPromotion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiPromotion.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiPromotion message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiPromotion} S2C_MenpaiPromotion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiPromotion.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiPromotion();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.zhiwu = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiPromotion message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiPromotion} S2C_MenpaiPromotion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiPromotion.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiPromotion message.
     * @function verify
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiPromotion.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.zhiwu != null && message.hasOwnProperty("zhiwu"))
            if (!$util.isInteger(message.zhiwu))
                return "zhiwu: integer expected";
        return null;
    };

    /**
     * Creates a S2C_MenpaiPromotion message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiPromotion} S2C_MenpaiPromotion
     */
    S2C_MenpaiPromotion.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiPromotion)
            return object;
        var message = new $root.S2C_MenpaiPromotion();
        if (object.zhiwu != null)
            message.zhiwu = object.zhiwu | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_MenpaiPromotion message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiPromotion
     * @static
     * @param {S2C_MenpaiPromotion} message S2C_MenpaiPromotion
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiPromotion.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.zhiwu = 0;
        if (message.zhiwu != null && message.hasOwnProperty("zhiwu"))
            object.zhiwu = message.zhiwu;
        return object;
    };

    /**
     * Converts this S2C_MenpaiPromotion to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiPromotion
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiPromotion.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiPromotion;
})();

$root.C2S_MenpaiSayHi = (function() {

    /**
     * Properties of a C2S_MenpaiSayHi.
     * @exports IC2S_MenpaiSayHi
     * @interface IC2S_MenpaiSayHi
     * @property {number|null} [id] C2S_MenpaiSayHi id
     */

    /**
     * Constructs a new C2S_MenpaiSayHi.
     * @exports C2S_MenpaiSayHi
     * @classdesc Represents a C2S_MenpaiSayHi.
     * @implements IC2S_MenpaiSayHi
     * @constructor
     * @param {IC2S_MenpaiSayHi=} [properties] Properties to set
     */
    function C2S_MenpaiSayHi(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MenpaiSayHi id.
     * @member {number} id
     * @memberof C2S_MenpaiSayHi
     * @instance
     */
    C2S_MenpaiSayHi.prototype.id = 0;

    /**
     * Creates a new C2S_MenpaiSayHi instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {IC2S_MenpaiSayHi=} [properties] Properties to set
     * @returns {C2S_MenpaiSayHi} C2S_MenpaiSayHi instance
     */
    C2S_MenpaiSayHi.create = function create(properties) {
        return new C2S_MenpaiSayHi(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiSayHi message. Does not implicitly {@link C2S_MenpaiSayHi.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {IC2S_MenpaiSayHi} message C2S_MenpaiSayHi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiSayHi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiSayHi message, length delimited. Does not implicitly {@link C2S_MenpaiSayHi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {IC2S_MenpaiSayHi} message C2S_MenpaiSayHi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiSayHi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiSayHi message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiSayHi} C2S_MenpaiSayHi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiSayHi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiSayHi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiSayHi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiSayHi} C2S_MenpaiSayHi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiSayHi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiSayHi message.
     * @function verify
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiSayHi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiSayHi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiSayHi} C2S_MenpaiSayHi
     */
    C2S_MenpaiSayHi.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiSayHi)
            return object;
        var message = new $root.C2S_MenpaiSayHi();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MenpaiSayHi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiSayHi
     * @static
     * @param {C2S_MenpaiSayHi} message C2S_MenpaiSayHi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiSayHi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_MenpaiSayHi to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiSayHi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiSayHi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiSayHi;
})();

$root.S2C_MenpaiSayHi = (function() {

    /**
     * Properties of a S2C_MenpaiSayHi.
     * @exports IS2C_MenpaiSayHi
     * @interface IS2C_MenpaiSayHi
     * @property {number|Long|null} [sayHiTime] S2C_MenpaiSayHi sayHiTime
     * @property {number|null} [id] S2C_MenpaiSayHi id
     */

    /**
     * Constructs a new S2C_MenpaiSayHi.
     * @exports S2C_MenpaiSayHi
     * @classdesc Represents a S2C_MenpaiSayHi.
     * @implements IS2C_MenpaiSayHi
     * @constructor
     * @param {IS2C_MenpaiSayHi=} [properties] Properties to set
     */
    function S2C_MenpaiSayHi(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MenpaiSayHi sayHiTime.
     * @member {number|Long} sayHiTime
     * @memberof S2C_MenpaiSayHi
     * @instance
     */
    S2C_MenpaiSayHi.prototype.sayHiTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_MenpaiSayHi id.
     * @member {number} id
     * @memberof S2C_MenpaiSayHi
     * @instance
     */
    S2C_MenpaiSayHi.prototype.id = 0;

    /**
     * Creates a new S2C_MenpaiSayHi instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {IS2C_MenpaiSayHi=} [properties] Properties to set
     * @returns {S2C_MenpaiSayHi} S2C_MenpaiSayHi instance
     */
    S2C_MenpaiSayHi.create = function create(properties) {
        return new S2C_MenpaiSayHi(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiSayHi message. Does not implicitly {@link S2C_MenpaiSayHi.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {IS2C_MenpaiSayHi} message S2C_MenpaiSayHi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiSayHi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sayHiTime != null && message.hasOwnProperty("sayHiTime"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sayHiTime);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiSayHi message, length delimited. Does not implicitly {@link S2C_MenpaiSayHi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {IS2C_MenpaiSayHi} message S2C_MenpaiSayHi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiSayHi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiSayHi message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiSayHi} S2C_MenpaiSayHi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiSayHi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiSayHi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sayHiTime = reader.int64();
                break;
            case 2:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiSayHi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiSayHi} S2C_MenpaiSayHi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiSayHi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiSayHi message.
     * @function verify
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiSayHi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sayHiTime != null && message.hasOwnProperty("sayHiTime"))
            if (!$util.isInteger(message.sayHiTime) && !(message.sayHiTime && $util.isInteger(message.sayHiTime.low) && $util.isInteger(message.sayHiTime.high)))
                return "sayHiTime: integer|Long expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a S2C_MenpaiSayHi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiSayHi} S2C_MenpaiSayHi
     */
    S2C_MenpaiSayHi.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiSayHi)
            return object;
        var message = new $root.S2C_MenpaiSayHi();
        if (object.sayHiTime != null)
            if ($util.Long)
                (message.sayHiTime = $util.Long.fromValue(object.sayHiTime)).unsigned = false;
            else if (typeof object.sayHiTime === "string")
                message.sayHiTime = parseInt(object.sayHiTime, 10);
            else if (typeof object.sayHiTime === "number")
                message.sayHiTime = object.sayHiTime;
            else if (typeof object.sayHiTime === "object")
                message.sayHiTime = new $util.LongBits(object.sayHiTime.low >>> 0, object.sayHiTime.high >>> 0).toNumber();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_MenpaiSayHi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiSayHi
     * @static
     * @param {S2C_MenpaiSayHi} message S2C_MenpaiSayHi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiSayHi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.sayHiTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.sayHiTime = options.longs === String ? "0" : 0;
            object.id = 0;
        }
        if (message.sayHiTime != null && message.hasOwnProperty("sayHiTime"))
            if (typeof message.sayHiTime === "number")
                object.sayHiTime = options.longs === String ? String(message.sayHiTime) : message.sayHiTime;
            else
                object.sayHiTime = options.longs === String ? $util.Long.prototype.toString.call(message.sayHiTime) : options.longs === Number ? new $util.LongBits(message.sayHiTime.low >>> 0, message.sayHiTime.high >>> 0).toNumber() : message.sayHiTime;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this S2C_MenpaiSayHi to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiSayHi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiSayHi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiSayHi;
})();

$root.C2S_MenpaiStudySkill = (function() {

    /**
     * Properties of a C2S_MenpaiStudySkill.
     * @exports IC2S_MenpaiStudySkill
     * @interface IC2S_MenpaiStudySkill
     * @property {number|null} [gongfaId] C2S_MenpaiStudySkill gongfaId
     */

    /**
     * Constructs a new C2S_MenpaiStudySkill.
     * @exports C2S_MenpaiStudySkill
     * @classdesc Represents a C2S_MenpaiStudySkill.
     * @implements IC2S_MenpaiStudySkill
     * @constructor
     * @param {IC2S_MenpaiStudySkill=} [properties] Properties to set
     */
    function C2S_MenpaiStudySkill(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MenpaiStudySkill gongfaId.
     * @member {number} gongfaId
     * @memberof C2S_MenpaiStudySkill
     * @instance
     */
    C2S_MenpaiStudySkill.prototype.gongfaId = 0;

    /**
     * Creates a new C2S_MenpaiStudySkill instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {IC2S_MenpaiStudySkill=} [properties] Properties to set
     * @returns {C2S_MenpaiStudySkill} C2S_MenpaiStudySkill instance
     */
    C2S_MenpaiStudySkill.create = function create(properties) {
        return new C2S_MenpaiStudySkill(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiStudySkill message. Does not implicitly {@link C2S_MenpaiStudySkill.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {IC2S_MenpaiStudySkill} message C2S_MenpaiStudySkill message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiStudySkill.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.gongfaId != null && message.hasOwnProperty("gongfaId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gongfaId);
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiStudySkill message, length delimited. Does not implicitly {@link C2S_MenpaiStudySkill.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {IC2S_MenpaiStudySkill} message C2S_MenpaiStudySkill message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiStudySkill.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiStudySkill message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiStudySkill} C2S_MenpaiStudySkill
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiStudySkill.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiStudySkill();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.gongfaId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiStudySkill message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiStudySkill} C2S_MenpaiStudySkill
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiStudySkill.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiStudySkill message.
     * @function verify
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiStudySkill.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.gongfaId != null && message.hasOwnProperty("gongfaId"))
            if (!$util.isInteger(message.gongfaId))
                return "gongfaId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiStudySkill message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiStudySkill} C2S_MenpaiStudySkill
     */
    C2S_MenpaiStudySkill.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiStudySkill)
            return object;
        var message = new $root.C2S_MenpaiStudySkill();
        if (object.gongfaId != null)
            message.gongfaId = object.gongfaId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MenpaiStudySkill message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiStudySkill
     * @static
     * @param {C2S_MenpaiStudySkill} message C2S_MenpaiStudySkill
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiStudySkill.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.gongfaId = 0;
        if (message.gongfaId != null && message.hasOwnProperty("gongfaId"))
            object.gongfaId = message.gongfaId;
        return object;
    };

    /**
     * Converts this C2S_MenpaiStudySkill to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiStudySkill
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiStudySkill.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiStudySkill;
})();

$root.S2C_MenpaiStudySkill = (function() {

    /**
     * Properties of a S2C_MenpaiStudySkill.
     * @exports IS2C_MenpaiStudySkill
     * @interface IS2C_MenpaiStudySkill
     */

    /**
     * Constructs a new S2C_MenpaiStudySkill.
     * @exports S2C_MenpaiStudySkill
     * @classdesc Represents a S2C_MenpaiStudySkill.
     * @implements IS2C_MenpaiStudySkill
     * @constructor
     * @param {IS2C_MenpaiStudySkill=} [properties] Properties to set
     */
    function S2C_MenpaiStudySkill(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_MenpaiStudySkill instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {IS2C_MenpaiStudySkill=} [properties] Properties to set
     * @returns {S2C_MenpaiStudySkill} S2C_MenpaiStudySkill instance
     */
    S2C_MenpaiStudySkill.create = function create(properties) {
        return new S2C_MenpaiStudySkill(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiStudySkill message. Does not implicitly {@link S2C_MenpaiStudySkill.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {IS2C_MenpaiStudySkill} message S2C_MenpaiStudySkill message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiStudySkill.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiStudySkill message, length delimited. Does not implicitly {@link S2C_MenpaiStudySkill.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {IS2C_MenpaiStudySkill} message S2C_MenpaiStudySkill message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiStudySkill.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiStudySkill message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiStudySkill} S2C_MenpaiStudySkill
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiStudySkill.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiStudySkill();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiStudySkill message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiStudySkill} S2C_MenpaiStudySkill
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiStudySkill.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiStudySkill message.
     * @function verify
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiStudySkill.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_MenpaiStudySkill message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiStudySkill} S2C_MenpaiStudySkill
     */
    S2C_MenpaiStudySkill.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiStudySkill)
            return object;
        return new $root.S2C_MenpaiStudySkill();
    };

    /**
     * Creates a plain object from a S2C_MenpaiStudySkill message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiStudySkill
     * @static
     * @param {S2C_MenpaiStudySkill} message S2C_MenpaiStudySkill
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiStudySkill.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_MenpaiStudySkill to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiStudySkill
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiStudySkill.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiStudySkill;
})();

$root.C2S_MenpaiStudy = (function() {

    /**
     * Properties of a C2S_MenpaiStudy.
     * @exports IC2S_MenpaiStudy
     * @interface IC2S_MenpaiStudy
     * @property {number|null} [npcId] C2S_MenpaiStudy npcId
     */

    /**
     * Constructs a new C2S_MenpaiStudy.
     * @exports C2S_MenpaiStudy
     * @classdesc Represents a C2S_MenpaiStudy.
     * @implements IC2S_MenpaiStudy
     * @constructor
     * @param {IC2S_MenpaiStudy=} [properties] Properties to set
     */
    function C2S_MenpaiStudy(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_MenpaiStudy npcId.
     * @member {number} npcId
     * @memberof C2S_MenpaiStudy
     * @instance
     */
    C2S_MenpaiStudy.prototype.npcId = 0;

    /**
     * Creates a new C2S_MenpaiStudy instance using the specified properties.
     * @function create
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {IC2S_MenpaiStudy=} [properties] Properties to set
     * @returns {C2S_MenpaiStudy} C2S_MenpaiStudy instance
     */
    C2S_MenpaiStudy.create = function create(properties) {
        return new C2S_MenpaiStudy(properties);
    };

    /**
     * Encodes the specified C2S_MenpaiStudy message. Does not implicitly {@link C2S_MenpaiStudy.verify|verify} messages.
     * @function encode
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {IC2S_MenpaiStudy} message C2S_MenpaiStudy message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiStudy.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.npcId != null && message.hasOwnProperty("npcId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.npcId);
        return writer;
    };

    /**
     * Encodes the specified C2S_MenpaiStudy message, length delimited. Does not implicitly {@link C2S_MenpaiStudy.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {IC2S_MenpaiStudy} message C2S_MenpaiStudy message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_MenpaiStudy.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_MenpaiStudy message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_MenpaiStudy} C2S_MenpaiStudy
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiStudy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_MenpaiStudy();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.npcId = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_MenpaiStudy message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_MenpaiStudy} C2S_MenpaiStudy
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_MenpaiStudy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_MenpaiStudy message.
     * @function verify
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_MenpaiStudy.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.npcId != null && message.hasOwnProperty("npcId"))
            if (!$util.isInteger(message.npcId))
                return "npcId: integer expected";
        return null;
    };

    /**
     * Creates a C2S_MenpaiStudy message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_MenpaiStudy} C2S_MenpaiStudy
     */
    C2S_MenpaiStudy.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_MenpaiStudy)
            return object;
        var message = new $root.C2S_MenpaiStudy();
        if (object.npcId != null)
            message.npcId = object.npcId | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_MenpaiStudy message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_MenpaiStudy
     * @static
     * @param {C2S_MenpaiStudy} message C2S_MenpaiStudy
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_MenpaiStudy.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.npcId = 0;
        if (message.npcId != null && message.hasOwnProperty("npcId"))
            object.npcId = message.npcId;
        return object;
    };

    /**
     * Converts this C2S_MenpaiStudy to JSON.
     * @function toJSON
     * @memberof C2S_MenpaiStudy
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_MenpaiStudy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_MenpaiStudy;
})();

$root.S2C_MenpaiStudy = (function() {

    /**
     * Properties of a S2C_MenpaiStudy.
     * @exports IS2C_MenpaiStudy
     * @interface IS2C_MenpaiStudy
     * @property {IFightResultMsg|null} [result] S2C_MenpaiStudy result
     */

    /**
     * Constructs a new S2C_MenpaiStudy.
     * @exports S2C_MenpaiStudy
     * @classdesc Represents a S2C_MenpaiStudy.
     * @implements IS2C_MenpaiStudy
     * @constructor
     * @param {IS2C_MenpaiStudy=} [properties] Properties to set
     */
    function S2C_MenpaiStudy(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_MenpaiStudy result.
     * @member {IFightResultMsg|null|undefined} result
     * @memberof S2C_MenpaiStudy
     * @instance
     */
    S2C_MenpaiStudy.prototype.result = null;

    /**
     * Creates a new S2C_MenpaiStudy instance using the specified properties.
     * @function create
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {IS2C_MenpaiStudy=} [properties] Properties to set
     * @returns {S2C_MenpaiStudy} S2C_MenpaiStudy instance
     */
    S2C_MenpaiStudy.create = function create(properties) {
        return new S2C_MenpaiStudy(properties);
    };

    /**
     * Encodes the specified S2C_MenpaiStudy message. Does not implicitly {@link S2C_MenpaiStudy.verify|verify} messages.
     * @function encode
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {IS2C_MenpaiStudy} message S2C_MenpaiStudy message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiStudy.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && message.hasOwnProperty("result"))
            $root.FightResultMsg.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_MenpaiStudy message, length delimited. Does not implicitly {@link S2C_MenpaiStudy.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {IS2C_MenpaiStudy} message S2C_MenpaiStudy message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_MenpaiStudy.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_MenpaiStudy message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_MenpaiStudy} S2C_MenpaiStudy
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiStudy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_MenpaiStudy();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = $root.FightResultMsg.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_MenpaiStudy message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_MenpaiStudy} S2C_MenpaiStudy
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_MenpaiStudy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_MenpaiStudy message.
     * @function verify
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_MenpaiStudy.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result")) {
            var error = $root.FightResultMsg.verify(message.result);
            if (error)
                return "result." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_MenpaiStudy message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_MenpaiStudy} S2C_MenpaiStudy
     */
    S2C_MenpaiStudy.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_MenpaiStudy)
            return object;
        var message = new $root.S2C_MenpaiStudy();
        if (object.result != null) {
            if (typeof object.result !== "object")
                throw TypeError(".S2C_MenpaiStudy.result: object expected");
            message.result = $root.FightResultMsg.fromObject(object.result);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_MenpaiStudy message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_MenpaiStudy
     * @static
     * @param {S2C_MenpaiStudy} message S2C_MenpaiStudy
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_MenpaiStudy.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.result = null;
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = $root.FightResultMsg.toObject(message.result, options);
        return object;
    };

    /**
     * Converts this S2C_MenpaiStudy to JSON.
     * @function toJSON
     * @memberof S2C_MenpaiStudy
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_MenpaiStudy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_MenpaiStudy;
})();

$root.PlayerMsg = (function() {

    /**
     * Properties of a PlayerMsg.
     * @exports IPlayerMsg
     * @interface IPlayerMsg
     * @property {number|Long|null} [pid] PlayerMsg pid
     * @property {string|null} [name] PlayerMsg name
     * @property {number|null} [icon] PlayerMsg icon
     * @property {string|null} [channel] PlayerMsg channel
     * @property {number|null} [level1] PlayerMsg level1
     * @property {number|null} [level2] PlayerMsg level2
     * @property {number|Long|null} [registerTime] PlayerMsg registerTime
     * @property {number|null} [pkgNum] PlayerMsg pkgNum
     * @property {number|null} [pkgLevel] PlayerMsg pkgLevel
     * @property {number|null} [pkgUse] PlayerMsg pkgUse
     */

    /**
     * Constructs a new PlayerMsg.
     * @exports PlayerMsg
     * @classdesc Represents a PlayerMsg.
     * @implements IPlayerMsg
     * @constructor
     * @param {IPlayerMsg=} [properties] Properties to set
     */
    function PlayerMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PlayerMsg pid.
     * @member {number|Long} pid
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.pid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PlayerMsg name.
     * @member {string} name
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.name = "";

    /**
     * PlayerMsg icon.
     * @member {number} icon
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.icon = 0;

    /**
     * PlayerMsg channel.
     * @member {string} channel
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.channel = "";

    /**
     * PlayerMsg level1.
     * @member {number} level1
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.level1 = 0;

    /**
     * PlayerMsg level2.
     * @member {number} level2
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.level2 = 0;

    /**
     * PlayerMsg registerTime.
     * @member {number|Long} registerTime
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.registerTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PlayerMsg pkgNum.
     * @member {number} pkgNum
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.pkgNum = 0;

    /**
     * PlayerMsg pkgLevel.
     * @member {number} pkgLevel
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.pkgLevel = 0;

    /**
     * PlayerMsg pkgUse.
     * @member {number} pkgUse
     * @memberof PlayerMsg
     * @instance
     */
    PlayerMsg.prototype.pkgUse = 0;

    /**
     * Creates a new PlayerMsg instance using the specified properties.
     * @function create
     * @memberof PlayerMsg
     * @static
     * @param {IPlayerMsg=} [properties] Properties to set
     * @returns {PlayerMsg} PlayerMsg instance
     */
    PlayerMsg.create = function create(properties) {
        return new PlayerMsg(properties);
    };

    /**
     * Encodes the specified PlayerMsg message. Does not implicitly {@link PlayerMsg.verify|verify} messages.
     * @function encode
     * @memberof PlayerMsg
     * @static
     * @param {IPlayerMsg} message PlayerMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlayerMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pid != null && message.hasOwnProperty("pid"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.pid);
        if (message.name != null && message.hasOwnProperty("name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.icon != null && message.hasOwnProperty("icon"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.icon);
        if (message.channel != null && message.hasOwnProperty("channel"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.channel);
        if (message.level1 != null && message.hasOwnProperty("level1"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.level1);
        if (message.level2 != null && message.hasOwnProperty("level2"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.level2);
        if (message.registerTime != null && message.hasOwnProperty("registerTime"))
            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.registerTime);
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.pkgNum);
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.pkgLevel);
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.pkgUse);
        return writer;
    };

    /**
     * Encodes the specified PlayerMsg message, length delimited. Does not implicitly {@link PlayerMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PlayerMsg
     * @static
     * @param {IPlayerMsg} message PlayerMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlayerMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PlayerMsg message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerMsg} PlayerMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.pid = reader.int64();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.icon = reader.int32();
                break;
            case 4:
                message.channel = reader.string();
                break;
            case 5:
                message.level1 = reader.int32();
                break;
            case 6:
                message.level2 = reader.int32();
                break;
            case 7:
                message.registerTime = reader.int64();
                break;
            case 8:
                message.pkgNum = reader.int32();
                break;
            case 9:
                message.pkgLevel = reader.int32();
                break;
            case 10:
                message.pkgUse = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PlayerMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PlayerMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PlayerMsg} PlayerMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PlayerMsg message.
     * @function verify
     * @memberof PlayerMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PlayerMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pid != null && message.hasOwnProperty("pid"))
            if (!$util.isInteger(message.pid) && !(message.pid && $util.isInteger(message.pid.low) && $util.isInteger(message.pid.high)))
                return "pid: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.icon != null && message.hasOwnProperty("icon"))
            if (!$util.isInteger(message.icon))
                return "icon: integer expected";
        if (message.channel != null && message.hasOwnProperty("channel"))
            if (!$util.isString(message.channel))
                return "channel: string expected";
        if (message.level1 != null && message.hasOwnProperty("level1"))
            if (!$util.isInteger(message.level1))
                return "level1: integer expected";
        if (message.level2 != null && message.hasOwnProperty("level2"))
            if (!$util.isInteger(message.level2))
                return "level2: integer expected";
        if (message.registerTime != null && message.hasOwnProperty("registerTime"))
            if (!$util.isInteger(message.registerTime) && !(message.registerTime && $util.isInteger(message.registerTime.low) && $util.isInteger(message.registerTime.high)))
                return "registerTime: integer|Long expected";
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            if (!$util.isInteger(message.pkgNum))
                return "pkgNum: integer expected";
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            if (!$util.isInteger(message.pkgLevel))
                return "pkgLevel: integer expected";
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            if (!$util.isInteger(message.pkgUse))
                return "pkgUse: integer expected";
        return null;
    };

    /**
     * Creates a PlayerMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PlayerMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PlayerMsg} PlayerMsg
     */
    PlayerMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.PlayerMsg)
            return object;
        var message = new $root.PlayerMsg();
        if (object.pid != null)
            if ($util.Long)
                (message.pid = $util.Long.fromValue(object.pid)).unsigned = false;
            else if (typeof object.pid === "string")
                message.pid = parseInt(object.pid, 10);
            else if (typeof object.pid === "number")
                message.pid = object.pid;
            else if (typeof object.pid === "object")
                message.pid = new $util.LongBits(object.pid.low >>> 0, object.pid.high >>> 0).toNumber();
        if (object.name != null)
            message.name = String(object.name);
        if (object.icon != null)
            message.icon = object.icon | 0;
        if (object.channel != null)
            message.channel = String(object.channel);
        if (object.level1 != null)
            message.level1 = object.level1 | 0;
        if (object.level2 != null)
            message.level2 = object.level2 | 0;
        if (object.registerTime != null)
            if ($util.Long)
                (message.registerTime = $util.Long.fromValue(object.registerTime)).unsigned = false;
            else if (typeof object.registerTime === "string")
                message.registerTime = parseInt(object.registerTime, 10);
            else if (typeof object.registerTime === "number")
                message.registerTime = object.registerTime;
            else if (typeof object.registerTime === "object")
                message.registerTime = new $util.LongBits(object.registerTime.low >>> 0, object.registerTime.high >>> 0).toNumber();
        if (object.pkgNum != null)
            message.pkgNum = object.pkgNum | 0;
        if (object.pkgLevel != null)
            message.pkgLevel = object.pkgLevel | 0;
        if (object.pkgUse != null)
            message.pkgUse = object.pkgUse | 0;
        return message;
    };

    /**
     * Creates a plain object from a PlayerMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PlayerMsg
     * @static
     * @param {PlayerMsg} message PlayerMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PlayerMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.pid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.pid = options.longs === String ? "0" : 0;
            object.name = "";
            object.icon = 0;
            object.channel = "";
            object.level1 = 0;
            object.level2 = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.registerTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.registerTime = options.longs === String ? "0" : 0;
            object.pkgNum = 0;
            object.pkgLevel = 0;
            object.pkgUse = 0;
        }
        if (message.pid != null && message.hasOwnProperty("pid"))
            if (typeof message.pid === "number")
                object.pid = options.longs === String ? String(message.pid) : message.pid;
            else
                object.pid = options.longs === String ? $util.Long.prototype.toString.call(message.pid) : options.longs === Number ? new $util.LongBits(message.pid.low >>> 0, message.pid.high >>> 0).toNumber() : message.pid;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = message.icon;
        if (message.channel != null && message.hasOwnProperty("channel"))
            object.channel = message.channel;
        if (message.level1 != null && message.hasOwnProperty("level1"))
            object.level1 = message.level1;
        if (message.level2 != null && message.hasOwnProperty("level2"))
            object.level2 = message.level2;
        if (message.registerTime != null && message.hasOwnProperty("registerTime"))
            if (typeof message.registerTime === "number")
                object.registerTime = options.longs === String ? String(message.registerTime) : message.registerTime;
            else
                object.registerTime = options.longs === String ? $util.Long.prototype.toString.call(message.registerTime) : options.longs === Number ? new $util.LongBits(message.registerTime.low >>> 0, message.registerTime.high >>> 0).toNumber() : message.registerTime;
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            object.pkgNum = message.pkgNum;
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            object.pkgLevel = message.pkgLevel;
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            object.pkgUse = message.pkgUse;
        return object;
    };

    /**
     * Converts this PlayerMsg to JSON.
     * @function toJSON
     * @memberof PlayerMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PlayerMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PlayerMsg;
})();

$root.C2S_Login = (function() {

    /**
     * Properties of a C2S_Login.
     * @exports IC2S_Login
     * @interface IC2S_Login
     * @property {string|null} [channel] C2S_Login channel
     * @property {string|null} [session] C2S_Login session
     * @property {number|Long|null} [uid] C2S_Login uid
     * @property {string|null} [openId] C2S_Login openId
     * @property {number|null} [sid] C2S_Login sid
     * @property {number|null} [zhongZu] C2S_Login zhongZu
     */

    /**
     * Constructs a new C2S_Login.
     * @exports C2S_Login
     * @classdesc Represents a C2S_Login.
     * @implements IC2S_Login
     * @constructor
     * @param {IC2S_Login=} [properties] Properties to set
     */
    function C2S_Login(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_Login channel.
     * @member {string} channel
     * @memberof C2S_Login
     * @instance
     */
    C2S_Login.prototype.channel = "";

    /**
     * C2S_Login session.
     * @member {string} session
     * @memberof C2S_Login
     * @instance
     */
    C2S_Login.prototype.session = "";

    /**
     * C2S_Login uid.
     * @member {number|Long} uid
     * @memberof C2S_Login
     * @instance
     */
    C2S_Login.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * C2S_Login openId.
     * @member {string} openId
     * @memberof C2S_Login
     * @instance
     */
    C2S_Login.prototype.openId = "";

    /**
     * C2S_Login sid.
     * @member {number} sid
     * @memberof C2S_Login
     * @instance
     */
    C2S_Login.prototype.sid = 0;

    /**
     * C2S_Login zhongZu.
     * @member {number} zhongZu
     * @memberof C2S_Login
     * @instance
     */
    C2S_Login.prototype.zhongZu = 0;

    /**
     * Creates a new C2S_Login instance using the specified properties.
     * @function create
     * @memberof C2S_Login
     * @static
     * @param {IC2S_Login=} [properties] Properties to set
     * @returns {C2S_Login} C2S_Login instance
     */
    C2S_Login.create = function create(properties) {
        return new C2S_Login(properties);
    };

    /**
     * Encodes the specified C2S_Login message. Does not implicitly {@link C2S_Login.verify|verify} messages.
     * @function encode
     * @memberof C2S_Login
     * @static
     * @param {IC2S_Login} message C2S_Login message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Login.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.channel != null && message.hasOwnProperty("channel"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
        if (message.session != null && message.hasOwnProperty("session"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.session);
        if (message.uid != null && message.hasOwnProperty("uid"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
        if (message.openId != null && message.hasOwnProperty("openId"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.openId);
        if (message.sid != null && message.hasOwnProperty("sid"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sid);
        if (message.zhongZu != null && message.hasOwnProperty("zhongZu"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.zhongZu);
        return writer;
    };

    /**
     * Encodes the specified C2S_Login message, length delimited. Does not implicitly {@link C2S_Login.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Login
     * @static
     * @param {IC2S_Login} message C2S_Login message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Login.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Login message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Login
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Login} C2S_Login
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Login.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Login();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.channel = reader.string();
                break;
            case 2:
                message.session = reader.string();
                break;
            case 3:
                message.uid = reader.int64();
                break;
            case 4:
                message.openId = reader.string();
                break;
            case 5:
                message.sid = reader.int32();
                break;
            case 6:
                message.zhongZu = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Login message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Login
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Login} C2S_Login
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Login.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Login message.
     * @function verify
     * @memberof C2S_Login
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Login.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.channel != null && message.hasOwnProperty("channel"))
            if (!$util.isString(message.channel))
                return "channel: string expected";
        if (message.session != null && message.hasOwnProperty("session"))
            if (!$util.isString(message.session))
                return "session: string expected";
        if (message.uid != null && message.hasOwnProperty("uid"))
            if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                return "uid: integer|Long expected";
        if (message.openId != null && message.hasOwnProperty("openId"))
            if (!$util.isString(message.openId))
                return "openId: string expected";
        if (message.sid != null && message.hasOwnProperty("sid"))
            if (!$util.isInteger(message.sid))
                return "sid: integer expected";
        if (message.zhongZu != null && message.hasOwnProperty("zhongZu"))
            if (!$util.isInteger(message.zhongZu))
                return "zhongZu: integer expected";
        return null;
    };

    /**
     * Creates a C2S_Login message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Login
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Login} C2S_Login
     */
    C2S_Login.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Login)
            return object;
        var message = new $root.C2S_Login();
        if (object.channel != null)
            message.channel = String(object.channel);
        if (object.session != null)
            message.session = String(object.session);
        if (object.uid != null)
            if ($util.Long)
                (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
            else if (typeof object.uid === "string")
                message.uid = parseInt(object.uid, 10);
            else if (typeof object.uid === "number")
                message.uid = object.uid;
            else if (typeof object.uid === "object")
                message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
        if (object.openId != null)
            message.openId = String(object.openId);
        if (object.sid != null)
            message.sid = object.sid | 0;
        if (object.zhongZu != null)
            message.zhongZu = object.zhongZu | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_Login message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Login
     * @static
     * @param {C2S_Login} message C2S_Login
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Login.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.channel = "";
            object.session = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.uid = options.longs === String ? "0" : 0;
            object.openId = "";
            object.sid = 0;
            object.zhongZu = 0;
        }
        if (message.channel != null && message.hasOwnProperty("channel"))
            object.channel = message.channel;
        if (message.session != null && message.hasOwnProperty("session"))
            object.session = message.session;
        if (message.uid != null && message.hasOwnProperty("uid"))
            if (typeof message.uid === "number")
                object.uid = options.longs === String ? String(message.uid) : message.uid;
            else
                object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
        if (message.openId != null && message.hasOwnProperty("openId"))
            object.openId = message.openId;
        if (message.sid != null && message.hasOwnProperty("sid"))
            object.sid = message.sid;
        if (message.zhongZu != null && message.hasOwnProperty("zhongZu"))
            object.zhongZu = message.zhongZu;
        return object;
    };

    /**
     * Converts this C2S_Login to JSON.
     * @function toJSON
     * @memberof C2S_Login
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Login.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Login;
})();

$root.S2C_Login = (function() {

    /**
     * Properties of a S2C_Login.
     * @exports IS2C_Login
     * @interface IS2C_Login
     * @property {boolean|null} [register] S2C_Login register
     */

    /**
     * Constructs a new S2C_Login.
     * @exports S2C_Login
     * @classdesc Represents a S2C_Login.
     * @implements IS2C_Login
     * @constructor
     * @param {IS2C_Login=} [properties] Properties to set
     */
    function S2C_Login(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Login register.
     * @member {boolean} register
     * @memberof S2C_Login
     * @instance
     */
    S2C_Login.prototype.register = false;

    /**
     * Creates a new S2C_Login instance using the specified properties.
     * @function create
     * @memberof S2C_Login
     * @static
     * @param {IS2C_Login=} [properties] Properties to set
     * @returns {S2C_Login} S2C_Login instance
     */
    S2C_Login.create = function create(properties) {
        return new S2C_Login(properties);
    };

    /**
     * Encodes the specified S2C_Login message. Does not implicitly {@link S2C_Login.verify|verify} messages.
     * @function encode
     * @memberof S2C_Login
     * @static
     * @param {IS2C_Login} message S2C_Login message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Login.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.register != null && message.hasOwnProperty("register"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.register);
        return writer;
    };

    /**
     * Encodes the specified S2C_Login message, length delimited. Does not implicitly {@link S2C_Login.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Login
     * @static
     * @param {IS2C_Login} message S2C_Login message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Login.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Login message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Login
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Login} S2C_Login
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Login.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Login();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.register = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Login message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Login
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Login} S2C_Login
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Login.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Login message.
     * @function verify
     * @memberof S2C_Login
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Login.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.register != null && message.hasOwnProperty("register"))
            if (typeof message.register !== "boolean")
                return "register: boolean expected";
        return null;
    };

    /**
     * Creates a S2C_Login message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Login
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Login} S2C_Login
     */
    S2C_Login.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Login)
            return object;
        var message = new $root.S2C_Login();
        if (object.register != null)
            message.register = Boolean(object.register);
        return message;
    };

    /**
     * Creates a plain object from a S2C_Login message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Login
     * @static
     * @param {S2C_Login} message S2C_Login
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Login.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.register = false;
        if (message.register != null && message.hasOwnProperty("register"))
            object.register = message.register;
        return object;
    };

    /**
     * Converts this S2C_Login to JSON.
     * @function toJSON
     * @memberof S2C_Login
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Login.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Login;
})();

$root.C2S_Register = (function() {

    /**
     * Properties of a C2S_Register.
     * @exports IC2S_Register
     * @interface IC2S_Register
     */

    /**
     * Constructs a new C2S_Register.
     * @exports C2S_Register
     * @classdesc Represents a C2S_Register.
     * @implements IC2S_Register
     * @constructor
     * @param {IC2S_Register=} [properties] Properties to set
     */
    function C2S_Register(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_Register instance using the specified properties.
     * @function create
     * @memberof C2S_Register
     * @static
     * @param {IC2S_Register=} [properties] Properties to set
     * @returns {C2S_Register} C2S_Register instance
     */
    C2S_Register.create = function create(properties) {
        return new C2S_Register(properties);
    };

    /**
     * Encodes the specified C2S_Register message. Does not implicitly {@link C2S_Register.verify|verify} messages.
     * @function encode
     * @memberof C2S_Register
     * @static
     * @param {IC2S_Register} message C2S_Register message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Register.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_Register message, length delimited. Does not implicitly {@link C2S_Register.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Register
     * @static
     * @param {IC2S_Register} message C2S_Register message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Register.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Register message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Register
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Register} C2S_Register
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Register.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Register();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Register message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Register
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Register} C2S_Register
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Register.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Register message.
     * @function verify
     * @memberof C2S_Register
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Register.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_Register message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Register
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Register} C2S_Register
     */
    C2S_Register.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Register)
            return object;
        return new $root.C2S_Register();
    };

    /**
     * Creates a plain object from a C2S_Register message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Register
     * @static
     * @param {C2S_Register} message C2S_Register
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Register.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_Register to JSON.
     * @function toJSON
     * @memberof C2S_Register
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Register.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Register;
})();

$root.S2C_Register = (function() {

    /**
     * Properties of a S2C_Register.
     * @exports IS2C_Register
     * @interface IS2C_Register
     * @property {boolean|null} [result] S2C_Register result
     */

    /**
     * Constructs a new S2C_Register.
     * @exports S2C_Register
     * @classdesc Represents a S2C_Register.
     * @implements IS2C_Register
     * @constructor
     * @param {IS2C_Register=} [properties] Properties to set
     */
    function S2C_Register(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Register result.
     * @member {boolean} result
     * @memberof S2C_Register
     * @instance
     */
    S2C_Register.prototype.result = false;

    /**
     * Creates a new S2C_Register instance using the specified properties.
     * @function create
     * @memberof S2C_Register
     * @static
     * @param {IS2C_Register=} [properties] Properties to set
     * @returns {S2C_Register} S2C_Register instance
     */
    S2C_Register.create = function create(properties) {
        return new S2C_Register(properties);
    };

    /**
     * Encodes the specified S2C_Register message. Does not implicitly {@link S2C_Register.verify|verify} messages.
     * @function encode
     * @memberof S2C_Register
     * @static
     * @param {IS2C_Register} message S2C_Register message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Register.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && message.hasOwnProperty("result"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.result);
        return writer;
    };

    /**
     * Encodes the specified S2C_Register message, length delimited. Does not implicitly {@link S2C_Register.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Register
     * @static
     * @param {IS2C_Register} message S2C_Register message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Register.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Register message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Register
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Register} S2C_Register
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Register.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Register();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Register message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Register
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Register} S2C_Register
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Register.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Register message.
     * @function verify
     * @memberof S2C_Register
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Register.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result"))
            if (typeof message.result !== "boolean")
                return "result: boolean expected";
        return null;
    };

    /**
     * Creates a S2C_Register message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Register
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Register} S2C_Register
     */
    S2C_Register.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Register)
            return object;
        var message = new $root.S2C_Register();
        if (object.result != null)
            message.result = Boolean(object.result);
        return message;
    };

    /**
     * Creates a plain object from a S2C_Register message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Register
     * @static
     * @param {S2C_Register} message S2C_Register
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Register.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.result = false;
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = message.result;
        return object;
    };

    /**
     * Converts this S2C_Register to JSON.
     * @function toJSON
     * @memberof S2C_Register
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Register.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Register;
})();

$root.C2S_GetPlayer = (function() {

    /**
     * Properties of a C2S_GetPlayer.
     * @exports IC2S_GetPlayer
     * @interface IC2S_GetPlayer
     */

    /**
     * Constructs a new C2S_GetPlayer.
     * @exports C2S_GetPlayer
     * @classdesc Represents a C2S_GetPlayer.
     * @implements IC2S_GetPlayer
     * @constructor
     * @param {IC2S_GetPlayer=} [properties] Properties to set
     */
    function C2S_GetPlayer(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_GetPlayer instance using the specified properties.
     * @function create
     * @memberof C2S_GetPlayer
     * @static
     * @param {IC2S_GetPlayer=} [properties] Properties to set
     * @returns {C2S_GetPlayer} C2S_GetPlayer instance
     */
    C2S_GetPlayer.create = function create(properties) {
        return new C2S_GetPlayer(properties);
    };

    /**
     * Encodes the specified C2S_GetPlayer message. Does not implicitly {@link C2S_GetPlayer.verify|verify} messages.
     * @function encode
     * @memberof C2S_GetPlayer
     * @static
     * @param {IC2S_GetPlayer} message C2S_GetPlayer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetPlayer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_GetPlayer message, length delimited. Does not implicitly {@link C2S_GetPlayer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_GetPlayer
     * @static
     * @param {IC2S_GetPlayer} message C2S_GetPlayer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetPlayer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_GetPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_GetPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_GetPlayer} C2S_GetPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_GetPlayer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_GetPlayer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_GetPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_GetPlayer} C2S_GetPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetPlayer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_GetPlayer message.
     * @function verify
     * @memberof C2S_GetPlayer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_GetPlayer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_GetPlayer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_GetPlayer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_GetPlayer} C2S_GetPlayer
     */
    C2S_GetPlayer.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_GetPlayer)
            return object;
        return new $root.C2S_GetPlayer();
    };

    /**
     * Creates a plain object from a C2S_GetPlayer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_GetPlayer
     * @static
     * @param {C2S_GetPlayer} message C2S_GetPlayer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_GetPlayer.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_GetPlayer to JSON.
     * @function toJSON
     * @memberof C2S_GetPlayer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_GetPlayer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_GetPlayer;
})();

$root.S2C_GetPlayer = (function() {

    /**
     * Properties of a S2C_GetPlayer.
     * @exports IS2C_GetPlayer
     * @interface IS2C_GetPlayer
     * @property {IPlayerMsg|null} [player] S2C_GetPlayer player
     * @property {number|Long|null} [serverTime] S2C_GetPlayer serverTime
     * @property {Array.<IItemMsg>|null} [item] S2C_GetPlayer item
     * @property {Array.<IDanYaoInfoPB>|null} [danYao] S2C_GetPlayer danYao
     * @property {Array.<IExchangeMsg>|null} [exchange] S2C_GetPlayer exchange
     */

    /**
     * Constructs a new S2C_GetPlayer.
     * @exports S2C_GetPlayer
     * @classdesc Represents a S2C_GetPlayer.
     * @implements IS2C_GetPlayer
     * @constructor
     * @param {IS2C_GetPlayer=} [properties] Properties to set
     */
    function S2C_GetPlayer(properties) {
        this.item = [];
        this.danYao = [];
        this.exchange = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_GetPlayer player.
     * @member {IPlayerMsg|null|undefined} player
     * @memberof S2C_GetPlayer
     * @instance
     */
    S2C_GetPlayer.prototype.player = null;

    /**
     * S2C_GetPlayer serverTime.
     * @member {number|Long} serverTime
     * @memberof S2C_GetPlayer
     * @instance
     */
    S2C_GetPlayer.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_GetPlayer item.
     * @member {Array.<IItemMsg>} item
     * @memberof S2C_GetPlayer
     * @instance
     */
    S2C_GetPlayer.prototype.item = $util.emptyArray;

    /**
     * S2C_GetPlayer danYao.
     * @member {Array.<IDanYaoInfoPB>} danYao
     * @memberof S2C_GetPlayer
     * @instance
     */
    S2C_GetPlayer.prototype.danYao = $util.emptyArray;

    /**
     * S2C_GetPlayer exchange.
     * @member {Array.<IExchangeMsg>} exchange
     * @memberof S2C_GetPlayer
     * @instance
     */
    S2C_GetPlayer.prototype.exchange = $util.emptyArray;

    /**
     * Creates a new S2C_GetPlayer instance using the specified properties.
     * @function create
     * @memberof S2C_GetPlayer
     * @static
     * @param {IS2C_GetPlayer=} [properties] Properties to set
     * @returns {S2C_GetPlayer} S2C_GetPlayer instance
     */
    S2C_GetPlayer.create = function create(properties) {
        return new S2C_GetPlayer(properties);
    };

    /**
     * Encodes the specified S2C_GetPlayer message. Does not implicitly {@link S2C_GetPlayer.verify|verify} messages.
     * @function encode
     * @memberof S2C_GetPlayer
     * @static
     * @param {IS2C_GetPlayer} message S2C_GetPlayer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetPlayer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.player != null && message.hasOwnProperty("player"))
            $root.PlayerMsg.encode(message.player, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.serverTime != null && message.hasOwnProperty("serverTime"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.serverTime);
        if (message.item != null && message.item.length)
            for (var i = 0; i < message.item.length; ++i)
                $root.ItemMsg.encode(message.item[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.danYao != null && message.danYao.length)
            for (var i = 0; i < message.danYao.length; ++i)
                $root.DanYaoInfoPB.encode(message.danYao[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.exchange != null && message.exchange.length)
            for (var i = 0; i < message.exchange.length; ++i)
                $root.ExchangeMsg.encode(message.exchange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_GetPlayer message, length delimited. Does not implicitly {@link S2C_GetPlayer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_GetPlayer
     * @static
     * @param {IS2C_GetPlayer} message S2C_GetPlayer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetPlayer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_GetPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_GetPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_GetPlayer} S2C_GetPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_GetPlayer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.player = $root.PlayerMsg.decode(reader, reader.uint32());
                break;
            case 2:
                message.serverTime = reader.int64();
                break;
            case 3:
                if (!(message.item && message.item.length))
                    message.item = [];
                message.item.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.danYao && message.danYao.length))
                    message.danYao = [];
                message.danYao.push($root.DanYaoInfoPB.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.exchange && message.exchange.length))
                    message.exchange = [];
                message.exchange.push($root.ExchangeMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_GetPlayer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_GetPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_GetPlayer} S2C_GetPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetPlayer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_GetPlayer message.
     * @function verify
     * @memberof S2C_GetPlayer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_GetPlayer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.player != null && message.hasOwnProperty("player")) {
            var error = $root.PlayerMsg.verify(message.player);
            if (error)
                return "player." + error;
        }
        if (message.serverTime != null && message.hasOwnProperty("serverTime"))
            if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                return "serverTime: integer|Long expected";
        if (message.item != null && message.hasOwnProperty("item")) {
            if (!Array.isArray(message.item))
                return "item: array expected";
            for (var i = 0; i < message.item.length; ++i) {
                var error = $root.ItemMsg.verify(message.item[i]);
                if (error)
                    return "item." + error;
            }
        }
        if (message.danYao != null && message.hasOwnProperty("danYao")) {
            if (!Array.isArray(message.danYao))
                return "danYao: array expected";
            for (var i = 0; i < message.danYao.length; ++i) {
                var error = $root.DanYaoInfoPB.verify(message.danYao[i]);
                if (error)
                    return "danYao." + error;
            }
        }
        if (message.exchange != null && message.hasOwnProperty("exchange")) {
            if (!Array.isArray(message.exchange))
                return "exchange: array expected";
            for (var i = 0; i < message.exchange.length; ++i) {
                var error = $root.ExchangeMsg.verify(message.exchange[i]);
                if (error)
                    return "exchange." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_GetPlayer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_GetPlayer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_GetPlayer} S2C_GetPlayer
     */
    S2C_GetPlayer.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_GetPlayer)
            return object;
        var message = new $root.S2C_GetPlayer();
        if (object.player != null) {
            if (typeof object.player !== "object")
                throw TypeError(".S2C_GetPlayer.player: object expected");
            message.player = $root.PlayerMsg.fromObject(object.player);
        }
        if (object.serverTime != null)
            if ($util.Long)
                (message.serverTime = $util.Long.fromValue(object.serverTime)).unsigned = false;
            else if (typeof object.serverTime === "string")
                message.serverTime = parseInt(object.serverTime, 10);
            else if (typeof object.serverTime === "number")
                message.serverTime = object.serverTime;
            else if (typeof object.serverTime === "object")
                message.serverTime = new $util.LongBits(object.serverTime.low >>> 0, object.serverTime.high >>> 0).toNumber();
        if (object.item) {
            if (!Array.isArray(object.item))
                throw TypeError(".S2C_GetPlayer.item: array expected");
            message.item = [];
            for (var i = 0; i < object.item.length; ++i) {
                if (typeof object.item[i] !== "object")
                    throw TypeError(".S2C_GetPlayer.item: object expected");
                message.item[i] = $root.ItemMsg.fromObject(object.item[i]);
            }
        }
        if (object.danYao) {
            if (!Array.isArray(object.danYao))
                throw TypeError(".S2C_GetPlayer.danYao: array expected");
            message.danYao = [];
            for (var i = 0; i < object.danYao.length; ++i) {
                if (typeof object.danYao[i] !== "object")
                    throw TypeError(".S2C_GetPlayer.danYao: object expected");
                message.danYao[i] = $root.DanYaoInfoPB.fromObject(object.danYao[i]);
            }
        }
        if (object.exchange) {
            if (!Array.isArray(object.exchange))
                throw TypeError(".S2C_GetPlayer.exchange: array expected");
            message.exchange = [];
            for (var i = 0; i < object.exchange.length; ++i) {
                if (typeof object.exchange[i] !== "object")
                    throw TypeError(".S2C_GetPlayer.exchange: object expected");
                message.exchange[i] = $root.ExchangeMsg.fromObject(object.exchange[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_GetPlayer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_GetPlayer
     * @static
     * @param {S2C_GetPlayer} message S2C_GetPlayer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_GetPlayer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.item = [];
            object.danYao = [];
            object.exchange = [];
        }
        if (options.defaults) {
            object.player = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.serverTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.serverTime = options.longs === String ? "0" : 0;
        }
        if (message.player != null && message.hasOwnProperty("player"))
            object.player = $root.PlayerMsg.toObject(message.player, options);
        if (message.serverTime != null && message.hasOwnProperty("serverTime"))
            if (typeof message.serverTime === "number")
                object.serverTime = options.longs === String ? String(message.serverTime) : message.serverTime;
            else
                object.serverTime = options.longs === String ? $util.Long.prototype.toString.call(message.serverTime) : options.longs === Number ? new $util.LongBits(message.serverTime.low >>> 0, message.serverTime.high >>> 0).toNumber() : message.serverTime;
        if (message.item && message.item.length) {
            object.item = [];
            for (var j = 0; j < message.item.length; ++j)
                object.item[j] = $root.ItemMsg.toObject(message.item[j], options);
        }
        if (message.danYao && message.danYao.length) {
            object.danYao = [];
            for (var j = 0; j < message.danYao.length; ++j)
                object.danYao[j] = $root.DanYaoInfoPB.toObject(message.danYao[j], options);
        }
        if (message.exchange && message.exchange.length) {
            object.exchange = [];
            for (var j = 0; j < message.exchange.length; ++j)
                object.exchange[j] = $root.ExchangeMsg.toObject(message.exchange[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_GetPlayer to JSON.
     * @function toJSON
     * @memberof S2C_GetPlayer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_GetPlayer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_GetPlayer;
})();

$root.S2C_ItemChange = (function() {

    /**
     * Properties of a S2C_ItemChange.
     * @exports IS2C_ItemChange
     * @interface IS2C_ItemChange
     * @property {Array.<IItemMsg>|null} [item] S2C_ItemChange item
     * @property {Array.<IItemMsg>|null} [currency] S2C_ItemChange currency
     */

    /**
     * Constructs a new S2C_ItemChange.
     * @exports S2C_ItemChange
     * @classdesc Represents a S2C_ItemChange.
     * @implements IS2C_ItemChange
     * @constructor
     * @param {IS2C_ItemChange=} [properties] Properties to set
     */
    function S2C_ItemChange(properties) {
        this.item = [];
        this.currency = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ItemChange item.
     * @member {Array.<IItemMsg>} item
     * @memberof S2C_ItemChange
     * @instance
     */
    S2C_ItemChange.prototype.item = $util.emptyArray;

    /**
     * S2C_ItemChange currency.
     * @member {Array.<IItemMsg>} currency
     * @memberof S2C_ItemChange
     * @instance
     */
    S2C_ItemChange.prototype.currency = $util.emptyArray;

    /**
     * Creates a new S2C_ItemChange instance using the specified properties.
     * @function create
     * @memberof S2C_ItemChange
     * @static
     * @param {IS2C_ItemChange=} [properties] Properties to set
     * @returns {S2C_ItemChange} S2C_ItemChange instance
     */
    S2C_ItemChange.create = function create(properties) {
        return new S2C_ItemChange(properties);
    };

    /**
     * Encodes the specified S2C_ItemChange message. Does not implicitly {@link S2C_ItemChange.verify|verify} messages.
     * @function encode
     * @memberof S2C_ItemChange
     * @static
     * @param {IS2C_ItemChange} message S2C_ItemChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ItemChange.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.item != null && message.item.length)
            for (var i = 0; i < message.item.length; ++i)
                $root.ItemMsg.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.currency != null && message.currency.length)
            for (var i = 0; i < message.currency.length; ++i)
                $root.ItemMsg.encode(message.currency[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_ItemChange message, length delimited. Does not implicitly {@link S2C_ItemChange.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ItemChange
     * @static
     * @param {IS2C_ItemChange} message S2C_ItemChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ItemChange.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ItemChange message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ItemChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ItemChange} S2C_ItemChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ItemChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ItemChange();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.item && message.item.length))
                    message.item = [];
                message.item.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.currency && message.currency.length))
                    message.currency = [];
                message.currency.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ItemChange message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ItemChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ItemChange} S2C_ItemChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ItemChange.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ItemChange message.
     * @function verify
     * @memberof S2C_ItemChange
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ItemChange.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.item != null && message.hasOwnProperty("item")) {
            if (!Array.isArray(message.item))
                return "item: array expected";
            for (var i = 0; i < message.item.length; ++i) {
                var error = $root.ItemMsg.verify(message.item[i]);
                if (error)
                    return "item." + error;
            }
        }
        if (message.currency != null && message.hasOwnProperty("currency")) {
            if (!Array.isArray(message.currency))
                return "currency: array expected";
            for (var i = 0; i < message.currency.length; ++i) {
                var error = $root.ItemMsg.verify(message.currency[i]);
                if (error)
                    return "currency." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_ItemChange message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ItemChange
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ItemChange} S2C_ItemChange
     */
    S2C_ItemChange.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ItemChange)
            return object;
        var message = new $root.S2C_ItemChange();
        if (object.item) {
            if (!Array.isArray(object.item))
                throw TypeError(".S2C_ItemChange.item: array expected");
            message.item = [];
            for (var i = 0; i < object.item.length; ++i) {
                if (typeof object.item[i] !== "object")
                    throw TypeError(".S2C_ItemChange.item: object expected");
                message.item[i] = $root.ItemMsg.fromObject(object.item[i]);
            }
        }
        if (object.currency) {
            if (!Array.isArray(object.currency))
                throw TypeError(".S2C_ItemChange.currency: array expected");
            message.currency = [];
            for (var i = 0; i < object.currency.length; ++i) {
                if (typeof object.currency[i] !== "object")
                    throw TypeError(".S2C_ItemChange.currency: object expected");
                message.currency[i] = $root.ItemMsg.fromObject(object.currency[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_ItemChange message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ItemChange
     * @static
     * @param {S2C_ItemChange} message S2C_ItemChange
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ItemChange.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.item = [];
            object.currency = [];
        }
        if (message.item && message.item.length) {
            object.item = [];
            for (var j = 0; j < message.item.length; ++j)
                object.item[j] = $root.ItemMsg.toObject(message.item[j], options);
        }
        if (message.currency && message.currency.length) {
            object.currency = [];
            for (var j = 0; j < message.currency.length; ++j)
                object.currency[j] = $root.ItemMsg.toObject(message.currency[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_ItemChange to JSON.
     * @function toJSON
     * @memberof S2C_ItemChange
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ItemChange.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ItemChange;
})();

$root.C2S_GetAllItem = (function() {

    /**
     * Properties of a C2S_GetAllItem.
     * @exports IC2S_GetAllItem
     * @interface IC2S_GetAllItem
     */

    /**
     * Constructs a new C2S_GetAllItem.
     * @exports C2S_GetAllItem
     * @classdesc Represents a C2S_GetAllItem.
     * @implements IC2S_GetAllItem
     * @constructor
     * @param {IC2S_GetAllItem=} [properties] Properties to set
     */
    function C2S_GetAllItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_GetAllItem instance using the specified properties.
     * @function create
     * @memberof C2S_GetAllItem
     * @static
     * @param {IC2S_GetAllItem=} [properties] Properties to set
     * @returns {C2S_GetAllItem} C2S_GetAllItem instance
     */
    C2S_GetAllItem.create = function create(properties) {
        return new C2S_GetAllItem(properties);
    };

    /**
     * Encodes the specified C2S_GetAllItem message. Does not implicitly {@link C2S_GetAllItem.verify|verify} messages.
     * @function encode
     * @memberof C2S_GetAllItem
     * @static
     * @param {IC2S_GetAllItem} message C2S_GetAllItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetAllItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_GetAllItem message, length delimited. Does not implicitly {@link C2S_GetAllItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_GetAllItem
     * @static
     * @param {IC2S_GetAllItem} message C2S_GetAllItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetAllItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_GetAllItem message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_GetAllItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_GetAllItem} C2S_GetAllItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetAllItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_GetAllItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_GetAllItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_GetAllItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_GetAllItem} C2S_GetAllItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetAllItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_GetAllItem message.
     * @function verify
     * @memberof C2S_GetAllItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_GetAllItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_GetAllItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_GetAllItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_GetAllItem} C2S_GetAllItem
     */
    C2S_GetAllItem.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_GetAllItem)
            return object;
        return new $root.C2S_GetAllItem();
    };

    /**
     * Creates a plain object from a C2S_GetAllItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_GetAllItem
     * @static
     * @param {C2S_GetAllItem} message C2S_GetAllItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_GetAllItem.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_GetAllItem to JSON.
     * @function toJSON
     * @memberof C2S_GetAllItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_GetAllItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_GetAllItem;
})();

$root.S2C_GetAllItem = (function() {

    /**
     * Properties of a S2C_GetAllItem.
     * @exports IS2C_GetAllItem
     * @interface IS2C_GetAllItem
     * @property {Array.<IItemMsg>|null} [item] S2C_GetAllItem item
     * @property {Array.<IItemMsg>|null} [currency] S2C_GetAllItem currency
     */

    /**
     * Constructs a new S2C_GetAllItem.
     * @exports S2C_GetAllItem
     * @classdesc Represents a S2C_GetAllItem.
     * @implements IS2C_GetAllItem
     * @constructor
     * @param {IS2C_GetAllItem=} [properties] Properties to set
     */
    function S2C_GetAllItem(properties) {
        this.item = [];
        this.currency = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_GetAllItem item.
     * @member {Array.<IItemMsg>} item
     * @memberof S2C_GetAllItem
     * @instance
     */
    S2C_GetAllItem.prototype.item = $util.emptyArray;

    /**
     * S2C_GetAllItem currency.
     * @member {Array.<IItemMsg>} currency
     * @memberof S2C_GetAllItem
     * @instance
     */
    S2C_GetAllItem.prototype.currency = $util.emptyArray;

    /**
     * Creates a new S2C_GetAllItem instance using the specified properties.
     * @function create
     * @memberof S2C_GetAllItem
     * @static
     * @param {IS2C_GetAllItem=} [properties] Properties to set
     * @returns {S2C_GetAllItem} S2C_GetAllItem instance
     */
    S2C_GetAllItem.create = function create(properties) {
        return new S2C_GetAllItem(properties);
    };

    /**
     * Encodes the specified S2C_GetAllItem message. Does not implicitly {@link S2C_GetAllItem.verify|verify} messages.
     * @function encode
     * @memberof S2C_GetAllItem
     * @static
     * @param {IS2C_GetAllItem} message S2C_GetAllItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetAllItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.item != null && message.item.length)
            for (var i = 0; i < message.item.length; ++i)
                $root.ItemMsg.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.currency != null && message.currency.length)
            for (var i = 0; i < message.currency.length; ++i)
                $root.ItemMsg.encode(message.currency[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_GetAllItem message, length delimited. Does not implicitly {@link S2C_GetAllItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_GetAllItem
     * @static
     * @param {IS2C_GetAllItem} message S2C_GetAllItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetAllItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_GetAllItem message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_GetAllItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_GetAllItem} S2C_GetAllItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetAllItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_GetAllItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.item && message.item.length))
                    message.item = [];
                message.item.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.currency && message.currency.length))
                    message.currency = [];
                message.currency.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_GetAllItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_GetAllItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_GetAllItem} S2C_GetAllItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetAllItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_GetAllItem message.
     * @function verify
     * @memberof S2C_GetAllItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_GetAllItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.item != null && message.hasOwnProperty("item")) {
            if (!Array.isArray(message.item))
                return "item: array expected";
            for (var i = 0; i < message.item.length; ++i) {
                var error = $root.ItemMsg.verify(message.item[i]);
                if (error)
                    return "item." + error;
            }
        }
        if (message.currency != null && message.hasOwnProperty("currency")) {
            if (!Array.isArray(message.currency))
                return "currency: array expected";
            for (var i = 0; i < message.currency.length; ++i) {
                var error = $root.ItemMsg.verify(message.currency[i]);
                if (error)
                    return "currency." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_GetAllItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_GetAllItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_GetAllItem} S2C_GetAllItem
     */
    S2C_GetAllItem.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_GetAllItem)
            return object;
        var message = new $root.S2C_GetAllItem();
        if (object.item) {
            if (!Array.isArray(object.item))
                throw TypeError(".S2C_GetAllItem.item: array expected");
            message.item = [];
            for (var i = 0; i < object.item.length; ++i) {
                if (typeof object.item[i] !== "object")
                    throw TypeError(".S2C_GetAllItem.item: object expected");
                message.item[i] = $root.ItemMsg.fromObject(object.item[i]);
            }
        }
        if (object.currency) {
            if (!Array.isArray(object.currency))
                throw TypeError(".S2C_GetAllItem.currency: array expected");
            message.currency = [];
            for (var i = 0; i < object.currency.length; ++i) {
                if (typeof object.currency[i] !== "object")
                    throw TypeError(".S2C_GetAllItem.currency: object expected");
                message.currency[i] = $root.ItemMsg.fromObject(object.currency[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_GetAllItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_GetAllItem
     * @static
     * @param {S2C_GetAllItem} message S2C_GetAllItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_GetAllItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.item = [];
            object.currency = [];
        }
        if (message.item && message.item.length) {
            object.item = [];
            for (var j = 0; j < message.item.length; ++j)
                object.item[j] = $root.ItemMsg.toObject(message.item[j], options);
        }
        if (message.currency && message.currency.length) {
            object.currency = [];
            for (var j = 0; j < message.currency.length; ++j)
                object.currency[j] = $root.ItemMsg.toObject(message.currency[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_GetAllItem to JSON.
     * @function toJSON
     * @memberof S2C_GetAllItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_GetAllItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_GetAllItem;
})();

$root.C2S_UseItem = (function() {

    /**
     * Properties of a C2S_UseItem.
     * @exports IC2S_UseItem
     * @interface IC2S_UseItem
     * @property {number|null} [itemId] C2S_UseItem itemId
     * @property {number|null} [count] C2S_UseItem count
     */

    /**
     * Constructs a new C2S_UseItem.
     * @exports C2S_UseItem
     * @classdesc Represents a C2S_UseItem.
     * @implements IC2S_UseItem
     * @constructor
     * @param {IC2S_UseItem=} [properties] Properties to set
     */
    function C2S_UseItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_UseItem itemId.
     * @member {number} itemId
     * @memberof C2S_UseItem
     * @instance
     */
    C2S_UseItem.prototype.itemId = 0;

    /**
     * C2S_UseItem count.
     * @member {number} count
     * @memberof C2S_UseItem
     * @instance
     */
    C2S_UseItem.prototype.count = 0;

    /**
     * Creates a new C2S_UseItem instance using the specified properties.
     * @function create
     * @memberof C2S_UseItem
     * @static
     * @param {IC2S_UseItem=} [properties] Properties to set
     * @returns {C2S_UseItem} C2S_UseItem instance
     */
    C2S_UseItem.create = function create(properties) {
        return new C2S_UseItem(properties);
    };

    /**
     * Encodes the specified C2S_UseItem message. Does not implicitly {@link C2S_UseItem.verify|verify} messages.
     * @function encode
     * @memberof C2S_UseItem
     * @static
     * @param {IC2S_UseItem} message C2S_UseItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UseItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified C2S_UseItem message, length delimited. Does not implicitly {@link C2S_UseItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_UseItem
     * @static
     * @param {IC2S_UseItem} message C2S_UseItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UseItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_UseItem message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_UseItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_UseItem} C2S_UseItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UseItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_UseItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.itemId = reader.int32();
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_UseItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_UseItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_UseItem} C2S_UseItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UseItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_UseItem message.
     * @function verify
     * @memberof C2S_UseItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_UseItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            if (!$util.isInteger(message.itemId))
                return "itemId: integer expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a C2S_UseItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_UseItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_UseItem} C2S_UseItem
     */
    C2S_UseItem.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_UseItem)
            return object;
        var message = new $root.C2S_UseItem();
        if (object.itemId != null)
            message.itemId = object.itemId | 0;
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_UseItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_UseItem
     * @static
     * @param {C2S_UseItem} message C2S_UseItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_UseItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.itemId = 0;
            object.count = 0;
        }
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            object.itemId = message.itemId;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this C2S_UseItem to JSON.
     * @function toJSON
     * @memberof C2S_UseItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_UseItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_UseItem;
})();

$root.S2C_UseItem = (function() {

    /**
     * Properties of a S2C_UseItem.
     * @exports IS2C_UseItem
     * @interface IS2C_UseItem
     * @property {number|null} [itemId] S2C_UseItem itemId
     * @property {number|null} [count] S2C_UseItem count
     */

    /**
     * Constructs a new S2C_UseItem.
     * @exports S2C_UseItem
     * @classdesc Represents a S2C_UseItem.
     * @implements IS2C_UseItem
     * @constructor
     * @param {IS2C_UseItem=} [properties] Properties to set
     */
    function S2C_UseItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_UseItem itemId.
     * @member {number} itemId
     * @memberof S2C_UseItem
     * @instance
     */
    S2C_UseItem.prototype.itemId = 0;

    /**
     * S2C_UseItem count.
     * @member {number} count
     * @memberof S2C_UseItem
     * @instance
     */
    S2C_UseItem.prototype.count = 0;

    /**
     * Creates a new S2C_UseItem instance using the specified properties.
     * @function create
     * @memberof S2C_UseItem
     * @static
     * @param {IS2C_UseItem=} [properties] Properties to set
     * @returns {S2C_UseItem} S2C_UseItem instance
     */
    S2C_UseItem.create = function create(properties) {
        return new S2C_UseItem(properties);
    };

    /**
     * Encodes the specified S2C_UseItem message. Does not implicitly {@link S2C_UseItem.verify|verify} messages.
     * @function encode
     * @memberof S2C_UseItem
     * @static
     * @param {IS2C_UseItem} message S2C_UseItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UseItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified S2C_UseItem message, length delimited. Does not implicitly {@link S2C_UseItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_UseItem
     * @static
     * @param {IS2C_UseItem} message S2C_UseItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UseItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_UseItem message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_UseItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_UseItem} S2C_UseItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UseItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_UseItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.itemId = reader.int32();
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_UseItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_UseItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_UseItem} S2C_UseItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UseItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_UseItem message.
     * @function verify
     * @memberof S2C_UseItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_UseItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            if (!$util.isInteger(message.itemId))
                return "itemId: integer expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a S2C_UseItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_UseItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_UseItem} S2C_UseItem
     */
    S2C_UseItem.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_UseItem)
            return object;
        var message = new $root.S2C_UseItem();
        if (object.itemId != null)
            message.itemId = object.itemId | 0;
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_UseItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_UseItem
     * @static
     * @param {S2C_UseItem} message S2C_UseItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_UseItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.itemId = 0;
            object.count = 0;
        }
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            object.itemId = message.itemId;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this S2C_UseItem to JSON.
     * @function toJSON
     * @memberof S2C_UseItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_UseItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_UseItem;
})();

$root.C2S_ExchangeItem = (function() {

    /**
     * Properties of a C2S_ExchangeItem.
     * @exports IC2S_ExchangeItem
     * @interface IC2S_ExchangeItem
     * @property {number|null} [id] C2S_ExchangeItem id
     */

    /**
     * Constructs a new C2S_ExchangeItem.
     * @exports C2S_ExchangeItem
     * @classdesc Represents a C2S_ExchangeItem.
     * @implements IC2S_ExchangeItem
     * @constructor
     * @param {IC2S_ExchangeItem=} [properties] Properties to set
     */
    function C2S_ExchangeItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_ExchangeItem id.
     * @member {number} id
     * @memberof C2S_ExchangeItem
     * @instance
     */
    C2S_ExchangeItem.prototype.id = 0;

    /**
     * Creates a new C2S_ExchangeItem instance using the specified properties.
     * @function create
     * @memberof C2S_ExchangeItem
     * @static
     * @param {IC2S_ExchangeItem=} [properties] Properties to set
     * @returns {C2S_ExchangeItem} C2S_ExchangeItem instance
     */
    C2S_ExchangeItem.create = function create(properties) {
        return new C2S_ExchangeItem(properties);
    };

    /**
     * Encodes the specified C2S_ExchangeItem message. Does not implicitly {@link C2S_ExchangeItem.verify|verify} messages.
     * @function encode
     * @memberof C2S_ExchangeItem
     * @static
     * @param {IC2S_ExchangeItem} message C2S_ExchangeItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ExchangeItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified C2S_ExchangeItem message, length delimited. Does not implicitly {@link C2S_ExchangeItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_ExchangeItem
     * @static
     * @param {IC2S_ExchangeItem} message C2S_ExchangeItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ExchangeItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_ExchangeItem message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_ExchangeItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_ExchangeItem} C2S_ExchangeItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ExchangeItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_ExchangeItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_ExchangeItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_ExchangeItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_ExchangeItem} C2S_ExchangeItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ExchangeItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_ExchangeItem message.
     * @function verify
     * @memberof C2S_ExchangeItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_ExchangeItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a C2S_ExchangeItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_ExchangeItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_ExchangeItem} C2S_ExchangeItem
     */
    C2S_ExchangeItem.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_ExchangeItem)
            return object;
        var message = new $root.C2S_ExchangeItem();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_ExchangeItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_ExchangeItem
     * @static
     * @param {C2S_ExchangeItem} message C2S_ExchangeItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_ExchangeItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this C2S_ExchangeItem to JSON.
     * @function toJSON
     * @memberof C2S_ExchangeItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_ExchangeItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_ExchangeItem;
})();

$root.S2C_ExchangeItem = (function() {

    /**
     * Properties of a S2C_ExchangeItem.
     * @exports IS2C_ExchangeItem
     * @interface IS2C_ExchangeItem
     * @property {number|null} [id] S2C_ExchangeItem id
     */

    /**
     * Constructs a new S2C_ExchangeItem.
     * @exports S2C_ExchangeItem
     * @classdesc Represents a S2C_ExchangeItem.
     * @implements IS2C_ExchangeItem
     * @constructor
     * @param {IS2C_ExchangeItem=} [properties] Properties to set
     */
    function S2C_ExchangeItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ExchangeItem id.
     * @member {number} id
     * @memberof S2C_ExchangeItem
     * @instance
     */
    S2C_ExchangeItem.prototype.id = 0;

    /**
     * Creates a new S2C_ExchangeItem instance using the specified properties.
     * @function create
     * @memberof S2C_ExchangeItem
     * @static
     * @param {IS2C_ExchangeItem=} [properties] Properties to set
     * @returns {S2C_ExchangeItem} S2C_ExchangeItem instance
     */
    S2C_ExchangeItem.create = function create(properties) {
        return new S2C_ExchangeItem(properties);
    };

    /**
     * Encodes the specified S2C_ExchangeItem message. Does not implicitly {@link S2C_ExchangeItem.verify|verify} messages.
     * @function encode
     * @memberof S2C_ExchangeItem
     * @static
     * @param {IS2C_ExchangeItem} message S2C_ExchangeItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ExchangeItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
        return writer;
    };

    /**
     * Encodes the specified S2C_ExchangeItem message, length delimited. Does not implicitly {@link S2C_ExchangeItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ExchangeItem
     * @static
     * @param {IS2C_ExchangeItem} message S2C_ExchangeItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ExchangeItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ExchangeItem message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ExchangeItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ExchangeItem} S2C_ExchangeItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ExchangeItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ExchangeItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ExchangeItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ExchangeItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ExchangeItem} S2C_ExchangeItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ExchangeItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ExchangeItem message.
     * @function verify
     * @memberof S2C_ExchangeItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ExchangeItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a S2C_ExchangeItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ExchangeItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ExchangeItem} S2C_ExchangeItem
     */
    S2C_ExchangeItem.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ExchangeItem)
            return object;
        var message = new $root.S2C_ExchangeItem();
        if (object.id != null)
            message.id = object.id | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_ExchangeItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ExchangeItem
     * @static
     * @param {S2C_ExchangeItem} message S2C_ExchangeItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ExchangeItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this S2C_ExchangeItem to JSON.
     * @function toJSON
     * @memberof S2C_ExchangeItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ExchangeItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ExchangeItem;
})();

$root.C2S_SellItem = (function() {

    /**
     * Properties of a C2S_SellItem.
     * @exports IC2S_SellItem
     * @interface IC2S_SellItem
     * @property {number|null} [itemId] C2S_SellItem itemId
     * @property {number|Long|null} [id] C2S_SellItem id
     * @property {number|null} [count] C2S_SellItem count
     */

    /**
     * Constructs a new C2S_SellItem.
     * @exports C2S_SellItem
     * @classdesc Represents a C2S_SellItem.
     * @implements IC2S_SellItem
     * @constructor
     * @param {IC2S_SellItem=} [properties] Properties to set
     */
    function C2S_SellItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_SellItem itemId.
     * @member {number} itemId
     * @memberof C2S_SellItem
     * @instance
     */
    C2S_SellItem.prototype.itemId = 0;

    /**
     * C2S_SellItem id.
     * @member {number|Long} id
     * @memberof C2S_SellItem
     * @instance
     */
    C2S_SellItem.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * C2S_SellItem count.
     * @member {number} count
     * @memberof C2S_SellItem
     * @instance
     */
    C2S_SellItem.prototype.count = 0;

    /**
     * Creates a new C2S_SellItem instance using the specified properties.
     * @function create
     * @memberof C2S_SellItem
     * @static
     * @param {IC2S_SellItem=} [properties] Properties to set
     * @returns {C2S_SellItem} C2S_SellItem instance
     */
    C2S_SellItem.create = function create(properties) {
        return new C2S_SellItem(properties);
    };

    /**
     * Encodes the specified C2S_SellItem message. Does not implicitly {@link C2S_SellItem.verify|verify} messages.
     * @function encode
     * @memberof C2S_SellItem
     * @static
     * @param {IC2S_SellItem} message C2S_SellItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_SellItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
        if (message.count != null && message.hasOwnProperty("count"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified C2S_SellItem message, length delimited. Does not implicitly {@link C2S_SellItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_SellItem
     * @static
     * @param {IC2S_SellItem} message C2S_SellItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_SellItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_SellItem message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_SellItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_SellItem} C2S_SellItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_SellItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_SellItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.itemId = reader.int32();
                break;
            case 2:
                message.id = reader.int64();
                break;
            case 3:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_SellItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_SellItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_SellItem} C2S_SellItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_SellItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_SellItem message.
     * @function verify
     * @memberof C2S_SellItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_SellItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            if (!$util.isInteger(message.itemId))
                return "itemId: integer expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a C2S_SellItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_SellItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_SellItem} C2S_SellItem
     */
    C2S_SellItem.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_SellItem)
            return object;
        var message = new $root.C2S_SellItem();
        if (object.itemId != null)
            message.itemId = object.itemId | 0;
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_SellItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_SellItem
     * @static
     * @param {C2S_SellItem} message C2S_SellItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_SellItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.itemId = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.count = 0;
        }
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            object.itemId = message.itemId;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this C2S_SellItem to JSON.
     * @function toJSON
     * @memberof C2S_SellItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_SellItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_SellItem;
})();

$root.S2C_SellItem = (function() {

    /**
     * Properties of a S2C_SellItem.
     * @exports IS2C_SellItem
     * @interface IS2C_SellItem
     */

    /**
     * Constructs a new S2C_SellItem.
     * @exports S2C_SellItem
     * @classdesc Represents a S2C_SellItem.
     * @implements IS2C_SellItem
     * @constructor
     * @param {IS2C_SellItem=} [properties] Properties to set
     */
    function S2C_SellItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_SellItem instance using the specified properties.
     * @function create
     * @memberof S2C_SellItem
     * @static
     * @param {IS2C_SellItem=} [properties] Properties to set
     * @returns {S2C_SellItem} S2C_SellItem instance
     */
    S2C_SellItem.create = function create(properties) {
        return new S2C_SellItem(properties);
    };

    /**
     * Encodes the specified S2C_SellItem message. Does not implicitly {@link S2C_SellItem.verify|verify} messages.
     * @function encode
     * @memberof S2C_SellItem
     * @static
     * @param {IS2C_SellItem} message S2C_SellItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_SellItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_SellItem message, length delimited. Does not implicitly {@link S2C_SellItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_SellItem
     * @static
     * @param {IS2C_SellItem} message S2C_SellItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_SellItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_SellItem message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_SellItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_SellItem} S2C_SellItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_SellItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_SellItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_SellItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_SellItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_SellItem} S2C_SellItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_SellItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_SellItem message.
     * @function verify
     * @memberof S2C_SellItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_SellItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_SellItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_SellItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_SellItem} S2C_SellItem
     */
    S2C_SellItem.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_SellItem)
            return object;
        return new $root.S2C_SellItem();
    };

    /**
     * Creates a plain object from a S2C_SellItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_SellItem
     * @static
     * @param {S2C_SellItem} message S2C_SellItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_SellItem.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_SellItem to JSON.
     * @function toJSON
     * @memberof S2C_SellItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_SellItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_SellItem;
})();

$root.S2C_CurrencyChange = (function() {

    /**
     * Properties of a S2C_CurrencyChange.
     * @exports IS2C_CurrencyChange
     * @interface IS2C_CurrencyChange
     * @property {Array.<IItemMsg>|null} [currency] S2C_CurrencyChange currency
     */

    /**
     * Constructs a new S2C_CurrencyChange.
     * @exports S2C_CurrencyChange
     * @classdesc Represents a S2C_CurrencyChange.
     * @implements IS2C_CurrencyChange
     * @constructor
     * @param {IS2C_CurrencyChange=} [properties] Properties to set
     */
    function S2C_CurrencyChange(properties) {
        this.currency = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_CurrencyChange currency.
     * @member {Array.<IItemMsg>} currency
     * @memberof S2C_CurrencyChange
     * @instance
     */
    S2C_CurrencyChange.prototype.currency = $util.emptyArray;

    /**
     * Creates a new S2C_CurrencyChange instance using the specified properties.
     * @function create
     * @memberof S2C_CurrencyChange
     * @static
     * @param {IS2C_CurrencyChange=} [properties] Properties to set
     * @returns {S2C_CurrencyChange} S2C_CurrencyChange instance
     */
    S2C_CurrencyChange.create = function create(properties) {
        return new S2C_CurrencyChange(properties);
    };

    /**
     * Encodes the specified S2C_CurrencyChange message. Does not implicitly {@link S2C_CurrencyChange.verify|verify} messages.
     * @function encode
     * @memberof S2C_CurrencyChange
     * @static
     * @param {IS2C_CurrencyChange} message S2C_CurrencyChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_CurrencyChange.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.currency != null && message.currency.length)
            for (var i = 0; i < message.currency.length; ++i)
                $root.ItemMsg.encode(message.currency[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_CurrencyChange message, length delimited. Does not implicitly {@link S2C_CurrencyChange.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_CurrencyChange
     * @static
     * @param {IS2C_CurrencyChange} message S2C_CurrencyChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_CurrencyChange.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_CurrencyChange message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_CurrencyChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_CurrencyChange} S2C_CurrencyChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_CurrencyChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_CurrencyChange();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.currency && message.currency.length))
                    message.currency = [];
                message.currency.push($root.ItemMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_CurrencyChange message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_CurrencyChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_CurrencyChange} S2C_CurrencyChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_CurrencyChange.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_CurrencyChange message.
     * @function verify
     * @memberof S2C_CurrencyChange
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_CurrencyChange.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.currency != null && message.hasOwnProperty("currency")) {
            if (!Array.isArray(message.currency))
                return "currency: array expected";
            for (var i = 0; i < message.currency.length; ++i) {
                var error = $root.ItemMsg.verify(message.currency[i]);
                if (error)
                    return "currency." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_CurrencyChange message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_CurrencyChange
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_CurrencyChange} S2C_CurrencyChange
     */
    S2C_CurrencyChange.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_CurrencyChange)
            return object;
        var message = new $root.S2C_CurrencyChange();
        if (object.currency) {
            if (!Array.isArray(object.currency))
                throw TypeError(".S2C_CurrencyChange.currency: array expected");
            message.currency = [];
            for (var i = 0; i < object.currency.length; ++i) {
                if (typeof object.currency[i] !== "object")
                    throw TypeError(".S2C_CurrencyChange.currency: object expected");
                message.currency[i] = $root.ItemMsg.fromObject(object.currency[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_CurrencyChange message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_CurrencyChange
     * @static
     * @param {S2C_CurrencyChange} message S2C_CurrencyChange
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_CurrencyChange.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.currency = [];
        if (message.currency && message.currency.length) {
            object.currency = [];
            for (var j = 0; j < message.currency.length; ++j)
                object.currency[j] = $root.ItemMsg.toObject(message.currency[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_CurrencyChange to JSON.
     * @function toJSON
     * @memberof S2C_CurrencyChange
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_CurrencyChange.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_CurrencyChange;
})();

/**
 * LevelUpType enum.
 * @exports LevelUpType
 * @enum {string}
 * @property {number} DU_JIE=1 DU_JIE value
 * @property {number} CUI_TI=2 CUI_TI value
 */
$root.LevelUpType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "DU_JIE"] = 1;
    values[valuesById[2] = "CUI_TI"] = 2;
    return values;
})();

$root.C2S_LevelUp = (function() {

    /**
     * Properties of a C2S_LevelUp.
     * @exports IC2S_LevelUp
     * @interface IC2S_LevelUp
     * @property {LevelUpType|null} [type] C2S_LevelUp type
     */

    /**
     * Constructs a new C2S_LevelUp.
     * @exports C2S_LevelUp
     * @classdesc Represents a C2S_LevelUp.
     * @implements IC2S_LevelUp
     * @constructor
     * @param {IC2S_LevelUp=} [properties] Properties to set
     */
    function C2S_LevelUp(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_LevelUp type.
     * @member {LevelUpType} type
     * @memberof C2S_LevelUp
     * @instance
     */
    C2S_LevelUp.prototype.type = 1;

    /**
     * Creates a new C2S_LevelUp instance using the specified properties.
     * @function create
     * @memberof C2S_LevelUp
     * @static
     * @param {IC2S_LevelUp=} [properties] Properties to set
     * @returns {C2S_LevelUp} C2S_LevelUp instance
     */
    C2S_LevelUp.create = function create(properties) {
        return new C2S_LevelUp(properties);
    };

    /**
     * Encodes the specified C2S_LevelUp message. Does not implicitly {@link C2S_LevelUp.verify|verify} messages.
     * @function encode
     * @memberof C2S_LevelUp
     * @static
     * @param {IC2S_LevelUp} message C2S_LevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_LevelUp.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified C2S_LevelUp message, length delimited. Does not implicitly {@link C2S_LevelUp.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_LevelUp
     * @static
     * @param {IC2S_LevelUp} message C2S_LevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_LevelUp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_LevelUp message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_LevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_LevelUp} C2S_LevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_LevelUp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_LevelUp();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_LevelUp message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_LevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_LevelUp} C2S_LevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_LevelUp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_LevelUp message.
     * @function verify
     * @memberof C2S_LevelUp
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_LevelUp.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a C2S_LevelUp message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_LevelUp
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_LevelUp} C2S_LevelUp
     */
    C2S_LevelUp.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_LevelUp)
            return object;
        var message = new $root.C2S_LevelUp();
        switch (object.type) {
        case "DU_JIE":
        case 1:
            message.type = 1;
            break;
        case "CUI_TI":
        case 2:
            message.type = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_LevelUp message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_LevelUp
     * @static
     * @param {C2S_LevelUp} message C2S_LevelUp
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_LevelUp.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.type = options.enums === String ? "DU_JIE" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.LevelUpType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this C2S_LevelUp to JSON.
     * @function toJSON
     * @memberof C2S_LevelUp
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_LevelUp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_LevelUp;
})();

$root.S2C_LevelUp = (function() {

    /**
     * Properties of a S2C_LevelUp.
     * @exports IS2C_LevelUp
     * @interface IS2C_LevelUp
     * @property {number|null} [level] S2C_LevelUp level
     * @property {LevelUpType|null} [type] S2C_LevelUp type
     */

    /**
     * Constructs a new S2C_LevelUp.
     * @exports S2C_LevelUp
     * @classdesc Represents a S2C_LevelUp.
     * @implements IS2C_LevelUp
     * @constructor
     * @param {IS2C_LevelUp=} [properties] Properties to set
     */
    function S2C_LevelUp(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_LevelUp level.
     * @member {number} level
     * @memberof S2C_LevelUp
     * @instance
     */
    S2C_LevelUp.prototype.level = 0;

    /**
     * S2C_LevelUp type.
     * @member {LevelUpType} type
     * @memberof S2C_LevelUp
     * @instance
     */
    S2C_LevelUp.prototype.type = 1;

    /**
     * Creates a new S2C_LevelUp instance using the specified properties.
     * @function create
     * @memberof S2C_LevelUp
     * @static
     * @param {IS2C_LevelUp=} [properties] Properties to set
     * @returns {S2C_LevelUp} S2C_LevelUp instance
     */
    S2C_LevelUp.create = function create(properties) {
        return new S2C_LevelUp(properties);
    };

    /**
     * Encodes the specified S2C_LevelUp message. Does not implicitly {@link S2C_LevelUp.verify|verify} messages.
     * @function encode
     * @memberof S2C_LevelUp
     * @static
     * @param {IS2C_LevelUp} message S2C_LevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_LevelUp.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified S2C_LevelUp message, length delimited. Does not implicitly {@link S2C_LevelUp.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_LevelUp
     * @static
     * @param {IS2C_LevelUp} message S2C_LevelUp message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_LevelUp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_LevelUp message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_LevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_LevelUp} S2C_LevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_LevelUp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_LevelUp();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.level = reader.int32();
                break;
            case 2:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_LevelUp message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_LevelUp
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_LevelUp} S2C_LevelUp
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_LevelUp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_LevelUp message.
     * @function verify
     * @memberof S2C_LevelUp
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_LevelUp.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a S2C_LevelUp message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_LevelUp
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_LevelUp} S2C_LevelUp
     */
    S2C_LevelUp.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_LevelUp)
            return object;
        var message = new $root.S2C_LevelUp();
        if (object.level != null)
            message.level = object.level | 0;
        switch (object.type) {
        case "DU_JIE":
        case 1:
            message.type = 1;
            break;
        case "CUI_TI":
        case 2:
            message.type = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_LevelUp message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_LevelUp
     * @static
     * @param {S2C_LevelUp} message S2C_LevelUp
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_LevelUp.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.level = 0;
            object.type = options.enums === String ? "DU_JIE" : 1;
        }
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.LevelUpType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this S2C_LevelUp to JSON.
     * @function toJSON
     * @memberof S2C_LevelUp
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_LevelUp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_LevelUp;
})();

$root.C2S_XiuLian = (function() {

    /**
     * Properties of a C2S_XiuLian.
     * @exports IC2S_XiuLian
     * @interface IC2S_XiuLian
     */

    /**
     * Constructs a new C2S_XiuLian.
     * @exports C2S_XiuLian
     * @classdesc Represents a C2S_XiuLian.
     * @implements IC2S_XiuLian
     * @constructor
     * @param {IC2S_XiuLian=} [properties] Properties to set
     */
    function C2S_XiuLian(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_XiuLian instance using the specified properties.
     * @function create
     * @memberof C2S_XiuLian
     * @static
     * @param {IC2S_XiuLian=} [properties] Properties to set
     * @returns {C2S_XiuLian} C2S_XiuLian instance
     */
    C2S_XiuLian.create = function create(properties) {
        return new C2S_XiuLian(properties);
    };

    /**
     * Encodes the specified C2S_XiuLian message. Does not implicitly {@link C2S_XiuLian.verify|verify} messages.
     * @function encode
     * @memberof C2S_XiuLian
     * @static
     * @param {IC2S_XiuLian} message C2S_XiuLian message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_XiuLian.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_XiuLian message, length delimited. Does not implicitly {@link C2S_XiuLian.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_XiuLian
     * @static
     * @param {IC2S_XiuLian} message C2S_XiuLian message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_XiuLian.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_XiuLian message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_XiuLian
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_XiuLian} C2S_XiuLian
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_XiuLian.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_XiuLian();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_XiuLian message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_XiuLian
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_XiuLian} C2S_XiuLian
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_XiuLian.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_XiuLian message.
     * @function verify
     * @memberof C2S_XiuLian
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_XiuLian.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_XiuLian message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_XiuLian
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_XiuLian} C2S_XiuLian
     */
    C2S_XiuLian.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_XiuLian)
            return object;
        return new $root.C2S_XiuLian();
    };

    /**
     * Creates a plain object from a C2S_XiuLian message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_XiuLian
     * @static
     * @param {C2S_XiuLian} message C2S_XiuLian
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_XiuLian.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_XiuLian to JSON.
     * @function toJSON
     * @memberof C2S_XiuLian
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_XiuLian.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_XiuLian;
})();

$root.S2C_XiuLian = (function() {

    /**
     * Properties of a S2C_XiuLian.
     * @exports IS2C_XiuLian
     * @interface IS2C_XiuLian
     * @property {number|Long|null} [endTime] S2C_XiuLian endTime
     */

    /**
     * Constructs a new S2C_XiuLian.
     * @exports S2C_XiuLian
     * @classdesc Represents a S2C_XiuLian.
     * @implements IS2C_XiuLian
     * @constructor
     * @param {IS2C_XiuLian=} [properties] Properties to set
     */
    function S2C_XiuLian(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_XiuLian endTime.
     * @member {number|Long} endTime
     * @memberof S2C_XiuLian
     * @instance
     */
    S2C_XiuLian.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new S2C_XiuLian instance using the specified properties.
     * @function create
     * @memberof S2C_XiuLian
     * @static
     * @param {IS2C_XiuLian=} [properties] Properties to set
     * @returns {S2C_XiuLian} S2C_XiuLian instance
     */
    S2C_XiuLian.create = function create(properties) {
        return new S2C_XiuLian(properties);
    };

    /**
     * Encodes the specified S2C_XiuLian message. Does not implicitly {@link S2C_XiuLian.verify|verify} messages.
     * @function encode
     * @memberof S2C_XiuLian
     * @static
     * @param {IS2C_XiuLian} message S2C_XiuLian message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_XiuLian.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.endTime);
        return writer;
    };

    /**
     * Encodes the specified S2C_XiuLian message, length delimited. Does not implicitly {@link S2C_XiuLian.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_XiuLian
     * @static
     * @param {IS2C_XiuLian} message S2C_XiuLian message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_XiuLian.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_XiuLian message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_XiuLian
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_XiuLian} S2C_XiuLian
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_XiuLian.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_XiuLian();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.endTime = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_XiuLian message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_XiuLian
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_XiuLian} S2C_XiuLian
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_XiuLian.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_XiuLian message.
     * @function verify
     * @memberof S2C_XiuLian
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_XiuLian.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                return "endTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a S2C_XiuLian message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_XiuLian
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_XiuLian} S2C_XiuLian
     */
    S2C_XiuLian.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_XiuLian)
            return object;
        var message = new $root.S2C_XiuLian();
        if (object.endTime != null)
            if ($util.Long)
                (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
            else if (typeof object.endTime === "string")
                message.endTime = parseInt(object.endTime, 10);
            else if (typeof object.endTime === "number")
                message.endTime = object.endTime;
            else if (typeof object.endTime === "object")
                message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a S2C_XiuLian message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_XiuLian
     * @static
     * @param {S2C_XiuLian} message S2C_XiuLian
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_XiuLian.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.endTime = options.longs === String ? "0" : 0;
        if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
                object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
                object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
        return object;
    };

    /**
     * Converts this S2C_XiuLian to JSON.
     * @function toJSON
     * @memberof S2C_XiuLian
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_XiuLian.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_XiuLian;
})();

$root.C2S_SellManyEquip = (function() {

    /**
     * Properties of a C2S_SellManyEquip.
     * @exports IC2S_SellManyEquip
     * @interface IC2S_SellManyEquip
     * @property {Array.<number>|null} [equipQuality] C2S_SellManyEquip equipQuality
     */

    /**
     * Constructs a new C2S_SellManyEquip.
     * @exports C2S_SellManyEquip
     * @classdesc Represents a C2S_SellManyEquip.
     * @implements IC2S_SellManyEquip
     * @constructor
     * @param {IC2S_SellManyEquip=} [properties] Properties to set
     */
    function C2S_SellManyEquip(properties) {
        this.equipQuality = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_SellManyEquip equipQuality.
     * @member {Array.<number>} equipQuality
     * @memberof C2S_SellManyEquip
     * @instance
     */
    C2S_SellManyEquip.prototype.equipQuality = $util.emptyArray;

    /**
     * Creates a new C2S_SellManyEquip instance using the specified properties.
     * @function create
     * @memberof C2S_SellManyEquip
     * @static
     * @param {IC2S_SellManyEquip=} [properties] Properties to set
     * @returns {C2S_SellManyEquip} C2S_SellManyEquip instance
     */
    C2S_SellManyEquip.create = function create(properties) {
        return new C2S_SellManyEquip(properties);
    };

    /**
     * Encodes the specified C2S_SellManyEquip message. Does not implicitly {@link C2S_SellManyEquip.verify|verify} messages.
     * @function encode
     * @memberof C2S_SellManyEquip
     * @static
     * @param {IC2S_SellManyEquip} message C2S_SellManyEquip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_SellManyEquip.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.equipQuality != null && message.equipQuality.length)
            for (var i = 0; i < message.equipQuality.length; ++i)
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipQuality[i]);
        return writer;
    };

    /**
     * Encodes the specified C2S_SellManyEquip message, length delimited. Does not implicitly {@link C2S_SellManyEquip.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_SellManyEquip
     * @static
     * @param {IC2S_SellManyEquip} message C2S_SellManyEquip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_SellManyEquip.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_SellManyEquip message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_SellManyEquip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_SellManyEquip} C2S_SellManyEquip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_SellManyEquip.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_SellManyEquip();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.equipQuality && message.equipQuality.length))
                    message.equipQuality = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.equipQuality.push(reader.int32());
                } else
                    message.equipQuality.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_SellManyEquip message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_SellManyEquip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_SellManyEquip} C2S_SellManyEquip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_SellManyEquip.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_SellManyEquip message.
     * @function verify
     * @memberof C2S_SellManyEquip
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_SellManyEquip.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.equipQuality != null && message.hasOwnProperty("equipQuality")) {
            if (!Array.isArray(message.equipQuality))
                return "equipQuality: array expected";
            for (var i = 0; i < message.equipQuality.length; ++i)
                if (!$util.isInteger(message.equipQuality[i]))
                    return "equipQuality: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a C2S_SellManyEquip message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_SellManyEquip
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_SellManyEquip} C2S_SellManyEquip
     */
    C2S_SellManyEquip.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_SellManyEquip)
            return object;
        var message = new $root.C2S_SellManyEquip();
        if (object.equipQuality) {
            if (!Array.isArray(object.equipQuality))
                throw TypeError(".C2S_SellManyEquip.equipQuality: array expected");
            message.equipQuality = [];
            for (var i = 0; i < object.equipQuality.length; ++i)
                message.equipQuality[i] = object.equipQuality[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a C2S_SellManyEquip message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_SellManyEquip
     * @static
     * @param {C2S_SellManyEquip} message C2S_SellManyEquip
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_SellManyEquip.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.equipQuality = [];
        if (message.equipQuality && message.equipQuality.length) {
            object.equipQuality = [];
            for (var j = 0; j < message.equipQuality.length; ++j)
                object.equipQuality[j] = message.equipQuality[j];
        }
        return object;
    };

    /**
     * Converts this C2S_SellManyEquip to JSON.
     * @function toJSON
     * @memberof C2S_SellManyEquip
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_SellManyEquip.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_SellManyEquip;
})();

$root.S2C_SellManyEquip = (function() {

    /**
     * Properties of a S2C_SellManyEquip.
     * @exports IS2C_SellManyEquip
     * @interface IS2C_SellManyEquip
     */

    /**
     * Constructs a new S2C_SellManyEquip.
     * @exports S2C_SellManyEquip
     * @classdesc Represents a S2C_SellManyEquip.
     * @implements IS2C_SellManyEquip
     * @constructor
     * @param {IS2C_SellManyEquip=} [properties] Properties to set
     */
    function S2C_SellManyEquip(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new S2C_SellManyEquip instance using the specified properties.
     * @function create
     * @memberof S2C_SellManyEquip
     * @static
     * @param {IS2C_SellManyEquip=} [properties] Properties to set
     * @returns {S2C_SellManyEquip} S2C_SellManyEquip instance
     */
    S2C_SellManyEquip.create = function create(properties) {
        return new S2C_SellManyEquip(properties);
    };

    /**
     * Encodes the specified S2C_SellManyEquip message. Does not implicitly {@link S2C_SellManyEquip.verify|verify} messages.
     * @function encode
     * @memberof S2C_SellManyEquip
     * @static
     * @param {IS2C_SellManyEquip} message S2C_SellManyEquip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_SellManyEquip.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified S2C_SellManyEquip message, length delimited. Does not implicitly {@link S2C_SellManyEquip.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_SellManyEquip
     * @static
     * @param {IS2C_SellManyEquip} message S2C_SellManyEquip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_SellManyEquip.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_SellManyEquip message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_SellManyEquip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_SellManyEquip} S2C_SellManyEquip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_SellManyEquip.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_SellManyEquip();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_SellManyEquip message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_SellManyEquip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_SellManyEquip} S2C_SellManyEquip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_SellManyEquip.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_SellManyEquip message.
     * @function verify
     * @memberof S2C_SellManyEquip
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_SellManyEquip.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a S2C_SellManyEquip message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_SellManyEquip
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_SellManyEquip} S2C_SellManyEquip
     */
    S2C_SellManyEquip.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_SellManyEquip)
            return object;
        return new $root.S2C_SellManyEquip();
    };

    /**
     * Creates a plain object from a S2C_SellManyEquip message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_SellManyEquip
     * @static
     * @param {S2C_SellManyEquip} message S2C_SellManyEquip
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_SellManyEquip.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this S2C_SellManyEquip to JSON.
     * @function toJSON
     * @memberof S2C_SellManyEquip
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_SellManyEquip.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_SellManyEquip;
})();

$root.C2S_UpgradePkg = (function() {

    /**
     * Properties of a C2S_UpgradePkg.
     * @exports IC2S_UpgradePkg
     * @interface IC2S_UpgradePkg
     */

    /**
     * Constructs a new C2S_UpgradePkg.
     * @exports C2S_UpgradePkg
     * @classdesc Represents a C2S_UpgradePkg.
     * @implements IC2S_UpgradePkg
     * @constructor
     * @param {IC2S_UpgradePkg=} [properties] Properties to set
     */
    function C2S_UpgradePkg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_UpgradePkg instance using the specified properties.
     * @function create
     * @memberof C2S_UpgradePkg
     * @static
     * @param {IC2S_UpgradePkg=} [properties] Properties to set
     * @returns {C2S_UpgradePkg} C2S_UpgradePkg instance
     */
    C2S_UpgradePkg.create = function create(properties) {
        return new C2S_UpgradePkg(properties);
    };

    /**
     * Encodes the specified C2S_UpgradePkg message. Does not implicitly {@link C2S_UpgradePkg.verify|verify} messages.
     * @function encode
     * @memberof C2S_UpgradePkg
     * @static
     * @param {IC2S_UpgradePkg} message C2S_UpgradePkg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradePkg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_UpgradePkg message, length delimited. Does not implicitly {@link C2S_UpgradePkg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_UpgradePkg
     * @static
     * @param {IC2S_UpgradePkg} message C2S_UpgradePkg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradePkg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_UpgradePkg message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_UpgradePkg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_UpgradePkg} C2S_UpgradePkg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradePkg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_UpgradePkg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_UpgradePkg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_UpgradePkg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_UpgradePkg} C2S_UpgradePkg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradePkg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_UpgradePkg message.
     * @function verify
     * @memberof C2S_UpgradePkg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_UpgradePkg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_UpgradePkg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_UpgradePkg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_UpgradePkg} C2S_UpgradePkg
     */
    C2S_UpgradePkg.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_UpgradePkg)
            return object;
        return new $root.C2S_UpgradePkg();
    };

    /**
     * Creates a plain object from a C2S_UpgradePkg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_UpgradePkg
     * @static
     * @param {C2S_UpgradePkg} message C2S_UpgradePkg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_UpgradePkg.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_UpgradePkg to JSON.
     * @function toJSON
     * @memberof C2S_UpgradePkg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_UpgradePkg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_UpgradePkg;
})();

$root.S2C_UpgradePkg = (function() {

    /**
     * Properties of a S2C_UpgradePkg.
     * @exports IS2C_UpgradePkg
     * @interface IS2C_UpgradePkg
     * @property {number|null} [pkgNum] S2C_UpgradePkg pkgNum
     * @property {number|null} [pkgLevel] S2C_UpgradePkg pkgLevel
     * @property {number|null} [pkgUse] S2C_UpgradePkg pkgUse
     */

    /**
     * Constructs a new S2C_UpgradePkg.
     * @exports S2C_UpgradePkg
     * @classdesc Represents a S2C_UpgradePkg.
     * @implements IS2C_UpgradePkg
     * @constructor
     * @param {IS2C_UpgradePkg=} [properties] Properties to set
     */
    function S2C_UpgradePkg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_UpgradePkg pkgNum.
     * @member {number} pkgNum
     * @memberof S2C_UpgradePkg
     * @instance
     */
    S2C_UpgradePkg.prototype.pkgNum = 0;

    /**
     * S2C_UpgradePkg pkgLevel.
     * @member {number} pkgLevel
     * @memberof S2C_UpgradePkg
     * @instance
     */
    S2C_UpgradePkg.prototype.pkgLevel = 0;

    /**
     * S2C_UpgradePkg pkgUse.
     * @member {number} pkgUse
     * @memberof S2C_UpgradePkg
     * @instance
     */
    S2C_UpgradePkg.prototype.pkgUse = 0;

    /**
     * Creates a new S2C_UpgradePkg instance using the specified properties.
     * @function create
     * @memberof S2C_UpgradePkg
     * @static
     * @param {IS2C_UpgradePkg=} [properties] Properties to set
     * @returns {S2C_UpgradePkg} S2C_UpgradePkg instance
     */
    S2C_UpgradePkg.create = function create(properties) {
        return new S2C_UpgradePkg(properties);
    };

    /**
     * Encodes the specified S2C_UpgradePkg message. Does not implicitly {@link S2C_UpgradePkg.verify|verify} messages.
     * @function encode
     * @memberof S2C_UpgradePkg
     * @static
     * @param {IS2C_UpgradePkg} message S2C_UpgradePkg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradePkg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pkgNum);
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pkgLevel);
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pkgUse);
        return writer;
    };

    /**
     * Encodes the specified S2C_UpgradePkg message, length delimited. Does not implicitly {@link S2C_UpgradePkg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_UpgradePkg
     * @static
     * @param {IS2C_UpgradePkg} message S2C_UpgradePkg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradePkg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_UpgradePkg message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_UpgradePkg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_UpgradePkg} S2C_UpgradePkg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradePkg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_UpgradePkg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.pkgNum = reader.int32();
                break;
            case 2:
                message.pkgLevel = reader.int32();
                break;
            case 3:
                message.pkgUse = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_UpgradePkg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_UpgradePkg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_UpgradePkg} S2C_UpgradePkg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradePkg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_UpgradePkg message.
     * @function verify
     * @memberof S2C_UpgradePkg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_UpgradePkg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            if (!$util.isInteger(message.pkgNum))
                return "pkgNum: integer expected";
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            if (!$util.isInteger(message.pkgLevel))
                return "pkgLevel: integer expected";
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            if (!$util.isInteger(message.pkgUse))
                return "pkgUse: integer expected";
        return null;
    };

    /**
     * Creates a S2C_UpgradePkg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_UpgradePkg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_UpgradePkg} S2C_UpgradePkg
     */
    S2C_UpgradePkg.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_UpgradePkg)
            return object;
        var message = new $root.S2C_UpgradePkg();
        if (object.pkgNum != null)
            message.pkgNum = object.pkgNum | 0;
        if (object.pkgLevel != null)
            message.pkgLevel = object.pkgLevel | 0;
        if (object.pkgUse != null)
            message.pkgUse = object.pkgUse | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_UpgradePkg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_UpgradePkg
     * @static
     * @param {S2C_UpgradePkg} message S2C_UpgradePkg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_UpgradePkg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.pkgNum = 0;
            object.pkgLevel = 0;
            object.pkgUse = 0;
        }
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            object.pkgNum = message.pkgNum;
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            object.pkgLevel = message.pkgLevel;
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            object.pkgUse = message.pkgUse;
        return object;
    };

    /**
     * Converts this S2C_UpgradePkg to JSON.
     * @function toJSON
     * @memberof S2C_UpgradePkg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_UpgradePkg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_UpgradePkg;
})();

$root.PropertyMsg = (function() {

    /**
     * Properties of a PropertyMsg.
     * @exports IPropertyMsg
     * @interface IPropertyMsg
     * @property {PropertyType} type PropertyMsg type
     * @property {number|null} [value] PropertyMsg value
     */

    /**
     * Constructs a new PropertyMsg.
     * @exports PropertyMsg
     * @classdesc Represents a PropertyMsg.
     * @implements IPropertyMsg
     * @constructor
     * @param {IPropertyMsg=} [properties] Properties to set
     */
    function PropertyMsg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PropertyMsg type.
     * @member {PropertyType} type
     * @memberof PropertyMsg
     * @instance
     */
    PropertyMsg.prototype.type = 1;

    /**
     * PropertyMsg value.
     * @member {number} value
     * @memberof PropertyMsg
     * @instance
     */
    PropertyMsg.prototype.value = 0;

    /**
     * Creates a new PropertyMsg instance using the specified properties.
     * @function create
     * @memberof PropertyMsg
     * @static
     * @param {IPropertyMsg=} [properties] Properties to set
     * @returns {PropertyMsg} PropertyMsg instance
     */
    PropertyMsg.create = function create(properties) {
        return new PropertyMsg(properties);
    };

    /**
     * Encodes the specified PropertyMsg message. Does not implicitly {@link PropertyMsg.verify|verify} messages.
     * @function encode
     * @memberof PropertyMsg
     * @static
     * @param {IPropertyMsg} message PropertyMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PropertyMsg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
        return writer;
    };

    /**
     * Encodes the specified PropertyMsg message, length delimited. Does not implicitly {@link PropertyMsg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PropertyMsg
     * @static
     * @param {IPropertyMsg} message PropertyMsg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PropertyMsg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PropertyMsg message from the specified reader or buffer.
     * @function decode
     * @memberof PropertyMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PropertyMsg} PropertyMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PropertyMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropertyMsg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.value = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("type"))
            throw $util.ProtocolError("missing required 'type'", { instance: message });
        return message;
    };

    /**
     * Decodes a PropertyMsg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PropertyMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PropertyMsg} PropertyMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PropertyMsg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PropertyMsg message.
     * @function verify
     * @memberof PropertyMsg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PropertyMsg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.type) {
        default:
            return "type: enum value expected";
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 201:
        case 202:
        case 203:
        case 204:
        case 205:
        case 206:
        case 301:
        case 302:
        case 1001:
        case 1002:
        case 1003:
        case 1004:
        case 1005:
        case 1006:
        case 1007:
            break;
        }
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isInteger(message.value))
                return "value: integer expected";
        return null;
    };

    /**
     * Creates a PropertyMsg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PropertyMsg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PropertyMsg} PropertyMsg
     */
    PropertyMsg.fromObject = function fromObject(object) {
        if (object instanceof $root.PropertyMsg)
            return object;
        var message = new $root.PropertyMsg();
        switch (object.type) {
        case "TiPo":
        case 1:
            message.type = 1;
            break;
        case "ZhenQi":
        case 2:
            message.type = 2;
            break;
        case "GenGu":
        case 3:
            message.type = 3;
            break;
        case "ShenFa":
        case 4:
            message.type = 4;
            break;
        case "LingLi":
        case 5:
            message.type = 5;
            break;
        case "WuXing":
        case 6:
            message.type = 6;
            break;
        case "JiYuan":
        case 7:
            message.type = 7;
            break;
        case "JinXi":
        case 101:
            message.type = 101;
            break;
        case "MuXi":
        case 102:
            message.type = 102;
            break;
        case "ShuiXi":
        case 103:
            message.type = 103;
            break;
        case "HuoXi":
        case 104:
            message.type = 104;
            break;
        case "TuXi":
        case 105:
            message.type = 105;
            break;
        case "RenZu":
        case 201:
            message.type = 201;
            break;
        case "YaoZu":
        case 202:
            message.type = 202;
            break;
        case "MoZu":
        case 203:
            message.type = 203;
            break;
        case "ShouZu":
        case 204:
            message.type = 204;
            break;
        case "LongZu":
        case 205:
            message.type = 205;
            break;
        case "XianRen":
        case 206:
            message.type = 206;
            break;
        case "ZhengQi":
        case 301:
            message.type = 301;
            break;
        case "XieQi":
        case 302:
            message.type = 302;
            break;
        case "ShengMing":
        case 1001:
            message.type = 1001;
            break;
        case "GongJi":
        case 1002:
            message.type = 1002;
            break;
        case "FangYu":
        case 1003:
            message.type = 1003;
            break;
        case "ShanBi":
        case 1004:
            message.type = 1004;
            break;
        case "BaoJi":
        case 1005:
            message.type = 1005;
            break;
        case "XiuLianSuDu":
        case 1006:
            message.type = 1006;
            break;
        case "LingLiHuoQu":
        case 1007:
            message.type = 1007;
            break;
        }
        if (object.value != null)
            message.value = object.value | 0;
        return message;
    };

    /**
     * Creates a plain object from a PropertyMsg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PropertyMsg
     * @static
     * @param {PropertyMsg} message PropertyMsg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PropertyMsg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "TiPo" : 1;
            object.value = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.PropertyType[message.type] : message.type;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this PropertyMsg to JSON.
     * @function toJSON
     * @memberof PropertyMsg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PropertyMsg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PropertyMsg;
})();

$root.C2S_PlayerProperty = (function() {

    /**
     * Properties of a C2S_PlayerProperty.
     * @exports IC2S_PlayerProperty
     * @interface IC2S_PlayerProperty
     */

    /**
     * Constructs a new C2S_PlayerProperty.
     * @exports C2S_PlayerProperty
     * @classdesc Represents a C2S_PlayerProperty.
     * @implements IC2S_PlayerProperty
     * @constructor
     * @param {IC2S_PlayerProperty=} [properties] Properties to set
     */
    function C2S_PlayerProperty(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_PlayerProperty instance using the specified properties.
     * @function create
     * @memberof C2S_PlayerProperty
     * @static
     * @param {IC2S_PlayerProperty=} [properties] Properties to set
     * @returns {C2S_PlayerProperty} C2S_PlayerProperty instance
     */
    C2S_PlayerProperty.create = function create(properties) {
        return new C2S_PlayerProperty(properties);
    };

    /**
     * Encodes the specified C2S_PlayerProperty message. Does not implicitly {@link C2S_PlayerProperty.verify|verify} messages.
     * @function encode
     * @memberof C2S_PlayerProperty
     * @static
     * @param {IC2S_PlayerProperty} message C2S_PlayerProperty message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_PlayerProperty.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_PlayerProperty message, length delimited. Does not implicitly {@link C2S_PlayerProperty.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_PlayerProperty
     * @static
     * @param {IC2S_PlayerProperty} message C2S_PlayerProperty message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_PlayerProperty.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_PlayerProperty message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_PlayerProperty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_PlayerProperty} C2S_PlayerProperty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_PlayerProperty.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_PlayerProperty();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_PlayerProperty message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_PlayerProperty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_PlayerProperty} C2S_PlayerProperty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_PlayerProperty.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_PlayerProperty message.
     * @function verify
     * @memberof C2S_PlayerProperty
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_PlayerProperty.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_PlayerProperty message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_PlayerProperty
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_PlayerProperty} C2S_PlayerProperty
     */
    C2S_PlayerProperty.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_PlayerProperty)
            return object;
        return new $root.C2S_PlayerProperty();
    };

    /**
     * Creates a plain object from a C2S_PlayerProperty message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_PlayerProperty
     * @static
     * @param {C2S_PlayerProperty} message C2S_PlayerProperty
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_PlayerProperty.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_PlayerProperty to JSON.
     * @function toJSON
     * @memberof C2S_PlayerProperty
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_PlayerProperty.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_PlayerProperty;
})();

$root.S2C_PlayerProperty = (function() {

    /**
     * Properties of a S2C_PlayerProperty.
     * @exports IS2C_PlayerProperty
     * @interface IS2C_PlayerProperty
     * @property {Array.<IPropertyMsg>|null} [property] S2C_PlayerProperty property
     */

    /**
     * Constructs a new S2C_PlayerProperty.
     * @exports S2C_PlayerProperty
     * @classdesc Represents a S2C_PlayerProperty.
     * @implements IS2C_PlayerProperty
     * @constructor
     * @param {IS2C_PlayerProperty=} [properties] Properties to set
     */
    function S2C_PlayerProperty(properties) {
        this.property = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_PlayerProperty property.
     * @member {Array.<IPropertyMsg>} property
     * @memberof S2C_PlayerProperty
     * @instance
     */
    S2C_PlayerProperty.prototype.property = $util.emptyArray;

    /**
     * Creates a new S2C_PlayerProperty instance using the specified properties.
     * @function create
     * @memberof S2C_PlayerProperty
     * @static
     * @param {IS2C_PlayerProperty=} [properties] Properties to set
     * @returns {S2C_PlayerProperty} S2C_PlayerProperty instance
     */
    S2C_PlayerProperty.create = function create(properties) {
        return new S2C_PlayerProperty(properties);
    };

    /**
     * Encodes the specified S2C_PlayerProperty message. Does not implicitly {@link S2C_PlayerProperty.verify|verify} messages.
     * @function encode
     * @memberof S2C_PlayerProperty
     * @static
     * @param {IS2C_PlayerProperty} message S2C_PlayerProperty message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PlayerProperty.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.property != null && message.property.length)
            for (var i = 0; i < message.property.length; ++i)
                $root.PropertyMsg.encode(message.property[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_PlayerProperty message, length delimited. Does not implicitly {@link S2C_PlayerProperty.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_PlayerProperty
     * @static
     * @param {IS2C_PlayerProperty} message S2C_PlayerProperty message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PlayerProperty.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_PlayerProperty message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_PlayerProperty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_PlayerProperty} S2C_PlayerProperty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PlayerProperty.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_PlayerProperty();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.property && message.property.length))
                    message.property = [];
                message.property.push($root.PropertyMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_PlayerProperty message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_PlayerProperty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_PlayerProperty} S2C_PlayerProperty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PlayerProperty.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_PlayerProperty message.
     * @function verify
     * @memberof S2C_PlayerProperty
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_PlayerProperty.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.property != null && message.hasOwnProperty("property")) {
            if (!Array.isArray(message.property))
                return "property: array expected";
            for (var i = 0; i < message.property.length; ++i) {
                var error = $root.PropertyMsg.verify(message.property[i]);
                if (error)
                    return "property." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_PlayerProperty message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_PlayerProperty
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_PlayerProperty} S2C_PlayerProperty
     */
    S2C_PlayerProperty.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_PlayerProperty)
            return object;
        var message = new $root.S2C_PlayerProperty();
        if (object.property) {
            if (!Array.isArray(object.property))
                throw TypeError(".S2C_PlayerProperty.property: array expected");
            message.property = [];
            for (var i = 0; i < object.property.length; ++i) {
                if (typeof object.property[i] !== "object")
                    throw TypeError(".S2C_PlayerProperty.property: object expected");
                message.property[i] = $root.PropertyMsg.fromObject(object.property[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_PlayerProperty message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_PlayerProperty
     * @static
     * @param {S2C_PlayerProperty} message S2C_PlayerProperty
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_PlayerProperty.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.property = [];
        if (message.property && message.property.length) {
            object.property = [];
            for (var j = 0; j < message.property.length; ++j)
                object.property[j] = $root.PropertyMsg.toObject(message.property[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_PlayerProperty to JSON.
     * @function toJSON
     * @memberof S2C_PlayerProperty
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_PlayerProperty.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_PlayerProperty;
})();

$root.C2S_EquipmentOpt = (function() {

    /**
     * Properties of a C2S_EquipmentOpt.
     * @exports IC2S_EquipmentOpt
     * @interface IC2S_EquipmentOpt
     * @property {number|Long|null} [id] C2S_EquipmentOpt id
     * @property {boolean|null} [wear] C2S_EquipmentOpt wear
     */

    /**
     * Constructs a new C2S_EquipmentOpt.
     * @exports C2S_EquipmentOpt
     * @classdesc Represents a C2S_EquipmentOpt.
     * @implements IC2S_EquipmentOpt
     * @constructor
     * @param {IC2S_EquipmentOpt=} [properties] Properties to set
     */
    function C2S_EquipmentOpt(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_EquipmentOpt id.
     * @member {number|Long} id
     * @memberof C2S_EquipmentOpt
     * @instance
     */
    C2S_EquipmentOpt.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * C2S_EquipmentOpt wear.
     * @member {boolean} wear
     * @memberof C2S_EquipmentOpt
     * @instance
     */
    C2S_EquipmentOpt.prototype.wear = false;

    /**
     * Creates a new C2S_EquipmentOpt instance using the specified properties.
     * @function create
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {IC2S_EquipmentOpt=} [properties] Properties to set
     * @returns {C2S_EquipmentOpt} C2S_EquipmentOpt instance
     */
    C2S_EquipmentOpt.create = function create(properties) {
        return new C2S_EquipmentOpt(properties);
    };

    /**
     * Encodes the specified C2S_EquipmentOpt message. Does not implicitly {@link C2S_EquipmentOpt.verify|verify} messages.
     * @function encode
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {IC2S_EquipmentOpt} message C2S_EquipmentOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_EquipmentOpt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
        if (message.wear != null && message.hasOwnProperty("wear"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.wear);
        return writer;
    };

    /**
     * Encodes the specified C2S_EquipmentOpt message, length delimited. Does not implicitly {@link C2S_EquipmentOpt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {IC2S_EquipmentOpt} message C2S_EquipmentOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_EquipmentOpt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_EquipmentOpt message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_EquipmentOpt} C2S_EquipmentOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_EquipmentOpt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_EquipmentOpt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int64();
                break;
            case 2:
                message.wear = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_EquipmentOpt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_EquipmentOpt} C2S_EquipmentOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_EquipmentOpt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_EquipmentOpt message.
     * @function verify
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_EquipmentOpt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.wear != null && message.hasOwnProperty("wear"))
            if (typeof message.wear !== "boolean")
                return "wear: boolean expected";
        return null;
    };

    /**
     * Creates a C2S_EquipmentOpt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_EquipmentOpt} C2S_EquipmentOpt
     */
    C2S_EquipmentOpt.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_EquipmentOpt)
            return object;
        var message = new $root.C2S_EquipmentOpt();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.wear != null)
            message.wear = Boolean(object.wear);
        return message;
    };

    /**
     * Creates a plain object from a C2S_EquipmentOpt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_EquipmentOpt
     * @static
     * @param {C2S_EquipmentOpt} message C2S_EquipmentOpt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_EquipmentOpt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.wear = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.wear != null && message.hasOwnProperty("wear"))
            object.wear = message.wear;
        return object;
    };

    /**
     * Converts this C2S_EquipmentOpt to JSON.
     * @function toJSON
     * @memberof C2S_EquipmentOpt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_EquipmentOpt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_EquipmentOpt;
})();

$root.S2C_EquipmentOpt = (function() {

    /**
     * Properties of a S2C_EquipmentOpt.
     * @exports IS2C_EquipmentOpt
     * @interface IS2C_EquipmentOpt
     * @property {number|Long|null} [id] S2C_EquipmentOpt id
     * @property {boolean|null} [wear] S2C_EquipmentOpt wear
     */

    /**
     * Constructs a new S2C_EquipmentOpt.
     * @exports S2C_EquipmentOpt
     * @classdesc Represents a S2C_EquipmentOpt.
     * @implements IS2C_EquipmentOpt
     * @constructor
     * @param {IS2C_EquipmentOpt=} [properties] Properties to set
     */
    function S2C_EquipmentOpt(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_EquipmentOpt id.
     * @member {number|Long} id
     * @memberof S2C_EquipmentOpt
     * @instance
     */
    S2C_EquipmentOpt.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_EquipmentOpt wear.
     * @member {boolean} wear
     * @memberof S2C_EquipmentOpt
     * @instance
     */
    S2C_EquipmentOpt.prototype.wear = false;

    /**
     * Creates a new S2C_EquipmentOpt instance using the specified properties.
     * @function create
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {IS2C_EquipmentOpt=} [properties] Properties to set
     * @returns {S2C_EquipmentOpt} S2C_EquipmentOpt instance
     */
    S2C_EquipmentOpt.create = function create(properties) {
        return new S2C_EquipmentOpt(properties);
    };

    /**
     * Encodes the specified S2C_EquipmentOpt message. Does not implicitly {@link S2C_EquipmentOpt.verify|verify} messages.
     * @function encode
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {IS2C_EquipmentOpt} message S2C_EquipmentOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_EquipmentOpt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
        if (message.wear != null && message.hasOwnProperty("wear"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.wear);
        return writer;
    };

    /**
     * Encodes the specified S2C_EquipmentOpt message, length delimited. Does not implicitly {@link S2C_EquipmentOpt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {IS2C_EquipmentOpt} message S2C_EquipmentOpt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_EquipmentOpt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_EquipmentOpt message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_EquipmentOpt} S2C_EquipmentOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_EquipmentOpt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_EquipmentOpt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.int64();
                break;
            case 2:
                message.wear = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_EquipmentOpt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_EquipmentOpt} S2C_EquipmentOpt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_EquipmentOpt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_EquipmentOpt message.
     * @function verify
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_EquipmentOpt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.wear != null && message.hasOwnProperty("wear"))
            if (typeof message.wear !== "boolean")
                return "wear: boolean expected";
        return null;
    };

    /**
     * Creates a S2C_EquipmentOpt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_EquipmentOpt} S2C_EquipmentOpt
     */
    S2C_EquipmentOpt.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_EquipmentOpt)
            return object;
        var message = new $root.S2C_EquipmentOpt();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.wear != null)
            message.wear = Boolean(object.wear);
        return message;
    };

    /**
     * Creates a plain object from a S2C_EquipmentOpt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_EquipmentOpt
     * @static
     * @param {S2C_EquipmentOpt} message S2C_EquipmentOpt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_EquipmentOpt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.wear = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.wear != null && message.hasOwnProperty("wear"))
            object.wear = message.wear;
        return object;
    };

    /**
     * Converts this S2C_EquipmentOpt to JSON.
     * @function toJSON
     * @memberof S2C_EquipmentOpt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_EquipmentOpt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_EquipmentOpt;
})();

$root.DanYaoInfoPB = (function() {

    /**
     * Properties of a DanYaoInfoPB.
     * @exports IDanYaoInfoPB
     * @interface IDanYaoInfoPB
     * @property {number} itemId DanYaoInfoPB itemId
     * @property {number|null} [useCount] DanYaoInfoPB useCount
     * @property {number|null} [maxCount] DanYaoInfoPB maxCount
     */

    /**
     * Constructs a new DanYaoInfoPB.
     * @exports DanYaoInfoPB
     * @classdesc Represents a DanYaoInfoPB.
     * @implements IDanYaoInfoPB
     * @constructor
     * @param {IDanYaoInfoPB=} [properties] Properties to set
     */
    function DanYaoInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DanYaoInfoPB itemId.
     * @member {number} itemId
     * @memberof DanYaoInfoPB
     * @instance
     */
    DanYaoInfoPB.prototype.itemId = 0;

    /**
     * DanYaoInfoPB useCount.
     * @member {number} useCount
     * @memberof DanYaoInfoPB
     * @instance
     */
    DanYaoInfoPB.prototype.useCount = 0;

    /**
     * DanYaoInfoPB maxCount.
     * @member {number} maxCount
     * @memberof DanYaoInfoPB
     * @instance
     */
    DanYaoInfoPB.prototype.maxCount = 0;

    /**
     * Creates a new DanYaoInfoPB instance using the specified properties.
     * @function create
     * @memberof DanYaoInfoPB
     * @static
     * @param {IDanYaoInfoPB=} [properties] Properties to set
     * @returns {DanYaoInfoPB} DanYaoInfoPB instance
     */
    DanYaoInfoPB.create = function create(properties) {
        return new DanYaoInfoPB(properties);
    };

    /**
     * Encodes the specified DanYaoInfoPB message. Does not implicitly {@link DanYaoInfoPB.verify|verify} messages.
     * @function encode
     * @memberof DanYaoInfoPB
     * @static
     * @param {IDanYaoInfoPB} message DanYaoInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DanYaoInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
        if (message.useCount != null && message.hasOwnProperty("useCount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.useCount);
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxCount);
        return writer;
    };

    /**
     * Encodes the specified DanYaoInfoPB message, length delimited. Does not implicitly {@link DanYaoInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DanYaoInfoPB
     * @static
     * @param {IDanYaoInfoPB} message DanYaoInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DanYaoInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DanYaoInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof DanYaoInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DanYaoInfoPB} DanYaoInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DanYaoInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DanYaoInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.itemId = reader.int32();
                break;
            case 2:
                message.useCount = reader.int32();
                break;
            case 3:
                message.maxCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("itemId"))
            throw $util.ProtocolError("missing required 'itemId'", { instance: message });
        return message;
    };

    /**
     * Decodes a DanYaoInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DanYaoInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DanYaoInfoPB} DanYaoInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DanYaoInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DanYaoInfoPB message.
     * @function verify
     * @memberof DanYaoInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DanYaoInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.itemId))
            return "itemId: integer expected";
        if (message.useCount != null && message.hasOwnProperty("useCount"))
            if (!$util.isInteger(message.useCount))
                return "useCount: integer expected";
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            if (!$util.isInteger(message.maxCount))
                return "maxCount: integer expected";
        return null;
    };

    /**
     * Creates a DanYaoInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DanYaoInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DanYaoInfoPB} DanYaoInfoPB
     */
    DanYaoInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.DanYaoInfoPB)
            return object;
        var message = new $root.DanYaoInfoPB();
        if (object.itemId != null)
            message.itemId = object.itemId | 0;
        if (object.useCount != null)
            message.useCount = object.useCount | 0;
        if (object.maxCount != null)
            message.maxCount = object.maxCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a DanYaoInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DanYaoInfoPB
     * @static
     * @param {DanYaoInfoPB} message DanYaoInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DanYaoInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.itemId = 0;
            object.useCount = 0;
            object.maxCount = 0;
        }
        if (message.itemId != null && message.hasOwnProperty("itemId"))
            object.itemId = message.itemId;
        if (message.useCount != null && message.hasOwnProperty("useCount"))
            object.useCount = message.useCount;
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            object.maxCount = message.maxCount;
        return object;
    };

    /**
     * Converts this DanYaoInfoPB to JSON.
     * @function toJSON
     * @memberof DanYaoInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DanYaoInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DanYaoInfoPB;
})();

$root.C2S_LevelUpRate = (function() {

    /**
     * Properties of a C2S_LevelUpRate.
     * @exports IC2S_LevelUpRate
     * @interface IC2S_LevelUpRate
     */

    /**
     * Constructs a new C2S_LevelUpRate.
     * @exports C2S_LevelUpRate
     * @classdesc Represents a C2S_LevelUpRate.
     * @implements IC2S_LevelUpRate
     * @constructor
     * @param {IC2S_LevelUpRate=} [properties] Properties to set
     */
    function C2S_LevelUpRate(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_LevelUpRate instance using the specified properties.
     * @function create
     * @memberof C2S_LevelUpRate
     * @static
     * @param {IC2S_LevelUpRate=} [properties] Properties to set
     * @returns {C2S_LevelUpRate} C2S_LevelUpRate instance
     */
    C2S_LevelUpRate.create = function create(properties) {
        return new C2S_LevelUpRate(properties);
    };

    /**
     * Encodes the specified C2S_LevelUpRate message. Does not implicitly {@link C2S_LevelUpRate.verify|verify} messages.
     * @function encode
     * @memberof C2S_LevelUpRate
     * @static
     * @param {IC2S_LevelUpRate} message C2S_LevelUpRate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_LevelUpRate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_LevelUpRate message, length delimited. Does not implicitly {@link C2S_LevelUpRate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_LevelUpRate
     * @static
     * @param {IC2S_LevelUpRate} message C2S_LevelUpRate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_LevelUpRate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_LevelUpRate message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_LevelUpRate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_LevelUpRate} C2S_LevelUpRate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_LevelUpRate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_LevelUpRate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_LevelUpRate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_LevelUpRate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_LevelUpRate} C2S_LevelUpRate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_LevelUpRate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_LevelUpRate message.
     * @function verify
     * @memberof C2S_LevelUpRate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_LevelUpRate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_LevelUpRate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_LevelUpRate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_LevelUpRate} C2S_LevelUpRate
     */
    C2S_LevelUpRate.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_LevelUpRate)
            return object;
        return new $root.C2S_LevelUpRate();
    };

    /**
     * Creates a plain object from a C2S_LevelUpRate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_LevelUpRate
     * @static
     * @param {C2S_LevelUpRate} message C2S_LevelUpRate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_LevelUpRate.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_LevelUpRate to JSON.
     * @function toJSON
     * @memberof C2S_LevelUpRate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_LevelUpRate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_LevelUpRate;
})();

$root.S2C_LevelUpRate = (function() {

    /**
     * Properties of a S2C_LevelUpRate.
     * @exports IS2C_LevelUpRate
     * @interface IS2C_LevelUpRate
     * @property {number|null} [rate] S2C_LevelUpRate rate
     */

    /**
     * Constructs a new S2C_LevelUpRate.
     * @exports S2C_LevelUpRate
     * @classdesc Represents a S2C_LevelUpRate.
     * @implements IS2C_LevelUpRate
     * @constructor
     * @param {IS2C_LevelUpRate=} [properties] Properties to set
     */
    function S2C_LevelUpRate(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_LevelUpRate rate.
     * @member {number} rate
     * @memberof S2C_LevelUpRate
     * @instance
     */
    S2C_LevelUpRate.prototype.rate = 0;

    /**
     * Creates a new S2C_LevelUpRate instance using the specified properties.
     * @function create
     * @memberof S2C_LevelUpRate
     * @static
     * @param {IS2C_LevelUpRate=} [properties] Properties to set
     * @returns {S2C_LevelUpRate} S2C_LevelUpRate instance
     */
    S2C_LevelUpRate.create = function create(properties) {
        return new S2C_LevelUpRate(properties);
    };

    /**
     * Encodes the specified S2C_LevelUpRate message. Does not implicitly {@link S2C_LevelUpRate.verify|verify} messages.
     * @function encode
     * @memberof S2C_LevelUpRate
     * @static
     * @param {IS2C_LevelUpRate} message S2C_LevelUpRate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_LevelUpRate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rate != null && message.hasOwnProperty("rate"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rate);
        return writer;
    };

    /**
     * Encodes the specified S2C_LevelUpRate message, length delimited. Does not implicitly {@link S2C_LevelUpRate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_LevelUpRate
     * @static
     * @param {IS2C_LevelUpRate} message S2C_LevelUpRate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_LevelUpRate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_LevelUpRate message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_LevelUpRate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_LevelUpRate} S2C_LevelUpRate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_LevelUpRate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_LevelUpRate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rate = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_LevelUpRate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_LevelUpRate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_LevelUpRate} S2C_LevelUpRate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_LevelUpRate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_LevelUpRate message.
     * @function verify
     * @memberof S2C_LevelUpRate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_LevelUpRate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rate != null && message.hasOwnProperty("rate"))
            if (!$util.isInteger(message.rate))
                return "rate: integer expected";
        return null;
    };

    /**
     * Creates a S2C_LevelUpRate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_LevelUpRate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_LevelUpRate} S2C_LevelUpRate
     */
    S2C_LevelUpRate.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_LevelUpRate)
            return object;
        var message = new $root.S2C_LevelUpRate();
        if (object.rate != null)
            message.rate = object.rate | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_LevelUpRate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_LevelUpRate
     * @static
     * @param {S2C_LevelUpRate} message S2C_LevelUpRate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_LevelUpRate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.rate = 0;
        if (message.rate != null && message.hasOwnProperty("rate"))
            object.rate = message.rate;
        return object;
    };

    /**
     * Converts this S2C_LevelUpRate to JSON.
     * @function toJSON
     * @memberof S2C_LevelUpRate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_LevelUpRate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_LevelUpRate;
})();

$root.C2S_ItemUseInfo = (function() {

    /**
     * Properties of a C2S_ItemUseInfo.
     * @exports IC2S_ItemUseInfo
     * @interface IC2S_ItemUseInfo
     */

    /**
     * Constructs a new C2S_ItemUseInfo.
     * @exports C2S_ItemUseInfo
     * @classdesc Represents a C2S_ItemUseInfo.
     * @implements IC2S_ItemUseInfo
     * @constructor
     * @param {IC2S_ItemUseInfo=} [properties] Properties to set
     */
    function C2S_ItemUseInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_ItemUseInfo instance using the specified properties.
     * @function create
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {IC2S_ItemUseInfo=} [properties] Properties to set
     * @returns {C2S_ItemUseInfo} C2S_ItemUseInfo instance
     */
    C2S_ItemUseInfo.create = function create(properties) {
        return new C2S_ItemUseInfo(properties);
    };

    /**
     * Encodes the specified C2S_ItemUseInfo message. Does not implicitly {@link C2S_ItemUseInfo.verify|verify} messages.
     * @function encode
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {IC2S_ItemUseInfo} message C2S_ItemUseInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ItemUseInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_ItemUseInfo message, length delimited. Does not implicitly {@link C2S_ItemUseInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {IC2S_ItemUseInfo} message C2S_ItemUseInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ItemUseInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_ItemUseInfo message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_ItemUseInfo} C2S_ItemUseInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ItemUseInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_ItemUseInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_ItemUseInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_ItemUseInfo} C2S_ItemUseInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ItemUseInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_ItemUseInfo message.
     * @function verify
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_ItemUseInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_ItemUseInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_ItemUseInfo} C2S_ItemUseInfo
     */
    C2S_ItemUseInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_ItemUseInfo)
            return object;
        return new $root.C2S_ItemUseInfo();
    };

    /**
     * Creates a plain object from a C2S_ItemUseInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_ItemUseInfo
     * @static
     * @param {C2S_ItemUseInfo} message C2S_ItemUseInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_ItemUseInfo.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_ItemUseInfo to JSON.
     * @function toJSON
     * @memberof C2S_ItemUseInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_ItemUseInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_ItemUseInfo;
})();

$root.S2C_ItemUseInfo = (function() {

    /**
     * Properties of a S2C_ItemUseInfo.
     * @exports IS2C_ItemUseInfo
     * @interface IS2C_ItemUseInfo
     * @property {Array.<IItemUseMsg>|null} [itemUse] S2C_ItemUseInfo itemUse
     */

    /**
     * Constructs a new S2C_ItemUseInfo.
     * @exports S2C_ItemUseInfo
     * @classdesc Represents a S2C_ItemUseInfo.
     * @implements IS2C_ItemUseInfo
     * @constructor
     * @param {IS2C_ItemUseInfo=} [properties] Properties to set
     */
    function S2C_ItemUseInfo(properties) {
        this.itemUse = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ItemUseInfo itemUse.
     * @member {Array.<IItemUseMsg>} itemUse
     * @memberof S2C_ItemUseInfo
     * @instance
     */
    S2C_ItemUseInfo.prototype.itemUse = $util.emptyArray;

    /**
     * Creates a new S2C_ItemUseInfo instance using the specified properties.
     * @function create
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {IS2C_ItemUseInfo=} [properties] Properties to set
     * @returns {S2C_ItemUseInfo} S2C_ItemUseInfo instance
     */
    S2C_ItemUseInfo.create = function create(properties) {
        return new S2C_ItemUseInfo(properties);
    };

    /**
     * Encodes the specified S2C_ItemUseInfo message. Does not implicitly {@link S2C_ItemUseInfo.verify|verify} messages.
     * @function encode
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {IS2C_ItemUseInfo} message S2C_ItemUseInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ItemUseInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.itemUse != null && message.itemUse.length)
            for (var i = 0; i < message.itemUse.length; ++i)
                $root.ItemUseMsg.encode(message.itemUse[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_ItemUseInfo message, length delimited. Does not implicitly {@link S2C_ItemUseInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {IS2C_ItemUseInfo} message S2C_ItemUseInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ItemUseInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ItemUseInfo message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ItemUseInfo} S2C_ItemUseInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ItemUseInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ItemUseInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.itemUse && message.itemUse.length))
                    message.itemUse = [];
                message.itemUse.push($root.ItemUseMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ItemUseInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ItemUseInfo} S2C_ItemUseInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ItemUseInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ItemUseInfo message.
     * @function verify
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ItemUseInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.itemUse != null && message.hasOwnProperty("itemUse")) {
            if (!Array.isArray(message.itemUse))
                return "itemUse: array expected";
            for (var i = 0; i < message.itemUse.length; ++i) {
                var error = $root.ItemUseMsg.verify(message.itemUse[i]);
                if (error)
                    return "itemUse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_ItemUseInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ItemUseInfo} S2C_ItemUseInfo
     */
    S2C_ItemUseInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ItemUseInfo)
            return object;
        var message = new $root.S2C_ItemUseInfo();
        if (object.itemUse) {
            if (!Array.isArray(object.itemUse))
                throw TypeError(".S2C_ItemUseInfo.itemUse: array expected");
            message.itemUse = [];
            for (var i = 0; i < object.itemUse.length; ++i) {
                if (typeof object.itemUse[i] !== "object")
                    throw TypeError(".S2C_ItemUseInfo.itemUse: object expected");
                message.itemUse[i] = $root.ItemUseMsg.fromObject(object.itemUse[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_ItemUseInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ItemUseInfo
     * @static
     * @param {S2C_ItemUseInfo} message S2C_ItemUseInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ItemUseInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.itemUse = [];
        if (message.itemUse && message.itemUse.length) {
            object.itemUse = [];
            for (var j = 0; j < message.itemUse.length; ++j)
                object.itemUse[j] = $root.ItemUseMsg.toObject(message.itemUse[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_ItemUseInfo to JSON.
     * @function toJSON
     * @memberof S2C_ItemUseInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ItemUseInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ItemUseInfo;
})();

$root.C2S_ItemExchangeInfo = (function() {

    /**
     * Properties of a C2S_ItemExchangeInfo.
     * @exports IC2S_ItemExchangeInfo
     * @interface IC2S_ItemExchangeInfo
     */

    /**
     * Constructs a new C2S_ItemExchangeInfo.
     * @exports C2S_ItemExchangeInfo
     * @classdesc Represents a C2S_ItemExchangeInfo.
     * @implements IC2S_ItemExchangeInfo
     * @constructor
     * @param {IC2S_ItemExchangeInfo=} [properties] Properties to set
     */
    function C2S_ItemExchangeInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_ItemExchangeInfo instance using the specified properties.
     * @function create
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {IC2S_ItemExchangeInfo=} [properties] Properties to set
     * @returns {C2S_ItemExchangeInfo} C2S_ItemExchangeInfo instance
     */
    C2S_ItemExchangeInfo.create = function create(properties) {
        return new C2S_ItemExchangeInfo(properties);
    };

    /**
     * Encodes the specified C2S_ItemExchangeInfo message. Does not implicitly {@link C2S_ItemExchangeInfo.verify|verify} messages.
     * @function encode
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {IC2S_ItemExchangeInfo} message C2S_ItemExchangeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ItemExchangeInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_ItemExchangeInfo message, length delimited. Does not implicitly {@link C2S_ItemExchangeInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {IC2S_ItemExchangeInfo} message C2S_ItemExchangeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_ItemExchangeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_ItemExchangeInfo message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_ItemExchangeInfo} C2S_ItemExchangeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ItemExchangeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_ItemExchangeInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_ItemExchangeInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_ItemExchangeInfo} C2S_ItemExchangeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_ItemExchangeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_ItemExchangeInfo message.
     * @function verify
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_ItemExchangeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_ItemExchangeInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_ItemExchangeInfo} C2S_ItemExchangeInfo
     */
    C2S_ItemExchangeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_ItemExchangeInfo)
            return object;
        return new $root.C2S_ItemExchangeInfo();
    };

    /**
     * Creates a plain object from a C2S_ItemExchangeInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_ItemExchangeInfo
     * @static
     * @param {C2S_ItemExchangeInfo} message C2S_ItemExchangeInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_ItemExchangeInfo.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_ItemExchangeInfo to JSON.
     * @function toJSON
     * @memberof C2S_ItemExchangeInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_ItemExchangeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_ItemExchangeInfo;
})();

$root.S2C_ItemExchangeInfo = (function() {

    /**
     * Properties of a S2C_ItemExchangeInfo.
     * @exports IS2C_ItemExchangeInfo
     * @interface IS2C_ItemExchangeInfo
     * @property {Array.<IExchangeMsg>|null} [itemExchange] S2C_ItemExchangeInfo itemExchange
     */

    /**
     * Constructs a new S2C_ItemExchangeInfo.
     * @exports S2C_ItemExchangeInfo
     * @classdesc Represents a S2C_ItemExchangeInfo.
     * @implements IS2C_ItemExchangeInfo
     * @constructor
     * @param {IS2C_ItemExchangeInfo=} [properties] Properties to set
     */
    function S2C_ItemExchangeInfo(properties) {
        this.itemExchange = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_ItemExchangeInfo itemExchange.
     * @member {Array.<IExchangeMsg>} itemExchange
     * @memberof S2C_ItemExchangeInfo
     * @instance
     */
    S2C_ItemExchangeInfo.prototype.itemExchange = $util.emptyArray;

    /**
     * Creates a new S2C_ItemExchangeInfo instance using the specified properties.
     * @function create
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {IS2C_ItemExchangeInfo=} [properties] Properties to set
     * @returns {S2C_ItemExchangeInfo} S2C_ItemExchangeInfo instance
     */
    S2C_ItemExchangeInfo.create = function create(properties) {
        return new S2C_ItemExchangeInfo(properties);
    };

    /**
     * Encodes the specified S2C_ItemExchangeInfo message. Does not implicitly {@link S2C_ItemExchangeInfo.verify|verify} messages.
     * @function encode
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {IS2C_ItemExchangeInfo} message S2C_ItemExchangeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ItemExchangeInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.itemExchange != null && message.itemExchange.length)
            for (var i = 0; i < message.itemExchange.length; ++i)
                $root.ExchangeMsg.encode(message.itemExchange[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_ItemExchangeInfo message, length delimited. Does not implicitly {@link S2C_ItemExchangeInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {IS2C_ItemExchangeInfo} message S2C_ItemExchangeInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_ItemExchangeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_ItemExchangeInfo message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_ItemExchangeInfo} S2C_ItemExchangeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ItemExchangeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_ItemExchangeInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.itemExchange && message.itemExchange.length))
                    message.itemExchange = [];
                message.itemExchange.push($root.ExchangeMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_ItemExchangeInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_ItemExchangeInfo} S2C_ItemExchangeInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_ItemExchangeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_ItemExchangeInfo message.
     * @function verify
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_ItemExchangeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.itemExchange != null && message.hasOwnProperty("itemExchange")) {
            if (!Array.isArray(message.itemExchange))
                return "itemExchange: array expected";
            for (var i = 0; i < message.itemExchange.length; ++i) {
                var error = $root.ExchangeMsg.verify(message.itemExchange[i]);
                if (error)
                    return "itemExchange." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_ItemExchangeInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_ItemExchangeInfo} S2C_ItemExchangeInfo
     */
    S2C_ItemExchangeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_ItemExchangeInfo)
            return object;
        var message = new $root.S2C_ItemExchangeInfo();
        if (object.itemExchange) {
            if (!Array.isArray(object.itemExchange))
                throw TypeError(".S2C_ItemExchangeInfo.itemExchange: array expected");
            message.itemExchange = [];
            for (var i = 0; i < object.itemExchange.length; ++i) {
                if (typeof object.itemExchange[i] !== "object")
                    throw TypeError(".S2C_ItemExchangeInfo.itemExchange: object expected");
                message.itemExchange[i] = $root.ExchangeMsg.fromObject(object.itemExchange[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_ItemExchangeInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_ItemExchangeInfo
     * @static
     * @param {S2C_ItemExchangeInfo} message S2C_ItemExchangeInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_ItemExchangeInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.itemExchange = [];
        if (message.itemExchange && message.itemExchange.length) {
            object.itemExchange = [];
            for (var j = 0; j < message.itemExchange.length; ++j)
                object.itemExchange[j] = $root.ExchangeMsg.toObject(message.itemExchange[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_ItemExchangeInfo to JSON.
     * @function toJSON
     * @memberof S2C_ItemExchangeInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_ItemExchangeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_ItemExchangeInfo;
})();

$root.S2C_PackageInfo = (function() {

    /**
     * Properties of a S2C_PackageInfo.
     * @exports IS2C_PackageInfo
     * @interface IS2C_PackageInfo
     * @property {number|null} [pkgNum] S2C_PackageInfo pkgNum
     * @property {number|null} [pkgLevel] S2C_PackageInfo pkgLevel
     * @property {number|null} [pkgUse] S2C_PackageInfo pkgUse
     */

    /**
     * Constructs a new S2C_PackageInfo.
     * @exports S2C_PackageInfo
     * @classdesc Represents a S2C_PackageInfo.
     * @implements IS2C_PackageInfo
     * @constructor
     * @param {IS2C_PackageInfo=} [properties] Properties to set
     */
    function S2C_PackageInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_PackageInfo pkgNum.
     * @member {number} pkgNum
     * @memberof S2C_PackageInfo
     * @instance
     */
    S2C_PackageInfo.prototype.pkgNum = 0;

    /**
     * S2C_PackageInfo pkgLevel.
     * @member {number} pkgLevel
     * @memberof S2C_PackageInfo
     * @instance
     */
    S2C_PackageInfo.prototype.pkgLevel = 0;

    /**
     * S2C_PackageInfo pkgUse.
     * @member {number} pkgUse
     * @memberof S2C_PackageInfo
     * @instance
     */
    S2C_PackageInfo.prototype.pkgUse = 0;

    /**
     * Creates a new S2C_PackageInfo instance using the specified properties.
     * @function create
     * @memberof S2C_PackageInfo
     * @static
     * @param {IS2C_PackageInfo=} [properties] Properties to set
     * @returns {S2C_PackageInfo} S2C_PackageInfo instance
     */
    S2C_PackageInfo.create = function create(properties) {
        return new S2C_PackageInfo(properties);
    };

    /**
     * Encodes the specified S2C_PackageInfo message. Does not implicitly {@link S2C_PackageInfo.verify|verify} messages.
     * @function encode
     * @memberof S2C_PackageInfo
     * @static
     * @param {IS2C_PackageInfo} message S2C_PackageInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PackageInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pkgNum);
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pkgLevel);
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pkgUse);
        return writer;
    };

    /**
     * Encodes the specified S2C_PackageInfo message, length delimited. Does not implicitly {@link S2C_PackageInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_PackageInfo
     * @static
     * @param {IS2C_PackageInfo} message S2C_PackageInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PackageInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_PackageInfo message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_PackageInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_PackageInfo} S2C_PackageInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PackageInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_PackageInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.pkgNum = reader.int32();
                break;
            case 2:
                message.pkgLevel = reader.int32();
                break;
            case 3:
                message.pkgUse = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_PackageInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_PackageInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_PackageInfo} S2C_PackageInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PackageInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_PackageInfo message.
     * @function verify
     * @memberof S2C_PackageInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_PackageInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            if (!$util.isInteger(message.pkgNum))
                return "pkgNum: integer expected";
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            if (!$util.isInteger(message.pkgLevel))
                return "pkgLevel: integer expected";
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            if (!$util.isInteger(message.pkgUse))
                return "pkgUse: integer expected";
        return null;
    };

    /**
     * Creates a S2C_PackageInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_PackageInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_PackageInfo} S2C_PackageInfo
     */
    S2C_PackageInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_PackageInfo)
            return object;
        var message = new $root.S2C_PackageInfo();
        if (object.pkgNum != null)
            message.pkgNum = object.pkgNum | 0;
        if (object.pkgLevel != null)
            message.pkgLevel = object.pkgLevel | 0;
        if (object.pkgUse != null)
            message.pkgUse = object.pkgUse | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_PackageInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_PackageInfo
     * @static
     * @param {S2C_PackageInfo} message S2C_PackageInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_PackageInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.pkgNum = 0;
            object.pkgLevel = 0;
            object.pkgUse = 0;
        }
        if (message.pkgNum != null && message.hasOwnProperty("pkgNum"))
            object.pkgNum = message.pkgNum;
        if (message.pkgLevel != null && message.hasOwnProperty("pkgLevel"))
            object.pkgLevel = message.pkgLevel;
        if (message.pkgUse != null && message.hasOwnProperty("pkgUse"))
            object.pkgUse = message.pkgUse;
        return object;
    };

    /**
     * Converts this S2C_PackageInfo to JSON.
     * @function toJSON
     * @memberof S2C_PackageInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_PackageInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_PackageInfo;
})();

$root.C2S_GetShopList = (function() {

    /**
     * Properties of a C2S_GetShopList.
     * @exports IC2S_GetShopList
     * @interface IC2S_GetShopList
     */

    /**
     * Constructs a new C2S_GetShopList.
     * @exports C2S_GetShopList
     * @classdesc Represents a C2S_GetShopList.
     * @implements IC2S_GetShopList
     * @constructor
     * @param {IC2S_GetShopList=} [properties] Properties to set
     */
    function C2S_GetShopList(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_GetShopList instance using the specified properties.
     * @function create
     * @memberof C2S_GetShopList
     * @static
     * @param {IC2S_GetShopList=} [properties] Properties to set
     * @returns {C2S_GetShopList} C2S_GetShopList instance
     */
    C2S_GetShopList.create = function create(properties) {
        return new C2S_GetShopList(properties);
    };

    /**
     * Encodes the specified C2S_GetShopList message. Does not implicitly {@link C2S_GetShopList.verify|verify} messages.
     * @function encode
     * @memberof C2S_GetShopList
     * @static
     * @param {IC2S_GetShopList} message C2S_GetShopList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetShopList.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_GetShopList message, length delimited. Does not implicitly {@link C2S_GetShopList.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_GetShopList
     * @static
     * @param {IC2S_GetShopList} message C2S_GetShopList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_GetShopList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_GetShopList message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_GetShopList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_GetShopList} C2S_GetShopList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetShopList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_GetShopList();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_GetShopList message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_GetShopList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_GetShopList} C2S_GetShopList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_GetShopList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_GetShopList message.
     * @function verify
     * @memberof C2S_GetShopList
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_GetShopList.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_GetShopList message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_GetShopList
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_GetShopList} C2S_GetShopList
     */
    C2S_GetShopList.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_GetShopList)
            return object;
        return new $root.C2S_GetShopList();
    };

    /**
     * Creates a plain object from a C2S_GetShopList message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_GetShopList
     * @static
     * @param {C2S_GetShopList} message C2S_GetShopList
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_GetShopList.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_GetShopList to JSON.
     * @function toJSON
     * @memberof C2S_GetShopList
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_GetShopList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_GetShopList;
})();

$root.S2C_GetShopList = (function() {

    /**
     * Properties of a S2C_GetShopList.
     * @exports IS2C_GetShopList
     * @interface IS2C_GetShopList
     * @property {Array.<IShopInfoPB>|null} [shopInfo] S2C_GetShopList shopInfo
     */

    /**
     * Constructs a new S2C_GetShopList.
     * @exports S2C_GetShopList
     * @classdesc Represents a S2C_GetShopList.
     * @implements IS2C_GetShopList
     * @constructor
     * @param {IS2C_GetShopList=} [properties] Properties to set
     */
    function S2C_GetShopList(properties) {
        this.shopInfo = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_GetShopList shopInfo.
     * @member {Array.<IShopInfoPB>} shopInfo
     * @memberof S2C_GetShopList
     * @instance
     */
    S2C_GetShopList.prototype.shopInfo = $util.emptyArray;

    /**
     * Creates a new S2C_GetShopList instance using the specified properties.
     * @function create
     * @memberof S2C_GetShopList
     * @static
     * @param {IS2C_GetShopList=} [properties] Properties to set
     * @returns {S2C_GetShopList} S2C_GetShopList instance
     */
    S2C_GetShopList.create = function create(properties) {
        return new S2C_GetShopList(properties);
    };

    /**
     * Encodes the specified S2C_GetShopList message. Does not implicitly {@link S2C_GetShopList.verify|verify} messages.
     * @function encode
     * @memberof S2C_GetShopList
     * @static
     * @param {IS2C_GetShopList} message S2C_GetShopList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetShopList.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.shopInfo != null && message.shopInfo.length)
            for (var i = 0; i < message.shopInfo.length; ++i)
                $root.ShopInfoPB.encode(message.shopInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_GetShopList message, length delimited. Does not implicitly {@link S2C_GetShopList.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_GetShopList
     * @static
     * @param {IS2C_GetShopList} message S2C_GetShopList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_GetShopList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_GetShopList message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_GetShopList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_GetShopList} S2C_GetShopList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetShopList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_GetShopList();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.shopInfo && message.shopInfo.length))
                    message.shopInfo = [];
                message.shopInfo.push($root.ShopInfoPB.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_GetShopList message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_GetShopList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_GetShopList} S2C_GetShopList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_GetShopList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_GetShopList message.
     * @function verify
     * @memberof S2C_GetShopList
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_GetShopList.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.shopInfo != null && message.hasOwnProperty("shopInfo")) {
            if (!Array.isArray(message.shopInfo))
                return "shopInfo: array expected";
            for (var i = 0; i < message.shopInfo.length; ++i) {
                var error = $root.ShopInfoPB.verify(message.shopInfo[i]);
                if (error)
                    return "shopInfo." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_GetShopList message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_GetShopList
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_GetShopList} S2C_GetShopList
     */
    S2C_GetShopList.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_GetShopList)
            return object;
        var message = new $root.S2C_GetShopList();
        if (object.shopInfo) {
            if (!Array.isArray(object.shopInfo))
                throw TypeError(".S2C_GetShopList.shopInfo: array expected");
            message.shopInfo = [];
            for (var i = 0; i < object.shopInfo.length; ++i) {
                if (typeof object.shopInfo[i] !== "object")
                    throw TypeError(".S2C_GetShopList.shopInfo: object expected");
                message.shopInfo[i] = $root.ShopInfoPB.fromObject(object.shopInfo[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_GetShopList message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_GetShopList
     * @static
     * @param {S2C_GetShopList} message S2C_GetShopList
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_GetShopList.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.shopInfo = [];
        if (message.shopInfo && message.shopInfo.length) {
            object.shopInfo = [];
            for (var j = 0; j < message.shopInfo.length; ++j)
                object.shopInfo[j] = $root.ShopInfoPB.toObject(message.shopInfo[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_GetShopList to JSON.
     * @function toJSON
     * @memberof S2C_GetShopList
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_GetShopList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_GetShopList;
})();

$root.C2S_PurchaseGoods = (function() {

    /**
     * Properties of a C2S_PurchaseGoods.
     * @exports IC2S_PurchaseGoods
     * @interface IC2S_PurchaseGoods
     * @property {number} shopType C2S_PurchaseGoods shopType
     * @property {number} layer C2S_PurchaseGoods layer
     * @property {number} goodsID C2S_PurchaseGoods goodsID
     * @property {number} count C2S_PurchaseGoods count
     */

    /**
     * Constructs a new C2S_PurchaseGoods.
     * @exports C2S_PurchaseGoods
     * @classdesc Represents a C2S_PurchaseGoods.
     * @implements IC2S_PurchaseGoods
     * @constructor
     * @param {IC2S_PurchaseGoods=} [properties] Properties to set
     */
    function C2S_PurchaseGoods(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_PurchaseGoods shopType.
     * @member {number} shopType
     * @memberof C2S_PurchaseGoods
     * @instance
     */
    C2S_PurchaseGoods.prototype.shopType = 0;

    /**
     * C2S_PurchaseGoods layer.
     * @member {number} layer
     * @memberof C2S_PurchaseGoods
     * @instance
     */
    C2S_PurchaseGoods.prototype.layer = 0;

    /**
     * C2S_PurchaseGoods goodsID.
     * @member {number} goodsID
     * @memberof C2S_PurchaseGoods
     * @instance
     */
    C2S_PurchaseGoods.prototype.goodsID = 0;

    /**
     * C2S_PurchaseGoods count.
     * @member {number} count
     * @memberof C2S_PurchaseGoods
     * @instance
     */
    C2S_PurchaseGoods.prototype.count = 0;

    /**
     * Creates a new C2S_PurchaseGoods instance using the specified properties.
     * @function create
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {IC2S_PurchaseGoods=} [properties] Properties to set
     * @returns {C2S_PurchaseGoods} C2S_PurchaseGoods instance
     */
    C2S_PurchaseGoods.create = function create(properties) {
        return new C2S_PurchaseGoods(properties);
    };

    /**
     * Encodes the specified C2S_PurchaseGoods message. Does not implicitly {@link C2S_PurchaseGoods.verify|verify} messages.
     * @function encode
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {IC2S_PurchaseGoods} message C2S_PurchaseGoods message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_PurchaseGoods.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.shopType);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.layer);
        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.goodsID);
        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified C2S_PurchaseGoods message, length delimited. Does not implicitly {@link C2S_PurchaseGoods.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {IC2S_PurchaseGoods} message C2S_PurchaseGoods message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_PurchaseGoods.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_PurchaseGoods message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_PurchaseGoods} C2S_PurchaseGoods
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_PurchaseGoods.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_PurchaseGoods();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.shopType = reader.int32();
                break;
            case 2:
                message.layer = reader.int32();
                break;
            case 3:
                message.goodsID = reader.int32();
                break;
            case 4:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("shopType"))
            throw $util.ProtocolError("missing required 'shopType'", { instance: message });
        if (!message.hasOwnProperty("layer"))
            throw $util.ProtocolError("missing required 'layer'", { instance: message });
        if (!message.hasOwnProperty("goodsID"))
            throw $util.ProtocolError("missing required 'goodsID'", { instance: message });
        if (!message.hasOwnProperty("count"))
            throw $util.ProtocolError("missing required 'count'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_PurchaseGoods message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_PurchaseGoods} C2S_PurchaseGoods
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_PurchaseGoods.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_PurchaseGoods message.
     * @function verify
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_PurchaseGoods.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.shopType))
            return "shopType: integer expected";
        if (!$util.isInteger(message.layer))
            return "layer: integer expected";
        if (!$util.isInteger(message.goodsID))
            return "goodsID: integer expected";
        if (!$util.isInteger(message.count))
            return "count: integer expected";
        return null;
    };

    /**
     * Creates a C2S_PurchaseGoods message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_PurchaseGoods} C2S_PurchaseGoods
     */
    C2S_PurchaseGoods.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_PurchaseGoods)
            return object;
        var message = new $root.C2S_PurchaseGoods();
        if (object.shopType != null)
            message.shopType = object.shopType | 0;
        if (object.layer != null)
            message.layer = object.layer | 0;
        if (object.goodsID != null)
            message.goodsID = object.goodsID | 0;
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_PurchaseGoods message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_PurchaseGoods
     * @static
     * @param {C2S_PurchaseGoods} message C2S_PurchaseGoods
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_PurchaseGoods.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.shopType = 0;
            object.layer = 0;
            object.goodsID = 0;
            object.count = 0;
        }
        if (message.shopType != null && message.hasOwnProperty("shopType"))
            object.shopType = message.shopType;
        if (message.layer != null && message.hasOwnProperty("layer"))
            object.layer = message.layer;
        if (message.goodsID != null && message.hasOwnProperty("goodsID"))
            object.goodsID = message.goodsID;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this C2S_PurchaseGoods to JSON.
     * @function toJSON
     * @memberof C2S_PurchaseGoods
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_PurchaseGoods.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_PurchaseGoods;
})();

$root.S2C_PurchaseGoods = (function() {

    /**
     * Properties of a S2C_PurchaseGoods.
     * @exports IS2C_PurchaseGoods
     * @interface IS2C_PurchaseGoods
     * @property {IShopInfoPB} shopInfo S2C_PurchaseGoods shopInfo
     */

    /**
     * Constructs a new S2C_PurchaseGoods.
     * @exports S2C_PurchaseGoods
     * @classdesc Represents a S2C_PurchaseGoods.
     * @implements IS2C_PurchaseGoods
     * @constructor
     * @param {IS2C_PurchaseGoods=} [properties] Properties to set
     */
    function S2C_PurchaseGoods(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_PurchaseGoods shopInfo.
     * @member {IShopInfoPB} shopInfo
     * @memberof S2C_PurchaseGoods
     * @instance
     */
    S2C_PurchaseGoods.prototype.shopInfo = null;

    /**
     * Creates a new S2C_PurchaseGoods instance using the specified properties.
     * @function create
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {IS2C_PurchaseGoods=} [properties] Properties to set
     * @returns {S2C_PurchaseGoods} S2C_PurchaseGoods instance
     */
    S2C_PurchaseGoods.create = function create(properties) {
        return new S2C_PurchaseGoods(properties);
    };

    /**
     * Encodes the specified S2C_PurchaseGoods message. Does not implicitly {@link S2C_PurchaseGoods.verify|verify} messages.
     * @function encode
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {IS2C_PurchaseGoods} message S2C_PurchaseGoods message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PurchaseGoods.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        $root.ShopInfoPB.encode(message.shopInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_PurchaseGoods message, length delimited. Does not implicitly {@link S2C_PurchaseGoods.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {IS2C_PurchaseGoods} message S2C_PurchaseGoods message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_PurchaseGoods.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_PurchaseGoods message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_PurchaseGoods} S2C_PurchaseGoods
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PurchaseGoods.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_PurchaseGoods();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.shopInfo = $root.ShopInfoPB.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("shopInfo"))
            throw $util.ProtocolError("missing required 'shopInfo'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_PurchaseGoods message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_PurchaseGoods} S2C_PurchaseGoods
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_PurchaseGoods.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_PurchaseGoods message.
     * @function verify
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_PurchaseGoods.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        {
            var error = $root.ShopInfoPB.verify(message.shopInfo);
            if (error)
                return "shopInfo." + error;
        }
        return null;
    };

    /**
     * Creates a S2C_PurchaseGoods message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_PurchaseGoods} S2C_PurchaseGoods
     */
    S2C_PurchaseGoods.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_PurchaseGoods)
            return object;
        var message = new $root.S2C_PurchaseGoods();
        if (object.shopInfo != null) {
            if (typeof object.shopInfo !== "object")
                throw TypeError(".S2C_PurchaseGoods.shopInfo: object expected");
            message.shopInfo = $root.ShopInfoPB.fromObject(object.shopInfo);
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_PurchaseGoods message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_PurchaseGoods
     * @static
     * @param {S2C_PurchaseGoods} message S2C_PurchaseGoods
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_PurchaseGoods.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.shopInfo = null;
        if (message.shopInfo != null && message.hasOwnProperty("shopInfo"))
            object.shopInfo = $root.ShopInfoPB.toObject(message.shopInfo, options);
        return object;
    };

    /**
     * Converts this S2C_PurchaseGoods to JSON.
     * @function toJSON
     * @memberof S2C_PurchaseGoods
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_PurchaseGoods.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_PurchaseGoods;
})();

$root.C2S_HeiShi = (function() {

    /**
     * Properties of a C2S_HeiShi.
     * @exports IC2S_HeiShi
     * @interface IC2S_HeiShi
     * @property {HeiShiCmdType} cmdType C2S_HeiShi cmdType
     * @property {number|null} [selectItemID] C2S_HeiShi selectItemID
     */

    /**
     * Constructs a new C2S_HeiShi.
     * @exports C2S_HeiShi
     * @classdesc Represents a C2S_HeiShi.
     * @implements IC2S_HeiShi
     * @constructor
     * @param {IC2S_HeiShi=} [properties] Properties to set
     */
    function C2S_HeiShi(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_HeiShi cmdType.
     * @member {HeiShiCmdType} cmdType
     * @memberof C2S_HeiShi
     * @instance
     */
    C2S_HeiShi.prototype.cmdType = 1;

    /**
     * C2S_HeiShi selectItemID.
     * @member {number} selectItemID
     * @memberof C2S_HeiShi
     * @instance
     */
    C2S_HeiShi.prototype.selectItemID = 0;

    /**
     * Creates a new C2S_HeiShi instance using the specified properties.
     * @function create
     * @memberof C2S_HeiShi
     * @static
     * @param {IC2S_HeiShi=} [properties] Properties to set
     * @returns {C2S_HeiShi} C2S_HeiShi instance
     */
    C2S_HeiShi.create = function create(properties) {
        return new C2S_HeiShi(properties);
    };

    /**
     * Encodes the specified C2S_HeiShi message. Does not implicitly {@link C2S_HeiShi.verify|verify} messages.
     * @function encode
     * @memberof C2S_HeiShi
     * @static
     * @param {IC2S_HeiShi} message C2S_HeiShi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_HeiShi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.selectItemID != null && message.hasOwnProperty("selectItemID"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.selectItemID);
        return writer;
    };

    /**
     * Encodes the specified C2S_HeiShi message, length delimited. Does not implicitly {@link C2S_HeiShi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_HeiShi
     * @static
     * @param {IC2S_HeiShi} message C2S_HeiShi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_HeiShi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_HeiShi message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_HeiShi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_HeiShi} C2S_HeiShi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_HeiShi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_HeiShi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                message.selectItemID = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_HeiShi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_HeiShi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_HeiShi} C2S_HeiShi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_HeiShi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_HeiShi message.
     * @function verify
     * @memberof C2S_HeiShi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_HeiShi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
        case 3:
            break;
        }
        if (message.selectItemID != null && message.hasOwnProperty("selectItemID"))
            if (!$util.isInteger(message.selectItemID))
                return "selectItemID: integer expected";
        return null;
    };

    /**
     * Creates a C2S_HeiShi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_HeiShi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_HeiShi} C2S_HeiShi
     */
    C2S_HeiShi.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_HeiShi)
            return object;
        var message = new $root.C2S_HeiShi();
        switch (object.cmdType) {
        case "EnterHeiShi_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "SelectShop_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        case "Reconnect_Cmd":
        case 3:
            message.cmdType = 3;
            break;
        }
        if (object.selectItemID != null)
            message.selectItemID = object.selectItemID | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_HeiShi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_HeiShi
     * @static
     * @param {C2S_HeiShi} message C2S_HeiShi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_HeiShi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmdType = options.enums === String ? "EnterHeiShi_Cmd" : 1;
            object.selectItemID = 0;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.HeiShiCmdType[message.cmdType] : message.cmdType;
        if (message.selectItemID != null && message.hasOwnProperty("selectItemID"))
            object.selectItemID = message.selectItemID;
        return object;
    };

    /**
     * Converts this C2S_HeiShi to JSON.
     * @function toJSON
     * @memberof C2S_HeiShi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_HeiShi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_HeiShi;
})();

$root.S2C_HeiShi = (function() {

    /**
     * Properties of a S2C_HeiShi.
     * @exports IS2C_HeiShi
     * @interface IS2C_HeiShi
     * @property {HeiShiCmdType} cmdType S2C_HeiShi cmdType
     * @property {Array.<number>|null} [heiShiList] S2C_HeiShi heiShiList
     * @property {Array.<IResourceMsg>|null} [reward] S2C_HeiShi reward
     * @property {IHeiShiConsumeInfoPB|null} [heiShiConsume] S2C_HeiShi heiShiConsume
     * @property {number|Long|null} [countDown] S2C_HeiShi countDown
     * @property {number|null} [gameState] S2C_HeiShi gameState
     * @property {number|null} [selectItemID] S2C_HeiShi selectItemID
     */

    /**
     * Constructs a new S2C_HeiShi.
     * @exports S2C_HeiShi
     * @classdesc Represents a S2C_HeiShi.
     * @implements IS2C_HeiShi
     * @constructor
     * @param {IS2C_HeiShi=} [properties] Properties to set
     */
    function S2C_HeiShi(properties) {
        this.heiShiList = [];
        this.reward = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_HeiShi cmdType.
     * @member {HeiShiCmdType} cmdType
     * @memberof S2C_HeiShi
     * @instance
     */
    S2C_HeiShi.prototype.cmdType = 1;

    /**
     * S2C_HeiShi heiShiList.
     * @member {Array.<number>} heiShiList
     * @memberof S2C_HeiShi
     * @instance
     */
    S2C_HeiShi.prototype.heiShiList = $util.emptyArray;

    /**
     * S2C_HeiShi reward.
     * @member {Array.<IResourceMsg>} reward
     * @memberof S2C_HeiShi
     * @instance
     */
    S2C_HeiShi.prototype.reward = $util.emptyArray;

    /**
     * S2C_HeiShi heiShiConsume.
     * @member {IHeiShiConsumeInfoPB|null|undefined} heiShiConsume
     * @memberof S2C_HeiShi
     * @instance
     */
    S2C_HeiShi.prototype.heiShiConsume = null;

    /**
     * S2C_HeiShi countDown.
     * @member {number|Long} countDown
     * @memberof S2C_HeiShi
     * @instance
     */
    S2C_HeiShi.prototype.countDown = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_HeiShi gameState.
     * @member {number} gameState
     * @memberof S2C_HeiShi
     * @instance
     */
    S2C_HeiShi.prototype.gameState = 0;

    /**
     * S2C_HeiShi selectItemID.
     * @member {number} selectItemID
     * @memberof S2C_HeiShi
     * @instance
     */
    S2C_HeiShi.prototype.selectItemID = 0;

    /**
     * Creates a new S2C_HeiShi instance using the specified properties.
     * @function create
     * @memberof S2C_HeiShi
     * @static
     * @param {IS2C_HeiShi=} [properties] Properties to set
     * @returns {S2C_HeiShi} S2C_HeiShi instance
     */
    S2C_HeiShi.create = function create(properties) {
        return new S2C_HeiShi(properties);
    };

    /**
     * Encodes the specified S2C_HeiShi message. Does not implicitly {@link S2C_HeiShi.verify|verify} messages.
     * @function encode
     * @memberof S2C_HeiShi
     * @static
     * @param {IS2C_HeiShi} message S2C_HeiShi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_HeiShi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.heiShiList != null && message.heiShiList.length)
            for (var i = 0; i < message.heiShiList.length; ++i)
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heiShiList[i]);
        if (message.reward != null && message.reward.length)
            for (var i = 0; i < message.reward.length; ++i)
                $root.ResourceMsg.encode(message.reward[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.heiShiConsume != null && message.hasOwnProperty("heiShiConsume"))
            $root.HeiShiConsumeInfoPB.encode(message.heiShiConsume, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.countDown != null && message.hasOwnProperty("countDown"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.countDown);
        if (message.gameState != null && message.hasOwnProperty("gameState"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.gameState);
        if (message.selectItemID != null && message.hasOwnProperty("selectItemID"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.selectItemID);
        return writer;
    };

    /**
     * Encodes the specified S2C_HeiShi message, length delimited. Does not implicitly {@link S2C_HeiShi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_HeiShi
     * @static
     * @param {IS2C_HeiShi} message S2C_HeiShi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_HeiShi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_HeiShi message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_HeiShi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_HeiShi} S2C_HeiShi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_HeiShi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_HeiShi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                if (!(message.heiShiList && message.heiShiList.length))
                    message.heiShiList = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.heiShiList.push(reader.int32());
                } else
                    message.heiShiList.push(reader.int32());
                break;
            case 3:
                if (!(message.reward && message.reward.length))
                    message.reward = [];
                message.reward.push($root.ResourceMsg.decode(reader, reader.uint32()));
                break;
            case 4:
                message.heiShiConsume = $root.HeiShiConsumeInfoPB.decode(reader, reader.uint32());
                break;
            case 5:
                message.countDown = reader.int64();
                break;
            case 6:
                message.gameState = reader.int32();
                break;
            case 7:
                message.selectItemID = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_HeiShi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_HeiShi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_HeiShi} S2C_HeiShi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_HeiShi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_HeiShi message.
     * @function verify
     * @memberof S2C_HeiShi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_HeiShi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
        case 3:
            break;
        }
        if (message.heiShiList != null && message.hasOwnProperty("heiShiList")) {
            if (!Array.isArray(message.heiShiList))
                return "heiShiList: array expected";
            for (var i = 0; i < message.heiShiList.length; ++i)
                if (!$util.isInteger(message.heiShiList[i]))
                    return "heiShiList: integer[] expected";
        }
        if (message.reward != null && message.hasOwnProperty("reward")) {
            if (!Array.isArray(message.reward))
                return "reward: array expected";
            for (var i = 0; i < message.reward.length; ++i) {
                var error = $root.ResourceMsg.verify(message.reward[i]);
                if (error)
                    return "reward." + error;
            }
        }
        if (message.heiShiConsume != null && message.hasOwnProperty("heiShiConsume")) {
            var error = $root.HeiShiConsumeInfoPB.verify(message.heiShiConsume);
            if (error)
                return "heiShiConsume." + error;
        }
        if (message.countDown != null && message.hasOwnProperty("countDown"))
            if (!$util.isInteger(message.countDown) && !(message.countDown && $util.isInteger(message.countDown.low) && $util.isInteger(message.countDown.high)))
                return "countDown: integer|Long expected";
        if (message.gameState != null && message.hasOwnProperty("gameState"))
            if (!$util.isInteger(message.gameState))
                return "gameState: integer expected";
        if (message.selectItemID != null && message.hasOwnProperty("selectItemID"))
            if (!$util.isInteger(message.selectItemID))
                return "selectItemID: integer expected";
        return null;
    };

    /**
     * Creates a S2C_HeiShi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_HeiShi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_HeiShi} S2C_HeiShi
     */
    S2C_HeiShi.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_HeiShi)
            return object;
        var message = new $root.S2C_HeiShi();
        switch (object.cmdType) {
        case "EnterHeiShi_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "SelectShop_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        case "Reconnect_Cmd":
        case 3:
            message.cmdType = 3;
            break;
        }
        if (object.heiShiList) {
            if (!Array.isArray(object.heiShiList))
                throw TypeError(".S2C_HeiShi.heiShiList: array expected");
            message.heiShiList = [];
            for (var i = 0; i < object.heiShiList.length; ++i)
                message.heiShiList[i] = object.heiShiList[i] | 0;
        }
        if (object.reward) {
            if (!Array.isArray(object.reward))
                throw TypeError(".S2C_HeiShi.reward: array expected");
            message.reward = [];
            for (var i = 0; i < object.reward.length; ++i) {
                if (typeof object.reward[i] !== "object")
                    throw TypeError(".S2C_HeiShi.reward: object expected");
                message.reward[i] = $root.ResourceMsg.fromObject(object.reward[i]);
            }
        }
        if (object.heiShiConsume != null) {
            if (typeof object.heiShiConsume !== "object")
                throw TypeError(".S2C_HeiShi.heiShiConsume: object expected");
            message.heiShiConsume = $root.HeiShiConsumeInfoPB.fromObject(object.heiShiConsume);
        }
        if (object.countDown != null)
            if ($util.Long)
                (message.countDown = $util.Long.fromValue(object.countDown)).unsigned = false;
            else if (typeof object.countDown === "string")
                message.countDown = parseInt(object.countDown, 10);
            else if (typeof object.countDown === "number")
                message.countDown = object.countDown;
            else if (typeof object.countDown === "object")
                message.countDown = new $util.LongBits(object.countDown.low >>> 0, object.countDown.high >>> 0).toNumber();
        if (object.gameState != null)
            message.gameState = object.gameState | 0;
        if (object.selectItemID != null)
            message.selectItemID = object.selectItemID | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_HeiShi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_HeiShi
     * @static
     * @param {S2C_HeiShi} message S2C_HeiShi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_HeiShi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.heiShiList = [];
            object.reward = [];
        }
        if (options.defaults) {
            object.cmdType = options.enums === String ? "EnterHeiShi_Cmd" : 1;
            object.heiShiConsume = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.countDown = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.countDown = options.longs === String ? "0" : 0;
            object.gameState = 0;
            object.selectItemID = 0;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.HeiShiCmdType[message.cmdType] : message.cmdType;
        if (message.heiShiList && message.heiShiList.length) {
            object.heiShiList = [];
            for (var j = 0; j < message.heiShiList.length; ++j)
                object.heiShiList[j] = message.heiShiList[j];
        }
        if (message.reward && message.reward.length) {
            object.reward = [];
            for (var j = 0; j < message.reward.length; ++j)
                object.reward[j] = $root.ResourceMsg.toObject(message.reward[j], options);
        }
        if (message.heiShiConsume != null && message.hasOwnProperty("heiShiConsume"))
            object.heiShiConsume = $root.HeiShiConsumeInfoPB.toObject(message.heiShiConsume, options);
        if (message.countDown != null && message.hasOwnProperty("countDown"))
            if (typeof message.countDown === "number")
                object.countDown = options.longs === String ? String(message.countDown) : message.countDown;
            else
                object.countDown = options.longs === String ? $util.Long.prototype.toString.call(message.countDown) : options.longs === Number ? new $util.LongBits(message.countDown.low >>> 0, message.countDown.high >>> 0).toNumber() : message.countDown;
        if (message.gameState != null && message.hasOwnProperty("gameState"))
            object.gameState = message.gameState;
        if (message.selectItemID != null && message.hasOwnProperty("selectItemID"))
            object.selectItemID = message.selectItemID;
        return object;
    };

    /**
     * Converts this S2C_HeiShi to JSON.
     * @function toJSON
     * @memberof S2C_HeiShi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_HeiShi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_HeiShi;
})();

/**
 * ShopType enum.
 * @exports ShopType
 * @enum {string}
 * @property {number} LingBaoGe=1 LingBaoGe value
 * @property {number} CangShuGe=2 CangShuGe value
 * @property {number} XianYuGe=3 XianYuGe value
 * @property {number} WeiWangGe=4 WeiWangGe value
 * @property {number} Recharge=5 Recharge value
 */
$root.ShopType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "LingBaoGe"] = 1;
    values[valuesById[2] = "CangShuGe"] = 2;
    values[valuesById[3] = "XianYuGe"] = 3;
    values[valuesById[4] = "WeiWangGe"] = 4;
    values[valuesById[5] = "Recharge"] = 5;
    return values;
})();

/**
 * ShopStateType enum.
 * @exports ShopStateType
 * @enum {string}
 * @property {number} AlreaStudy=-1 AlreaStudy value
 * @property {number} Normal=0 Normal value
 */
$root.ShopStateType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[-1] = "AlreaStudy"] = -1;
    values[valuesById[0] = "Normal"] = 0;
    return values;
})();

$root.ShopInfoPB = (function() {

    /**
     * Properties of a ShopInfoPB.
     * @exports IShopInfoPB
     * @interface IShopInfoPB
     * @property {number} shopType ShopInfoPB shopType
     * @property {number} layer ShopInfoPB layer
     * @property {number} goodsID ShopInfoPB goodsID
     * @property {number} remainCount ShopInfoPB remainCount
     */

    /**
     * Constructs a new ShopInfoPB.
     * @exports ShopInfoPB
     * @classdesc Represents a ShopInfoPB.
     * @implements IShopInfoPB
     * @constructor
     * @param {IShopInfoPB=} [properties] Properties to set
     */
    function ShopInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ShopInfoPB shopType.
     * @member {number} shopType
     * @memberof ShopInfoPB
     * @instance
     */
    ShopInfoPB.prototype.shopType = 0;

    /**
     * ShopInfoPB layer.
     * @member {number} layer
     * @memberof ShopInfoPB
     * @instance
     */
    ShopInfoPB.prototype.layer = 0;

    /**
     * ShopInfoPB goodsID.
     * @member {number} goodsID
     * @memberof ShopInfoPB
     * @instance
     */
    ShopInfoPB.prototype.goodsID = 0;

    /**
     * ShopInfoPB remainCount.
     * @member {number} remainCount
     * @memberof ShopInfoPB
     * @instance
     */
    ShopInfoPB.prototype.remainCount = 0;

    /**
     * Creates a new ShopInfoPB instance using the specified properties.
     * @function create
     * @memberof ShopInfoPB
     * @static
     * @param {IShopInfoPB=} [properties] Properties to set
     * @returns {ShopInfoPB} ShopInfoPB instance
     */
    ShopInfoPB.create = function create(properties) {
        return new ShopInfoPB(properties);
    };

    /**
     * Encodes the specified ShopInfoPB message. Does not implicitly {@link ShopInfoPB.verify|verify} messages.
     * @function encode
     * @memberof ShopInfoPB
     * @static
     * @param {IShopInfoPB} message ShopInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShopInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.shopType);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.layer);
        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.goodsID);
        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.remainCount);
        return writer;
    };

    /**
     * Encodes the specified ShopInfoPB message, length delimited. Does not implicitly {@link ShopInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ShopInfoPB
     * @static
     * @param {IShopInfoPB} message ShopInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShopInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ShopInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof ShopInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ShopInfoPB} ShopInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShopInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ShopInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.shopType = reader.int32();
                break;
            case 2:
                message.layer = reader.int32();
                break;
            case 3:
                message.goodsID = reader.int32();
                break;
            case 4:
                message.remainCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("shopType"))
            throw $util.ProtocolError("missing required 'shopType'", { instance: message });
        if (!message.hasOwnProperty("layer"))
            throw $util.ProtocolError("missing required 'layer'", { instance: message });
        if (!message.hasOwnProperty("goodsID"))
            throw $util.ProtocolError("missing required 'goodsID'", { instance: message });
        if (!message.hasOwnProperty("remainCount"))
            throw $util.ProtocolError("missing required 'remainCount'", { instance: message });
        return message;
    };

    /**
     * Decodes a ShopInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ShopInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ShopInfoPB} ShopInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShopInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ShopInfoPB message.
     * @function verify
     * @memberof ShopInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ShopInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.shopType))
            return "shopType: integer expected";
        if (!$util.isInteger(message.layer))
            return "layer: integer expected";
        if (!$util.isInteger(message.goodsID))
            return "goodsID: integer expected";
        if (!$util.isInteger(message.remainCount))
            return "remainCount: integer expected";
        return null;
    };

    /**
     * Creates a ShopInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ShopInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ShopInfoPB} ShopInfoPB
     */
    ShopInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.ShopInfoPB)
            return object;
        var message = new $root.ShopInfoPB();
        if (object.shopType != null)
            message.shopType = object.shopType | 0;
        if (object.layer != null)
            message.layer = object.layer | 0;
        if (object.goodsID != null)
            message.goodsID = object.goodsID | 0;
        if (object.remainCount != null)
            message.remainCount = object.remainCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a ShopInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ShopInfoPB
     * @static
     * @param {ShopInfoPB} message ShopInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ShopInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.shopType = 0;
            object.layer = 0;
            object.goodsID = 0;
            object.remainCount = 0;
        }
        if (message.shopType != null && message.hasOwnProperty("shopType"))
            object.shopType = message.shopType;
        if (message.layer != null && message.hasOwnProperty("layer"))
            object.layer = message.layer;
        if (message.goodsID != null && message.hasOwnProperty("goodsID"))
            object.goodsID = message.goodsID;
        if (message.remainCount != null && message.hasOwnProperty("remainCount"))
            object.remainCount = message.remainCount;
        return object;
    };

    /**
     * Converts this ShopInfoPB to JSON.
     * @function toJSON
     * @memberof ShopInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ShopInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ShopInfoPB;
})();

/**
 * HeiShiCmdType enum.
 * @exports HeiShiCmdType
 * @enum {string}
 * @property {number} EnterHeiShi_Cmd=1 EnterHeiShi_Cmd value
 * @property {number} SelectShop_Cmd=2 SelectShop_Cmd value
 * @property {number} Reconnect_Cmd=3 Reconnect_Cmd value
 */
$root.HeiShiCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "EnterHeiShi_Cmd"] = 1;
    values[valuesById[2] = "SelectShop_Cmd"] = 2;
    values[valuesById[3] = "Reconnect_Cmd"] = 3;
    return values;
})();

/**
 * HeiShiGameState enum.
 * @exports HeiShiGameState
 * @enum {string}
 * @property {number} Select=1 Select value
 * @property {number} Stop=2 Stop value
 */
$root.HeiShiGameState = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "Select"] = 1;
    values[valuesById[2] = "Stop"] = 2;
    return values;
})();

$root.HeiShiConsumeInfoPB = (function() {

    /**
     * Properties of an HeiShiConsumeInfoPB.
     * @exports IHeiShiConsumeInfoPB
     * @interface IHeiShiConsumeInfoPB
     * @property {boolean} avaliableLevel HeiShiConsumeInfoPB avaliableLevel
     * @property {number} avaliableCount HeiShiConsumeInfoPB avaliableCount
     * @property {Array.<IResourceMsg>|null} [resource] HeiShiConsumeInfoPB resource
     */

    /**
     * Constructs a new HeiShiConsumeInfoPB.
     * @exports HeiShiConsumeInfoPB
     * @classdesc Represents an HeiShiConsumeInfoPB.
     * @implements IHeiShiConsumeInfoPB
     * @constructor
     * @param {IHeiShiConsumeInfoPB=} [properties] Properties to set
     */
    function HeiShiConsumeInfoPB(properties) {
        this.resource = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HeiShiConsumeInfoPB avaliableLevel.
     * @member {boolean} avaliableLevel
     * @memberof HeiShiConsumeInfoPB
     * @instance
     */
    HeiShiConsumeInfoPB.prototype.avaliableLevel = false;

    /**
     * HeiShiConsumeInfoPB avaliableCount.
     * @member {number} avaliableCount
     * @memberof HeiShiConsumeInfoPB
     * @instance
     */
    HeiShiConsumeInfoPB.prototype.avaliableCount = 0;

    /**
     * HeiShiConsumeInfoPB resource.
     * @member {Array.<IResourceMsg>} resource
     * @memberof HeiShiConsumeInfoPB
     * @instance
     */
    HeiShiConsumeInfoPB.prototype.resource = $util.emptyArray;

    /**
     * Creates a new HeiShiConsumeInfoPB instance using the specified properties.
     * @function create
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {IHeiShiConsumeInfoPB=} [properties] Properties to set
     * @returns {HeiShiConsumeInfoPB} HeiShiConsumeInfoPB instance
     */
    HeiShiConsumeInfoPB.create = function create(properties) {
        return new HeiShiConsumeInfoPB(properties);
    };

    /**
     * Encodes the specified HeiShiConsumeInfoPB message. Does not implicitly {@link HeiShiConsumeInfoPB.verify|verify} messages.
     * @function encode
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {IHeiShiConsumeInfoPB} message HeiShiConsumeInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HeiShiConsumeInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.avaliableLevel);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.avaliableCount);
        if (message.resource != null && message.resource.length)
            for (var i = 0; i < message.resource.length; ++i)
                $root.ResourceMsg.encode(message.resource[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified HeiShiConsumeInfoPB message, length delimited. Does not implicitly {@link HeiShiConsumeInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {IHeiShiConsumeInfoPB} message HeiShiConsumeInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HeiShiConsumeInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an HeiShiConsumeInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HeiShiConsumeInfoPB} HeiShiConsumeInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HeiShiConsumeInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HeiShiConsumeInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.avaliableLevel = reader.bool();
                break;
            case 2:
                message.avaliableCount = reader.int32();
                break;
            case 3:
                if (!(message.resource && message.resource.length))
                    message.resource = [];
                message.resource.push($root.ResourceMsg.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("avaliableLevel"))
            throw $util.ProtocolError("missing required 'avaliableLevel'", { instance: message });
        if (!message.hasOwnProperty("avaliableCount"))
            throw $util.ProtocolError("missing required 'avaliableCount'", { instance: message });
        return message;
    };

    /**
     * Decodes an HeiShiConsumeInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HeiShiConsumeInfoPB} HeiShiConsumeInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HeiShiConsumeInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an HeiShiConsumeInfoPB message.
     * @function verify
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HeiShiConsumeInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.avaliableLevel !== "boolean")
            return "avaliableLevel: boolean expected";
        if (!$util.isInteger(message.avaliableCount))
            return "avaliableCount: integer expected";
        if (message.resource != null && message.hasOwnProperty("resource")) {
            if (!Array.isArray(message.resource))
                return "resource: array expected";
            for (var i = 0; i < message.resource.length; ++i) {
                var error = $root.ResourceMsg.verify(message.resource[i]);
                if (error)
                    return "resource." + error;
            }
        }
        return null;
    };

    /**
     * Creates an HeiShiConsumeInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HeiShiConsumeInfoPB} HeiShiConsumeInfoPB
     */
    HeiShiConsumeInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.HeiShiConsumeInfoPB)
            return object;
        var message = new $root.HeiShiConsumeInfoPB();
        if (object.avaliableLevel != null)
            message.avaliableLevel = Boolean(object.avaliableLevel);
        if (object.avaliableCount != null)
            message.avaliableCount = object.avaliableCount | 0;
        if (object.resource) {
            if (!Array.isArray(object.resource))
                throw TypeError(".HeiShiConsumeInfoPB.resource: array expected");
            message.resource = [];
            for (var i = 0; i < object.resource.length; ++i) {
                if (typeof object.resource[i] !== "object")
                    throw TypeError(".HeiShiConsumeInfoPB.resource: object expected");
                message.resource[i] = $root.ResourceMsg.fromObject(object.resource[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an HeiShiConsumeInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HeiShiConsumeInfoPB
     * @static
     * @param {HeiShiConsumeInfoPB} message HeiShiConsumeInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HeiShiConsumeInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.resource = [];
        if (options.defaults) {
            object.avaliableLevel = false;
            object.avaliableCount = 0;
        }
        if (message.avaliableLevel != null && message.hasOwnProperty("avaliableLevel"))
            object.avaliableLevel = message.avaliableLevel;
        if (message.avaliableCount != null && message.hasOwnProperty("avaliableCount"))
            object.avaliableCount = message.avaliableCount;
        if (message.resource && message.resource.length) {
            object.resource = [];
            for (var j = 0; j < message.resource.length; ++j)
                object.resource[j] = $root.ResourceMsg.toObject(message.resource[j], options);
        }
        return object;
    };

    /**
     * Converts this HeiShiConsumeInfoPB to JSON.
     * @function toJSON
     * @memberof HeiShiConsumeInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HeiShiConsumeInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return HeiShiConsumeInfoPB;
})();

$root.TimeResponse = (function() {

    /**
     * Properties of a TimeResponse.
     * @exports ITimeResponse
     * @interface ITimeResponse
     * @property {number|null} [hour] TimeResponse hour
     */

    /**
     * Constructs a new TimeResponse.
     * @exports TimeResponse
     * @classdesc Represents a TimeResponse.
     * @implements ITimeResponse
     * @constructor
     * @param {ITimeResponse=} [properties] Properties to set
     */
    function TimeResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TimeResponse hour.
     * @member {number} hour
     * @memberof TimeResponse
     * @instance
     */
    TimeResponse.prototype.hour = 0;

    /**
     * Creates a new TimeResponse instance using the specified properties.
     * @function create
     * @memberof TimeResponse
     * @static
     * @param {ITimeResponse=} [properties] Properties to set
     * @returns {TimeResponse} TimeResponse instance
     */
    TimeResponse.create = function create(properties) {
        return new TimeResponse(properties);
    };

    /**
     * Encodes the specified TimeResponse message. Does not implicitly {@link TimeResponse.verify|verify} messages.
     * @function encode
     * @memberof TimeResponse
     * @static
     * @param {ITimeResponse} message TimeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TimeResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hour != null && message.hasOwnProperty("hour"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hour);
        return writer;
    };

    /**
     * Encodes the specified TimeResponse message, length delimited. Does not implicitly {@link TimeResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TimeResponse
     * @static
     * @param {ITimeResponse} message TimeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TimeResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TimeResponse message from the specified reader or buffer.
     * @function decode
     * @memberof TimeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TimeResponse} TimeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TimeResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TimeResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hour = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TimeResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TimeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TimeResponse} TimeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TimeResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TimeResponse message.
     * @function verify
     * @memberof TimeResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TimeResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hour != null && message.hasOwnProperty("hour"))
            if (!$util.isInteger(message.hour))
                return "hour: integer expected";
        return null;
    };

    /**
     * Creates a TimeResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TimeResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TimeResponse} TimeResponse
     */
    TimeResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.TimeResponse)
            return object;
        var message = new $root.TimeResponse();
        if (object.hour != null)
            message.hour = object.hour | 0;
        return message;
    };

    /**
     * Creates a plain object from a TimeResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TimeResponse
     * @static
     * @param {TimeResponse} message TimeResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TimeResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.hour = 0;
        if (message.hour != null && message.hasOwnProperty("hour"))
            object.hour = message.hour;
        return object;
    };

    /**
     * Converts this TimeResponse to JSON.
     * @function toJSON
     * @memberof TimeResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TimeResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TimeResponse;
})();

$root.C2S_Wudao = (function() {

    /**
     * Properties of a C2S_Wudao.
     * @exports IC2S_Wudao
     * @interface IC2S_Wudao
     */

    /**
     * Constructs a new C2S_Wudao.
     * @exports C2S_Wudao
     * @classdesc Represents a C2S_Wudao.
     * @implements IC2S_Wudao
     * @constructor
     * @param {IC2S_Wudao=} [properties] Properties to set
     */
    function C2S_Wudao(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_Wudao instance using the specified properties.
     * @function create
     * @memberof C2S_Wudao
     * @static
     * @param {IC2S_Wudao=} [properties] Properties to set
     * @returns {C2S_Wudao} C2S_Wudao instance
     */
    C2S_Wudao.create = function create(properties) {
        return new C2S_Wudao(properties);
    };

    /**
     * Encodes the specified C2S_Wudao message. Does not implicitly {@link C2S_Wudao.verify|verify} messages.
     * @function encode
     * @memberof C2S_Wudao
     * @static
     * @param {IC2S_Wudao} message C2S_Wudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Wudao.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_Wudao message, length delimited. Does not implicitly {@link C2S_Wudao.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_Wudao
     * @static
     * @param {IC2S_Wudao} message C2S_Wudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_Wudao.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_Wudao message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_Wudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_Wudao} C2S_Wudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Wudao.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_Wudao();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_Wudao message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_Wudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_Wudao} C2S_Wudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_Wudao.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_Wudao message.
     * @function verify
     * @memberof C2S_Wudao
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_Wudao.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_Wudao message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_Wudao
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_Wudao} C2S_Wudao
     */
    C2S_Wudao.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_Wudao)
            return object;
        return new $root.C2S_Wudao();
    };

    /**
     * Creates a plain object from a C2S_Wudao message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_Wudao
     * @static
     * @param {C2S_Wudao} message C2S_Wudao
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_Wudao.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_Wudao to JSON.
     * @function toJSON
     * @memberof C2S_Wudao
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_Wudao.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_Wudao;
})();

$root.S2C_Wudao = (function() {

    /**
     * Properties of a S2C_Wudao.
     * @exports IS2C_Wudao
     * @interface IS2C_Wudao
     * @property {number|null} [level] S2C_Wudao level
     * @property {number|Long|null} [time] S2C_Wudao time
     * @property {Array.<number>|null} [attr] S2C_Wudao attr
     */

    /**
     * Constructs a new S2C_Wudao.
     * @exports S2C_Wudao
     * @classdesc Represents a S2C_Wudao.
     * @implements IS2C_Wudao
     * @constructor
     * @param {IS2C_Wudao=} [properties] Properties to set
     */
    function S2C_Wudao(properties) {
        this.attr = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_Wudao level.
     * @member {number} level
     * @memberof S2C_Wudao
     * @instance
     */
    S2C_Wudao.prototype.level = 0;

    /**
     * S2C_Wudao time.
     * @member {number|Long} time
     * @memberof S2C_Wudao
     * @instance
     */
    S2C_Wudao.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * S2C_Wudao attr.
     * @member {Array.<number>} attr
     * @memberof S2C_Wudao
     * @instance
     */
    S2C_Wudao.prototype.attr = $util.emptyArray;

    /**
     * Creates a new S2C_Wudao instance using the specified properties.
     * @function create
     * @memberof S2C_Wudao
     * @static
     * @param {IS2C_Wudao=} [properties] Properties to set
     * @returns {S2C_Wudao} S2C_Wudao instance
     */
    S2C_Wudao.create = function create(properties) {
        return new S2C_Wudao(properties);
    };

    /**
     * Encodes the specified S2C_Wudao message. Does not implicitly {@link S2C_Wudao.verify|verify} messages.
     * @function encode
     * @memberof S2C_Wudao
     * @static
     * @param {IS2C_Wudao} message S2C_Wudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Wudao.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
        if (message.time != null && message.hasOwnProperty("time"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
        if (message.attr != null && message.attr.length)
            for (var i = 0; i < message.attr.length; ++i)
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.attr[i]);
        return writer;
    };

    /**
     * Encodes the specified S2C_Wudao message, length delimited. Does not implicitly {@link S2C_Wudao.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_Wudao
     * @static
     * @param {IS2C_Wudao} message S2C_Wudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_Wudao.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_Wudao message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_Wudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_Wudao} S2C_Wudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Wudao.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_Wudao();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.level = reader.int32();
                break;
            case 2:
                message.time = reader.int64();
                break;
            case 3:
                if (!(message.attr && message.attr.length))
                    message.attr = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.attr.push(reader.int32());
                } else
                    message.attr.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_Wudao message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_Wudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_Wudao} S2C_Wudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_Wudao.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_Wudao message.
     * @function verify
     * @memberof S2C_Wudao
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_Wudao.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.time != null && message.hasOwnProperty("time"))
            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
        if (message.attr != null && message.hasOwnProperty("attr")) {
            if (!Array.isArray(message.attr))
                return "attr: array expected";
            for (var i = 0; i < message.attr.length; ++i)
                if (!$util.isInteger(message.attr[i]))
                    return "attr: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a S2C_Wudao message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_Wudao
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_Wudao} S2C_Wudao
     */
    S2C_Wudao.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_Wudao)
            return object;
        var message = new $root.S2C_Wudao();
        if (object.level != null)
            message.level = object.level | 0;
        if (object.time != null)
            if ($util.Long)
                (message.time = $util.Long.fromValue(object.time)).unsigned = false;
            else if (typeof object.time === "string")
                message.time = parseInt(object.time, 10);
            else if (typeof object.time === "number")
                message.time = object.time;
            else if (typeof object.time === "object")
                message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
        if (object.attr) {
            if (!Array.isArray(object.attr))
                throw TypeError(".S2C_Wudao.attr: array expected");
            message.attr = [];
            for (var i = 0; i < object.attr.length; ++i)
                message.attr[i] = object.attr[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_Wudao message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_Wudao
     * @static
     * @param {S2C_Wudao} message S2C_Wudao
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_Wudao.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.attr = [];
        if (options.defaults) {
            object.level = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.time = options.longs === String ? "0" : 0;
        }
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.time != null && message.hasOwnProperty("time"))
            if (typeof message.time === "number")
                object.time = options.longs === String ? String(message.time) : message.time;
            else
                object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
        if (message.attr && message.attr.length) {
            object.attr = [];
            for (var j = 0; j < message.attr.length; ++j)
                object.attr[j] = message.attr[j];
        }
        return object;
    };

    /**
     * Converts this S2C_Wudao to JSON.
     * @function toJSON
     * @memberof S2C_Wudao
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_Wudao.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_Wudao;
})();

$root.C2S_UpgradeWudao = (function() {

    /**
     * Properties of a C2S_UpgradeWudao.
     * @exports IC2S_UpgradeWudao
     * @interface IC2S_UpgradeWudao
     */

    /**
     * Constructs a new C2S_UpgradeWudao.
     * @exports C2S_UpgradeWudao
     * @classdesc Represents a C2S_UpgradeWudao.
     * @implements IC2S_UpgradeWudao
     * @constructor
     * @param {IC2S_UpgradeWudao=} [properties] Properties to set
     */
    function C2S_UpgradeWudao(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new C2S_UpgradeWudao instance using the specified properties.
     * @function create
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {IC2S_UpgradeWudao=} [properties] Properties to set
     * @returns {C2S_UpgradeWudao} C2S_UpgradeWudao instance
     */
    C2S_UpgradeWudao.create = function create(properties) {
        return new C2S_UpgradeWudao(properties);
    };

    /**
     * Encodes the specified C2S_UpgradeWudao message. Does not implicitly {@link C2S_UpgradeWudao.verify|verify} messages.
     * @function encode
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {IC2S_UpgradeWudao} message C2S_UpgradeWudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradeWudao.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified C2S_UpgradeWudao message, length delimited. Does not implicitly {@link C2S_UpgradeWudao.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {IC2S_UpgradeWudao} message C2S_UpgradeWudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradeWudao.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_UpgradeWudao message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_UpgradeWudao} C2S_UpgradeWudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradeWudao.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_UpgradeWudao();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_UpgradeWudao message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_UpgradeWudao} C2S_UpgradeWudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradeWudao.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_UpgradeWudao message.
     * @function verify
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_UpgradeWudao.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a C2S_UpgradeWudao message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_UpgradeWudao} C2S_UpgradeWudao
     */
    C2S_UpgradeWudao.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_UpgradeWudao)
            return object;
        return new $root.C2S_UpgradeWudao();
    };

    /**
     * Creates a plain object from a C2S_UpgradeWudao message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_UpgradeWudao
     * @static
     * @param {C2S_UpgradeWudao} message C2S_UpgradeWudao
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_UpgradeWudao.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this C2S_UpgradeWudao to JSON.
     * @function toJSON
     * @memberof C2S_UpgradeWudao
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_UpgradeWudao.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_UpgradeWudao;
})();

$root.S2C_UpgradeWudao = (function() {

    /**
     * Properties of a S2C_UpgradeWudao.
     * @exports IS2C_UpgradeWudao
     * @interface IS2C_UpgradeWudao
     * @property {number|null} [level] S2C_UpgradeWudao level
     */

    /**
     * Constructs a new S2C_UpgradeWudao.
     * @exports S2C_UpgradeWudao
     * @classdesc Represents a S2C_UpgradeWudao.
     * @implements IS2C_UpgradeWudao
     * @constructor
     * @param {IS2C_UpgradeWudao=} [properties] Properties to set
     */
    function S2C_UpgradeWudao(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_UpgradeWudao level.
     * @member {number} level
     * @memberof S2C_UpgradeWudao
     * @instance
     */
    S2C_UpgradeWudao.prototype.level = 0;

    /**
     * Creates a new S2C_UpgradeWudao instance using the specified properties.
     * @function create
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {IS2C_UpgradeWudao=} [properties] Properties to set
     * @returns {S2C_UpgradeWudao} S2C_UpgradeWudao instance
     */
    S2C_UpgradeWudao.create = function create(properties) {
        return new S2C_UpgradeWudao(properties);
    };

    /**
     * Encodes the specified S2C_UpgradeWudao message. Does not implicitly {@link S2C_UpgradeWudao.verify|verify} messages.
     * @function encode
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {IS2C_UpgradeWudao} message S2C_UpgradeWudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradeWudao.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
        return writer;
    };

    /**
     * Encodes the specified S2C_UpgradeWudao message, length delimited. Does not implicitly {@link S2C_UpgradeWudao.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {IS2C_UpgradeWudao} message S2C_UpgradeWudao message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradeWudao.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_UpgradeWudao message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_UpgradeWudao} S2C_UpgradeWudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradeWudao.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_UpgradeWudao();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.level = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_UpgradeWudao message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_UpgradeWudao} S2C_UpgradeWudao
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradeWudao.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_UpgradeWudao message.
     * @function verify
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_UpgradeWudao.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        return null;
    };

    /**
     * Creates a S2C_UpgradeWudao message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_UpgradeWudao} S2C_UpgradeWudao
     */
    S2C_UpgradeWudao.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_UpgradeWudao)
            return object;
        var message = new $root.S2C_UpgradeWudao();
        if (object.level != null)
            message.level = object.level | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_UpgradeWudao message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_UpgradeWudao
     * @static
     * @param {S2C_UpgradeWudao} message S2C_UpgradeWudao
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_UpgradeWudao.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.level = 0;
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        return object;
    };

    /**
     * Converts this S2C_UpgradeWudao to JSON.
     * @function toJSON
     * @memberof S2C_UpgradeWudao
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_UpgradeWudao.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_UpgradeWudao;
})();

$root.C2S_UpgradeWudaoAttr = (function() {

    /**
     * Properties of a C2S_UpgradeWudaoAttr.
     * @exports IC2S_UpgradeWudaoAttr
     * @interface IC2S_UpgradeWudaoAttr
     * @property {number|null} [index] C2S_UpgradeWudaoAttr index
     */

    /**
     * Constructs a new C2S_UpgradeWudaoAttr.
     * @exports C2S_UpgradeWudaoAttr
     * @classdesc Represents a C2S_UpgradeWudaoAttr.
     * @implements IC2S_UpgradeWudaoAttr
     * @constructor
     * @param {IC2S_UpgradeWudaoAttr=} [properties] Properties to set
     */
    function C2S_UpgradeWudaoAttr(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_UpgradeWudaoAttr index.
     * @member {number} index
     * @memberof C2S_UpgradeWudaoAttr
     * @instance
     */
    C2S_UpgradeWudaoAttr.prototype.index = 0;

    /**
     * Creates a new C2S_UpgradeWudaoAttr instance using the specified properties.
     * @function create
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {IC2S_UpgradeWudaoAttr=} [properties] Properties to set
     * @returns {C2S_UpgradeWudaoAttr} C2S_UpgradeWudaoAttr instance
     */
    C2S_UpgradeWudaoAttr.create = function create(properties) {
        return new C2S_UpgradeWudaoAttr(properties);
    };

    /**
     * Encodes the specified C2S_UpgradeWudaoAttr message. Does not implicitly {@link C2S_UpgradeWudaoAttr.verify|verify} messages.
     * @function encode
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {IC2S_UpgradeWudaoAttr} message C2S_UpgradeWudaoAttr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradeWudaoAttr.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.index != null && message.hasOwnProperty("index"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
        return writer;
    };

    /**
     * Encodes the specified C2S_UpgradeWudaoAttr message, length delimited. Does not implicitly {@link C2S_UpgradeWudaoAttr.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {IC2S_UpgradeWudaoAttr} message C2S_UpgradeWudaoAttr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_UpgradeWudaoAttr.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_UpgradeWudaoAttr message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_UpgradeWudaoAttr} C2S_UpgradeWudaoAttr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradeWudaoAttr.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_UpgradeWudaoAttr();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.index = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a C2S_UpgradeWudaoAttr message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_UpgradeWudaoAttr} C2S_UpgradeWudaoAttr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_UpgradeWudaoAttr.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_UpgradeWudaoAttr message.
     * @function verify
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_UpgradeWudaoAttr.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index))
                return "index: integer expected";
        return null;
    };

    /**
     * Creates a C2S_UpgradeWudaoAttr message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_UpgradeWudaoAttr} C2S_UpgradeWudaoAttr
     */
    C2S_UpgradeWudaoAttr.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_UpgradeWudaoAttr)
            return object;
        var message = new $root.C2S_UpgradeWudaoAttr();
        if (object.index != null)
            message.index = object.index | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_UpgradeWudaoAttr message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_UpgradeWudaoAttr
     * @static
     * @param {C2S_UpgradeWudaoAttr} message C2S_UpgradeWudaoAttr
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_UpgradeWudaoAttr.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.index = 0;
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        return object;
    };

    /**
     * Converts this C2S_UpgradeWudaoAttr to JSON.
     * @function toJSON
     * @memberof C2S_UpgradeWudaoAttr
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_UpgradeWudaoAttr.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_UpgradeWudaoAttr;
})();

$root.S2C_UpgradeWudaoAttr = (function() {

    /**
     * Properties of a S2C_UpgradeWudaoAttr.
     * @exports IS2C_UpgradeWudaoAttr
     * @interface IS2C_UpgradeWudaoAttr
     * @property {number|null} [level] S2C_UpgradeWudaoAttr level
     * @property {number|null} [index] S2C_UpgradeWudaoAttr index
     */

    /**
     * Constructs a new S2C_UpgradeWudaoAttr.
     * @exports S2C_UpgradeWudaoAttr
     * @classdesc Represents a S2C_UpgradeWudaoAttr.
     * @implements IS2C_UpgradeWudaoAttr
     * @constructor
     * @param {IS2C_UpgradeWudaoAttr=} [properties] Properties to set
     */
    function S2C_UpgradeWudaoAttr(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_UpgradeWudaoAttr level.
     * @member {number} level
     * @memberof S2C_UpgradeWudaoAttr
     * @instance
     */
    S2C_UpgradeWudaoAttr.prototype.level = 0;

    /**
     * S2C_UpgradeWudaoAttr index.
     * @member {number} index
     * @memberof S2C_UpgradeWudaoAttr
     * @instance
     */
    S2C_UpgradeWudaoAttr.prototype.index = 0;

    /**
     * Creates a new S2C_UpgradeWudaoAttr instance using the specified properties.
     * @function create
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {IS2C_UpgradeWudaoAttr=} [properties] Properties to set
     * @returns {S2C_UpgradeWudaoAttr} S2C_UpgradeWudaoAttr instance
     */
    S2C_UpgradeWudaoAttr.create = function create(properties) {
        return new S2C_UpgradeWudaoAttr(properties);
    };

    /**
     * Encodes the specified S2C_UpgradeWudaoAttr message. Does not implicitly {@link S2C_UpgradeWudaoAttr.verify|verify} messages.
     * @function encode
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {IS2C_UpgradeWudaoAttr} message S2C_UpgradeWudaoAttr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradeWudaoAttr.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
        if (message.index != null && message.hasOwnProperty("index"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
        return writer;
    };

    /**
     * Encodes the specified S2C_UpgradeWudaoAttr message, length delimited. Does not implicitly {@link S2C_UpgradeWudaoAttr.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {IS2C_UpgradeWudaoAttr} message S2C_UpgradeWudaoAttr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_UpgradeWudaoAttr.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_UpgradeWudaoAttr message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_UpgradeWudaoAttr} S2C_UpgradeWudaoAttr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradeWudaoAttr.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_UpgradeWudaoAttr();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.level = reader.int32();
                break;
            case 2:
                message.index = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a S2C_UpgradeWudaoAttr message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_UpgradeWudaoAttr} S2C_UpgradeWudaoAttr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_UpgradeWudaoAttr.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_UpgradeWudaoAttr message.
     * @function verify
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_UpgradeWudaoAttr.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.level != null && message.hasOwnProperty("level"))
            if (!$util.isInteger(message.level))
                return "level: integer expected";
        if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index))
                return "index: integer expected";
        return null;
    };

    /**
     * Creates a S2C_UpgradeWudaoAttr message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_UpgradeWudaoAttr} S2C_UpgradeWudaoAttr
     */
    S2C_UpgradeWudaoAttr.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_UpgradeWudaoAttr)
            return object;
        var message = new $root.S2C_UpgradeWudaoAttr();
        if (object.level != null)
            message.level = object.level | 0;
        if (object.index != null)
            message.index = object.index | 0;
        return message;
    };

    /**
     * Creates a plain object from a S2C_UpgradeWudaoAttr message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_UpgradeWudaoAttr
     * @static
     * @param {S2C_UpgradeWudaoAttr} message S2C_UpgradeWudaoAttr
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_UpgradeWudaoAttr.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.level = 0;
            object.index = 0;
        }
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = message.level;
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        return object;
    };

    /**
     * Converts this S2C_UpgradeWudaoAttr to JSON.
     * @function toJSON
     * @memberof S2C_UpgradeWudaoAttr
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_UpgradeWudaoAttr.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_UpgradeWudaoAttr;
})();

/**
 * XiSuiCmdType enum.
 * @exports XiSuiCmdType
 * @enum {string}
 * @property {number} GetXiSui_Cmd=1 GetXiSui_Cmd value
 * @property {number} XiSui_Cmd=2 XiSui_Cmd value
 */
$root.XiSuiCmdType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "GetXiSui_Cmd"] = 1;
    values[valuesById[2] = "XiSui_Cmd"] = 2;
    return values;
})();

$root.C2S_XiSui = (function() {

    /**
     * Properties of a C2S_XiSui.
     * @exports IC2S_XiSui
     * @interface IC2S_XiSui
     * @property {XiSuiCmdType} cmdType C2S_XiSui cmdType
     * @property {number|null} [jie] C2S_XiSui jie
     */

    /**
     * Constructs a new C2S_XiSui.
     * @exports C2S_XiSui
     * @classdesc Represents a C2S_XiSui.
     * @implements IC2S_XiSui
     * @constructor
     * @param {IC2S_XiSui=} [properties] Properties to set
     */
    function C2S_XiSui(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * C2S_XiSui cmdType.
     * @member {XiSuiCmdType} cmdType
     * @memberof C2S_XiSui
     * @instance
     */
    C2S_XiSui.prototype.cmdType = 1;

    /**
     * C2S_XiSui jie.
     * @member {number} jie
     * @memberof C2S_XiSui
     * @instance
     */
    C2S_XiSui.prototype.jie = 0;

    /**
     * Creates a new C2S_XiSui instance using the specified properties.
     * @function create
     * @memberof C2S_XiSui
     * @static
     * @param {IC2S_XiSui=} [properties] Properties to set
     * @returns {C2S_XiSui} C2S_XiSui instance
     */
    C2S_XiSui.create = function create(properties) {
        return new C2S_XiSui(properties);
    };

    /**
     * Encodes the specified C2S_XiSui message. Does not implicitly {@link C2S_XiSui.verify|verify} messages.
     * @function encode
     * @memberof C2S_XiSui
     * @static
     * @param {IC2S_XiSui} message C2S_XiSui message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_XiSui.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.jie != null && message.hasOwnProperty("jie"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.jie);
        return writer;
    };

    /**
     * Encodes the specified C2S_XiSui message, length delimited. Does not implicitly {@link C2S_XiSui.verify|verify} messages.
     * @function encodeDelimited
     * @memberof C2S_XiSui
     * @static
     * @param {IC2S_XiSui} message C2S_XiSui message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    C2S_XiSui.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a C2S_XiSui message from the specified reader or buffer.
     * @function decode
     * @memberof C2S_XiSui
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {C2S_XiSui} C2S_XiSui
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_XiSui.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.C2S_XiSui();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                message.jie = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a C2S_XiSui message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof C2S_XiSui
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {C2S_XiSui} C2S_XiSui
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    C2S_XiSui.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a C2S_XiSui message.
     * @function verify
     * @memberof C2S_XiSui
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    C2S_XiSui.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
            break;
        }
        if (message.jie != null && message.hasOwnProperty("jie"))
            if (!$util.isInteger(message.jie))
                return "jie: integer expected";
        return null;
    };

    /**
     * Creates a C2S_XiSui message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof C2S_XiSui
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {C2S_XiSui} C2S_XiSui
     */
    C2S_XiSui.fromObject = function fromObject(object) {
        if (object instanceof $root.C2S_XiSui)
            return object;
        var message = new $root.C2S_XiSui();
        switch (object.cmdType) {
        case "GetXiSui_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "XiSui_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        }
        if (object.jie != null)
            message.jie = object.jie | 0;
        return message;
    };

    /**
     * Creates a plain object from a C2S_XiSui message. Also converts values to other types if specified.
     * @function toObject
     * @memberof C2S_XiSui
     * @static
     * @param {C2S_XiSui} message C2S_XiSui
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    C2S_XiSui.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.cmdType = options.enums === String ? "GetXiSui_Cmd" : 1;
            object.jie = 0;
        }
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.XiSuiCmdType[message.cmdType] : message.cmdType;
        if (message.jie != null && message.hasOwnProperty("jie"))
            object.jie = message.jie;
        return object;
    };

    /**
     * Converts this C2S_XiSui to JSON.
     * @function toJSON
     * @memberof C2S_XiSui
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    C2S_XiSui.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return C2S_XiSui;
})();

$root.S2C_XiSu = (function() {

    /**
     * Properties of a S2C_XiSu.
     * @exports IS2C_XiSu
     * @interface IS2C_XiSu
     * @property {XiSuiCmdType} cmdType S2C_XiSu cmdType
     * @property {Array.<IXiSuiInfoPB>|null} [xiSuiInfo] S2C_XiSu xiSuiInfo
     */

    /**
     * Constructs a new S2C_XiSu.
     * @exports S2C_XiSu
     * @classdesc Represents a S2C_XiSu.
     * @implements IS2C_XiSu
     * @constructor
     * @param {IS2C_XiSu=} [properties] Properties to set
     */
    function S2C_XiSu(properties) {
        this.xiSuiInfo = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * S2C_XiSu cmdType.
     * @member {XiSuiCmdType} cmdType
     * @memberof S2C_XiSu
     * @instance
     */
    S2C_XiSu.prototype.cmdType = 1;

    /**
     * S2C_XiSu xiSuiInfo.
     * @member {Array.<IXiSuiInfoPB>} xiSuiInfo
     * @memberof S2C_XiSu
     * @instance
     */
    S2C_XiSu.prototype.xiSuiInfo = $util.emptyArray;

    /**
     * Creates a new S2C_XiSu instance using the specified properties.
     * @function create
     * @memberof S2C_XiSu
     * @static
     * @param {IS2C_XiSu=} [properties] Properties to set
     * @returns {S2C_XiSu} S2C_XiSu instance
     */
    S2C_XiSu.create = function create(properties) {
        return new S2C_XiSu(properties);
    };

    /**
     * Encodes the specified S2C_XiSu message. Does not implicitly {@link S2C_XiSu.verify|verify} messages.
     * @function encode
     * @memberof S2C_XiSu
     * @static
     * @param {IS2C_XiSu} message S2C_XiSu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_XiSu.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cmdType);
        if (message.xiSuiInfo != null && message.xiSuiInfo.length)
            for (var i = 0; i < message.xiSuiInfo.length; ++i)
                $root.XiSuiInfoPB.encode(message.xiSuiInfo[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified S2C_XiSu message, length delimited. Does not implicitly {@link S2C_XiSu.verify|verify} messages.
     * @function encodeDelimited
     * @memberof S2C_XiSu
     * @static
     * @param {IS2C_XiSu} message S2C_XiSu message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    S2C_XiSu.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a S2C_XiSu message from the specified reader or buffer.
     * @function decode
     * @memberof S2C_XiSu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {S2C_XiSu} S2C_XiSu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_XiSu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.S2C_XiSu();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cmdType = reader.int32();
                break;
            case 2:
                if (!(message.xiSuiInfo && message.xiSuiInfo.length))
                    message.xiSuiInfo = [];
                message.xiSuiInfo.push($root.XiSuiInfoPB.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cmdType"))
            throw $util.ProtocolError("missing required 'cmdType'", { instance: message });
        return message;
    };

    /**
     * Decodes a S2C_XiSu message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof S2C_XiSu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {S2C_XiSu} S2C_XiSu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    S2C_XiSu.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a S2C_XiSu message.
     * @function verify
     * @memberof S2C_XiSu
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    S2C_XiSu.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.cmdType) {
        default:
            return "cmdType: enum value expected";
        case 1:
        case 2:
            break;
        }
        if (message.xiSuiInfo != null && message.hasOwnProperty("xiSuiInfo")) {
            if (!Array.isArray(message.xiSuiInfo))
                return "xiSuiInfo: array expected";
            for (var i = 0; i < message.xiSuiInfo.length; ++i) {
                var error = $root.XiSuiInfoPB.verify(message.xiSuiInfo[i]);
                if (error)
                    return "xiSuiInfo." + error;
            }
        }
        return null;
    };

    /**
     * Creates a S2C_XiSu message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof S2C_XiSu
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {S2C_XiSu} S2C_XiSu
     */
    S2C_XiSu.fromObject = function fromObject(object) {
        if (object instanceof $root.S2C_XiSu)
            return object;
        var message = new $root.S2C_XiSu();
        switch (object.cmdType) {
        case "GetXiSui_Cmd":
        case 1:
            message.cmdType = 1;
            break;
        case "XiSui_Cmd":
        case 2:
            message.cmdType = 2;
            break;
        }
        if (object.xiSuiInfo) {
            if (!Array.isArray(object.xiSuiInfo))
                throw TypeError(".S2C_XiSu.xiSuiInfo: array expected");
            message.xiSuiInfo = [];
            for (var i = 0; i < object.xiSuiInfo.length; ++i) {
                if (typeof object.xiSuiInfo[i] !== "object")
                    throw TypeError(".S2C_XiSu.xiSuiInfo: object expected");
                message.xiSuiInfo[i] = $root.XiSuiInfoPB.fromObject(object.xiSuiInfo[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a S2C_XiSu message. Also converts values to other types if specified.
     * @function toObject
     * @memberof S2C_XiSu
     * @static
     * @param {S2C_XiSu} message S2C_XiSu
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    S2C_XiSu.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.xiSuiInfo = [];
        if (options.defaults)
            object.cmdType = options.enums === String ? "GetXiSui_Cmd" : 1;
        if (message.cmdType != null && message.hasOwnProperty("cmdType"))
            object.cmdType = options.enums === String ? $root.XiSuiCmdType[message.cmdType] : message.cmdType;
        if (message.xiSuiInfo && message.xiSuiInfo.length) {
            object.xiSuiInfo = [];
            for (var j = 0; j < message.xiSuiInfo.length; ++j)
                object.xiSuiInfo[j] = $root.XiSuiInfoPB.toObject(message.xiSuiInfo[j], options);
        }
        return object;
    };

    /**
     * Converts this S2C_XiSu to JSON.
     * @function toJSON
     * @memberof S2C_XiSu
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    S2C_XiSu.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return S2C_XiSu;
})();

$root.XiSuiInfoPB = (function() {

    /**
     * Properties of a XiSuiInfoPB.
     * @exports IXiSuiInfoPB
     * @interface IXiSuiInfoPB
     * @property {number} jie XiSuiInfoPB jie
     * @property {number} num XiSuiInfoPB num
     */

    /**
     * Constructs a new XiSuiInfoPB.
     * @exports XiSuiInfoPB
     * @classdesc Represents a XiSuiInfoPB.
     * @implements IXiSuiInfoPB
     * @constructor
     * @param {IXiSuiInfoPB=} [properties] Properties to set
     */
    function XiSuiInfoPB(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * XiSuiInfoPB jie.
     * @member {number} jie
     * @memberof XiSuiInfoPB
     * @instance
     */
    XiSuiInfoPB.prototype.jie = 0;

    /**
     * XiSuiInfoPB num.
     * @member {number} num
     * @memberof XiSuiInfoPB
     * @instance
     */
    XiSuiInfoPB.prototype.num = 0;

    /**
     * Creates a new XiSuiInfoPB instance using the specified properties.
     * @function create
     * @memberof XiSuiInfoPB
     * @static
     * @param {IXiSuiInfoPB=} [properties] Properties to set
     * @returns {XiSuiInfoPB} XiSuiInfoPB instance
     */
    XiSuiInfoPB.create = function create(properties) {
        return new XiSuiInfoPB(properties);
    };

    /**
     * Encodes the specified XiSuiInfoPB message. Does not implicitly {@link XiSuiInfoPB.verify|verify} messages.
     * @function encode
     * @memberof XiSuiInfoPB
     * @static
     * @param {IXiSuiInfoPB} message XiSuiInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    XiSuiInfoPB.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.jie);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
        return writer;
    };

    /**
     * Encodes the specified XiSuiInfoPB message, length delimited. Does not implicitly {@link XiSuiInfoPB.verify|verify} messages.
     * @function encodeDelimited
     * @memberof XiSuiInfoPB
     * @static
     * @param {IXiSuiInfoPB} message XiSuiInfoPB message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    XiSuiInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a XiSuiInfoPB message from the specified reader or buffer.
     * @function decode
     * @memberof XiSuiInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {XiSuiInfoPB} XiSuiInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    XiSuiInfoPB.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.XiSuiInfoPB();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.jie = reader.int32();
                break;
            case 2:
                message.num = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("jie"))
            throw $util.ProtocolError("missing required 'jie'", { instance: message });
        if (!message.hasOwnProperty("num"))
            throw $util.ProtocolError("missing required 'num'", { instance: message });
        return message;
    };

    /**
     * Decodes a XiSuiInfoPB message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof XiSuiInfoPB
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {XiSuiInfoPB} XiSuiInfoPB
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    XiSuiInfoPB.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a XiSuiInfoPB message.
     * @function verify
     * @memberof XiSuiInfoPB
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    XiSuiInfoPB.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.jie))
            return "jie: integer expected";
        if (!$util.isInteger(message.num))
            return "num: integer expected";
        return null;
    };

    /**
     * Creates a XiSuiInfoPB message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof XiSuiInfoPB
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {XiSuiInfoPB} XiSuiInfoPB
     */
    XiSuiInfoPB.fromObject = function fromObject(object) {
        if (object instanceof $root.XiSuiInfoPB)
            return object;
        var message = new $root.XiSuiInfoPB();
        if (object.jie != null)
            message.jie = object.jie | 0;
        if (object.num != null)
            message.num = object.num | 0;
        return message;
    };

    /**
     * Creates a plain object from a XiSuiInfoPB message. Also converts values to other types if specified.
     * @function toObject
     * @memberof XiSuiInfoPB
     * @static
     * @param {XiSuiInfoPB} message XiSuiInfoPB
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    XiSuiInfoPB.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.jie = 0;
            object.num = 0;
        }
        if (message.jie != null && message.hasOwnProperty("jie"))
            object.jie = message.jie;
        if (message.num != null && message.hasOwnProperty("num"))
            object.num = message.num;
        return object;
    };

    /**
     * Converts this XiSuiInfoPB to JSON.
     * @function toJSON
     * @memberof XiSuiInfoPB
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    XiSuiInfoPB.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return XiSuiInfoPB;
})();

module.exports = $root;
